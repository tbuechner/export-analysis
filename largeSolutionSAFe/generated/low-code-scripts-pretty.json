[
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.solution\n * @attribute cf.cplace.solution.safe.*WIPLimit\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if the WIP limit is either null or larger than 1\n */\n\nfunction checkIfWIPLimitIsCorrect() {\n    if (page.get(customAttribute) === null) {\n        return;\n    }\n    if (page.get(customAttribute) <= 0) {\n        return \"WIP Limit must be >= 1 or empty\";\n    }\n}\n\nreturn checkIfWIPLimitIsCorrect();",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.funnelWIPLimit"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.solution\n * @attribute cf.cplace.solution.safe.*WIPLimit\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if the WIP limit is either null or larger than 1\n */\n\nfunction checkIfWIPLimitIsCorrect() {\n    if (page.get(customAttribute) === null) {\n        return;\n    }\n    if (page.get(customAttribute) <= 0) {\n        return \"WIP Limit must be >= 1 or empty\";\n    }\n}\n\nreturn checkIfWIPLimitIsCorrect();",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.analyzingWIPLimit"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.solution\n * @attribute cf.cplace.solution.safe.*WIPLimit\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if the WIP limit is either null or larger than 1\n */\n\nfunction checkIfWIPLimitIsCorrect() {\n    if (page.get(customAttribute) === null) {\n        return;\n    }\n    if (page.get(customAttribute) <= 0) {\n        return \"WIP Limit must be >= 1 or empty\";\n    }\n}\n\nreturn checkIfWIPLimitIsCorrect();",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.backlogWIPLimit"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.solution\n * @attribute cf.cplace.solution.safe.*WIPLimit\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if the WIP limit is either null or larger than 1\n */\n\nfunction checkIfWIPLimitIsCorrect() {\n    if (page.get(customAttribute) === null) {\n        return;\n    }\n    if (page.get(customAttribute) <= 0) {\n        return \"WIP Limit must be >= 1 or empty\";\n    }\n}\n\nreturn checkIfWIPLimitIsCorrect();",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.implementingWIPLimit"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.solution\n * @attribute cf.cplace.solution.safe.*WIPLimit\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if the WIP limit is either null or larger than 1\n */\n\nfunction checkIfWIPLimitIsCorrect() {\n    if (page.get(customAttribute) === null) {\n        return;\n    }\n    if (page.get(customAttribute) <= 0) {\n        return \"WIP Limit must be >= 1 or empty\";\n    }\n}\n\nreturn checkIfWIPLimitIsCorrect();",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.validatingWIPLimit"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.solution\n * @attribute cf.cplace.solution.safe.*WIPLimit\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if the WIP limit is either null or larger than 1\n */\n\nfunction checkIfWIPLimitIsCorrect() {\n    if (page.get(customAttribute) === null) {\n        return;\n    }\n    if (page.get(customAttribute) <= 0) {\n        return \"WIP Limit must be >= 1 or empty\";\n    }\n}\n\nreturn checkIfWIPLimitIsCorrect();",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.deployingWIPLimit"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.solution\n * @attribute cf.cplace.solution.safe.*WIPLimit\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if the WIP limit is either null or larger than 1\n */\n\nfunction checkIfWIPLimitIsCorrect() {\n    if (page.get(customAttribute) === null) {\n        return;\n    }\n    if (page.get(customAttribute) <= 0) {\n        return \"WIP Limit must be >= 1 or empty\";\n    }\n}\n\nreturn checkIfWIPLimitIsCorrect();",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.releasingWIPLimit"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.programIncrement\n * @attribute cf.cplace.solution.safe.title\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Automatically creates a Confidence Vote page upon creation of a Programm Increment\n */\n\ncplace.setLogName(\"listener_createConfidenceVote\")\n\nconst CONFIDENCE_VOTE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.confidenceVote\",\n    ATTR: {\n        PROGRAMM_INCREMENT: \"cf.cplace.solution.safe.confidenceVote.PI\",\n        SOLUTION: \"cf.cplace.solution.safe.confidenceVote.solution\",\n    },\n});\n\nconst PROGRAMM_INCREMENT = /** @type {const} */ ({\n    ATTR: {\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n    },\n});\n\nfunction main() {\n    if (!changeEvent.isNew()) {\n        return;\n    }\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>} */\n    const programmIncrement = changeEvent.getEntity();\n    const solution = programmIncrement.get(PROGRAMM_INCREMENT.ATTR.SOLUTION);\n\n    const confidenceVote = cplace.actions().createPage(\n        {\n            space: programmIncrement.getSpaceId(),\n            customType: CONFIDENCE_VOTE.TYPE,\n            customAttributes: {\n                [CONFIDENCE_VOTE.ATTR.PROGRAMM_INCREMENT]: programmIncrement,\n                [CONFIDENCE_VOTE.ATTR.SOLUTION]: solution,\n            },\n        },\n        { setGeneratedName: true }\n    );\n    cplace.log(`${confidenceVote.getName()} created`);\n}\n\nmain()",
        "attributes": [
            "cf.cplace.solution.safe.title"
        ],
        "type_name": "cf.cplace.solution.safe.programIncrement"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.programIncrement\n * @attribute cf.cplace.solution.safe.title\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Automatically set the predecessor of a Program Increment upon creation\n */\n\ncplace.setLogName(\"listener_setPredecessorOnCreation\");\n\nconst DEBUG = true;\n\nconst PROGRAMM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        PERIOD_STATUS: \"cf.cplace.solution.safe.periodStatus\",\n        PREDECESSOR: \"cf.cplace.solution.safe.predecessor\",\n    },\n    ENUM: {\n        PERIOD_STATUS: {\n            DONE: \"#15 - done\",\n            ACTIVE: \"#25 - active\",\n        },\n    },\n});\n\nfunction main() {\n    if (!changeEvent.isNew()) {\n        return;\n    }\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>} */\n    const programmIncrement = changeEvent.getEntity();\n\n    const predecessor = getPreviousPiByDate(programmIncrement);\n\n    if (!predecessor) {\n        DEBUG && cplace.log(\"No predecessor found\");\n        return;\n    }\n\n    DEBUG && cplace.log(\"Predecessor: \" + predecessor);\n\n    cplace.actions().updatePage(programmIncrement, {\n        customAttributes: {\n            [PROGRAMM_INCREMENT.ATTR.PREDECESSOR]: predecessor,\n        },\n    });\n    programmIncrement.registerAttributeForRefresh(PROGRAMM_INCREMENT.ATTR.PREDECESSOR);\n}\n\n/**\n * Get the previous PI by date\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>} programIncrement\n */\nfunction getPreviousPiByDate(programIncrement) {\n    const solution = programIncrement.get(\"cf.cplace.solution.safe.solution\");\n    if (!solution) {\n        return null;\n    }\n    const startDate = programIncrement.get(PROGRAMM_INCREMENT.ATTR.START_DATE);\n    if (!startDate) {\n        return null;\n    }\n\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>[]} */\n    const pisOfSolution = Array.from(\n        solution.getIncomingPages(PROGRAMM_INCREMENT.TYPE, PROGRAMM_INCREMENT.ATTR.SOLUTION)\n    );\n\n    const piDateMap = {};\n    pisOfSolution.forEach((pi) => {\n        if (pi.getId() == programIncrement.getId()) {\n            return;\n        }\n        piDateMap[pi.getId()] = { date: pi.get(PROGRAMM_INCREMENT.ATTR.START_DATE), page: pi };\n    });\n\n    let closestDateDiff = Infinity;\n    let closestPageId = null;\n\n    // Find the closest previous PI to the startDate of the programmIncrement\n    for (const [pageId, data] of Object.entries(piDateMap)) {\n        const pageDate = data.date;\n        const dateDiff = Days.daysBetween(pageDate.withTimeAtStartOfDay(), startDate.withTimeAtStartOfDay()).getDays();\n\n        if (dateDiff > 0 && dateDiff < closestDateDiff) {\n            closestDateDiff = dateDiff;\n            closestPageId = pageId;\n        }\n    }\n    if (!closestPageId) {\n        return null;\n    }\n\n    return piDateMap[closestPageId].page;\n}\n\nmain();",
        "attributes": [
            "cf.cplace.solution.safe.title"
        ],
        "type_name": "cf.cplace.solution.safe.programIncrement"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*ChangeListener on attribute periodStatus of programIncrement type \nwhenever the periodStatus of the PI is changed the periodStatus of the associated features are also updated\nSteps followed to achieve this \n1.get the updated periodStatus of the PI\n2.if the periodStatus is not null get the feature associated with the PI using Features as Program Increment \n3.set the updated periodStatus of the PI to its Features*/\n\ncplace.setLogName('cF - syncProgramIncrementPeriodStatustoFeature');\n\n// Configuration\nconst PI={\n  TYPE:'cf.cplace.solution.safe.programIncrement',\n  ATTR:{\n    periodStatus:'cf.cplace.solution.safe.periodStatus'\n  },\n  refAttr:{\n    pIReferenceAttr:'cf.cplace.solution.safe.programIncrement',\n    mappingRefAttr:'cf.cplace.solution.safe.periodStatus',\n    orderRefAttr:'cf.cplace.solution.safe.order'\n  }\n}\n\nconst FEATURE={\n  TYPE:'cf.cplace.solution.safe.feature',\n  ATTR:{\n    PI:'cf.cplace.solution.safe.programIncrement',\n    periodStatus:'cf.cplace.solution.safe.periodStatus'\n  }\n}\n\n// get changed page\nlet page = changeEvent.getEntity();\n\nlet periodStatus=page.get(PI.ATTR.periodStatus);\ncplace.log(periodStatus);\n\nif(periodStatus == null){\n  return\n}\n\nlet features=page.getIncomingPages(FEATURE.TYPE,FEATURE.ATTR.PI);\n//cplace.log('periodStatus of feature'+features);\n\n\ncplace.each(features,function(feature){\n  cplace.actions().updatePage(feature, {\n\tcustomAttributes: {\n\t\t[FEATURE.ATTR.periodStatus]: periodStatus\n\t\t}\n    });\n \nfeature.registerAttributeForRefresh(FEATURE.ATTR.periodStatus);\n\n})",
        "attributes": [
            "cf.cplace.solution.safe.periodStatus"
        ],
        "type_name": "cf.cplace.solution.safe.programIncrement"
    },
    {
        "type": "cf.cplace.platform.PageAction",
        "code": "/**\n * PAGE ACTION\n * @customType cf.cplace.solution.safe.programIncrement\n * @author unknown\n * @version 1.1\n * @description Updating period status of a program increment\n */\n\ncplace.setLogName(\"pageAction on PI-ProgramIncrement start\");\n\n//Configurations\nconst PI = /** @type {const} */ ({\n  TYPE: \"cf.cplace.solution.safe.programIncrement\",\n  ATTR: {\n    periodStatus: \"cf.cplace.solution.safe.periodStatus\",\n    predecessor: \"cf.cplace.solution.safe.predecessor\",\n  },\n  refAttr: {\n    order: \"cf.cplace.solution.safe.order\",\n  },\n});\nconst PERIOD_STATUS = /** @type {const} */ ({\n  TYPE: \"cf.cplace.solution.safe.periodStatus\",\n  ATTR: {\n    order: \"cf.cplace.solution.safe.order\",\n  },\n});\n\nfunction checkAccess() {\n  /** @type {Page<'cf.cplace.solution.safe.programIncrement'>} */\n  const programIncrement = embeddingPage;\n  let orderarr = [];\n\n  // action should be available only when the periodStatus is not running, not finished and no other PI should have running periodStatus\n  //check all PIs for the periodStatus whether periodStatus 'Running' is present or not\n  let piSearch = new Search();\n  piSearch.add(Filters.space(programIncrement.getSpaceId()));\n  piSearch.add(Filters.type(PI.TYPE));\n  piSearch.add(Filters.customAttributeNonempty(PI.ATTR.periodStatus));\n  /** @type {JIterable<Page<'cf.cplace.solution.safe.programIncrement'>>} */\n  let result = piSearch.findAllPages();\n\n  cplace.each(result, function (pi) {\n    let pStatus = pi.get(PI.ATTR.periodStatus);\n    let porder = pStatus.get(PERIOD_STATUS.ATTR.order);\n    orderarr.push(porder);\n  });\n  cplace.log(orderarr);\n  if (orderarr.indexOf(0) == -1) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction call() {\n  /** @type {Page<'cf.cplace.solution.safe.programIncrement'>} */\n  const programIncrement = embeddingPage;\n  let order = programIncrement.get(PI.ATTR.periodStatus)\n    ? programIncrement.get(PI.ATTR.periodStatus).get(PI.refAttr.order)\n    : null;\n  let update = true;\n  let orderarr1 = [];\n\n  //orderMap is required to get the corresponding periodStatus of the order\n  let orderSearch = new Search();\n  orderSearch.add(Filters.space(programIncrement.getSpaceId()));\n  orderSearch.add(Filters.type(PERIOD_STATUS.TYPE));\n  orderSearch.add(Filters.customAttributeNonempty(PERIOD_STATUS.ATTR.order));\n  /** @type {JIterable<Page<'cf.cplace.solution.safe.periodStatus'>>} */\n  let result = orderSearch.findAllPages();\n\n  let orderMap = new Map();\n  if (result) {\n    cplace.each(result, function (value) {\n      orderMap.set(value.get(PERIOD_STATUS.ATTR.order), value);\n      orderarr1.push(value.get(PERIOD_STATUS.ATTR.order)); // get the order array\n    });\n  }\n  //find the highest order\n  let highorder = Math.max(...orderarr1);\n  cplace.log(highorder);\n  let sarr = [];\n\n  let arr = checkforPredecessorChain(sarr, programIncrement);\n\n  for (let i = 0; i <= highorder; i++) {\n    if (arr[i] == null) {\n      update = false;\n      return {\n        success: false,\n        message: {\n          en: \"Set the predeccessor chain properly\",\n        },\n      };\n    }\n  }\n\n  // update the periodStatus\n  if (update) {\n    updateperiodStatus(programIncrement, 1, orderMap);\n  }\n}\n\nfunction updateperiodStatus(page, orderIncr, orderMap) {\n  let newPeriodStatus = orderMap.get(orderIncr - 1);\n  // update the periodStatus\n  if (newPeriodStatus) {\n    cplace.actions().updatePage(page, {\n      customAttributes: {\n        [PI.ATTR.periodStatus]: newPeriodStatus,\n      },\n    });\n\n    orderIncr += 1;\n\n    // check for the successor PI if successor is present then update its periodStatus\n    // @ts-ignore\n    let successor = Iterables.getFirst(\n      page.getIncomingPages(PI.TYPE, PI.ATTR.predecessor),\n      null\n    );\n    if (successor) {\n      updateperiodStatus(successor, orderIncr, orderMap);\n    }\n  }\n}\n\nfunction checkforPredecessorChain(sarr, page) {\n  // @ts-ignore\n  let successor = Iterables.getFirst(\n    page.getIncomingPages(PI.TYPE, PI.ATTR.predecessor),\n    null\n  );\n  sarr.push(successor);\n  if (successor != null) {\n    cplace.log(successor.getName());\n    checkforPredecessorChain(sarr, successor);\n  } else {\n    cplace.log(\"check the chain\");\n  }\n\n  return sarr;\n}\n\n// @ts-ignore\nreturn {\n  checkAccess,\n  call,\n};",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.programIncrement"
    },
    {
        "type": "cf.cplace.platform.PageAction",
        "code": "cplace.setLogName('pageAction on PI-ProgramIncrement Progress');\n\n//Configurations\nconst PI={\n  TYPE:'cf.cplace.solution.safe.programIncrement',\n  ATTR:{\n    periodStatus:'cf.cplace.solution.safe.periodStatus',\n    predecessor:'cf.cplace.solution.safe.predecessor'\n  },\n  refAttr:{\n  \torder:'cf.cplace.solution.safe.order'\n}\n}\nconst periodStatus={\n  TYPE:'cf.cplace.solution.safe.periodStatus',\n  ATTR:{\n  \torder:'cf.cplace.solution.safe.order'\n}\n}  \n\nlet orderarr=[];\nlet sarr=[];\nlet order = (page.get(PI.ATTR.periodStatus) ? page.get(PI.ATTR.periodStatus).get(PI.refAttr.order) : null);\n\n return {\n   \n   checkAccess: function() {\n              // Pageaction should only be available when the periodStatus is 'Running'\n                if (order == 0) {\n                    return true;\n                }\n                return false;\n            }, \n  \tcall: function() {\n    \treturn doBusinessAction(page);\n  \t}\n}\n \n \n function doBusinessAction(page){\n   \n   let order=(page.get(PI.ATTR.periodStatus) ? page.get(PI.ATTR.periodStatus).get(PI.refAttr.order) : null);\n   let update=true; //setting the flag to check whether the update process should be performed or not\n  \n   \n   /*orderMap is required to get the corresponding periodStatus of the order */\n   let orderSearch=new Search();\n   orderSearch.add(Filters.space(page.getSpaceId()));\n   orderSearch.add(Filters.type(periodStatus.TYPE));\n   orderSearch.add(Filters.customAttributeNonempty(periodStatus.ATTR.order));\n   let result=orderSearch.findAllPages();\n   \n   let orderMap=new Map();\n    if(result){\n       cplace.each(result,function(value){\n         orderMap.set(value.get(periodStatus.ATTR.order),value);\n         orderarr.push(value.get(periodStatus.ATTR.order));\n       });\n    }\n  \n     /*Get the highest order */\n     let highorder=Math.max(...orderarr);\n     cplace.log(highorder);\n     /*check the predecessor chain to be set properly or not*/\n     let arr= checkforPredecessorChain(page); \n     for(let i=0;i<=highorder;i++){\n        if(arr[i]==null){\n          update=false;\n    /*Return the error message if the predecessor chain is not set*/    \n       return {\n            success: false, // default is true\n            message: {\n                en: 'Set the predeccessor chain properly'\n            } \n         }  \n      }\n   }   \n\n     // update the periodStatus \n     if(update){\n        updateperiodStatus(page, order, orderMap);  \n     }\n }\n     \n  \n \n \nfunction updateperiodStatus(page, orderIncr, orderMap) {\n \n   let newPeriodStatus = orderMap.get(orderIncr - 1);\n      \n     if (newPeriodStatus) {\n        cplace.actions().updatePage(page, {\n           customAttributes: {\n            [PI.ATTR.periodStatus]: newPeriodStatus //update the status to the one which comes next in the order (decreased by 1)\n             }\n         });\n     orderIncr += 1;\n            \n     // check for the successor PI if successor is present then update its periodStatus\n     let successor = Iterables.getFirst(page.getIncomingPages(PI.TYPE,PI.ATTR.predecessor), null);\n       \n     if (successor) {\n            updateperiodStatus (successor, orderIncr, orderMap);\n         }\n\t  }\n}\n\n\n function checkforPredecessorChain(page){\n    let successor = Iterables.getFirst(page.getIncomingPages(PI.TYPE,PI.ATTR.predecessor), null);\n    sarr.push(successor);\n    if(successor!=null){\n       cplace.log(successor.getName());\n       checkforPredecessorChain(successor,sarr);\n    }else{\n       cplace.log('check the chain');\n    }\n     \n    return sarr;\n }",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.programIncrement"
    },
    {
        "type": "cf.cplace.platform.PageAction",
        "code": "/**\n * LOWCODE BUTTON\n * @customType cf.cplace.solution.safe.solution\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Set previous current and next pi\n */\n\ncplace.setLogName(\"lowcodebutton_setAsCurrentPi\");\n\nconst PROGRAMM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        PERIOD_STATUS: \"cf.cplace.solution.safe.periodStatus\",\n    },\n    ENUM: {\n        PERIOD_STATUS: {\n            DONE: \"#15 - done\",\n            ACTIVE: \"#25 - active\",\n        },\n    },\n});\n\nconst SOLUTION = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nfunction checkAccess() {\n    return true;\n}\n\nfunction call() {\n    const newState = {\n        \"cf.cplace.solution.safe.previousPi\": {},\n        \"cf.cplace.solution.safe.currentPi\": {},\n        \"cf.cplace.solution.safe.nextPi\": {},\n    };\n\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>} */\n    const programIncrement = embeddingPage;\n    const solution = programIncrement.get(PROGRAMM_INCREMENT.ATTR.SOLUTION);\n\n    if (!solution) {\n        return \"No Solution\";\n    }\n    const currentPi = solution.get(\"cf.cplace.solution.safe.currentPi\");\n\n    if (!currentPi) {\n        return \"No current PI\";\n    }\n\n    newState[\"cf.cplace.solution.safe.previousPi\"] = currentPi;\n    newState[\"cf.cplace.solution.safe.currentPi\"] = programIncrement;\n    const nextPi = getNextPi(programIncrement);\n\n    if (!nextPi) {\n        cplace.error(\"No next PI\");\n        return;\n    }\n\n    cplace.log(`Next PI: ${nextPi}`);\n    newState[\"cf.cplace.solution.safe.nextPi\"] = nextPi;\n\n    cplace.actions().updatePage(solution, {\n        customAttributes: newState,\n    });\n\n    cplace.actions().updatePage(currentPi, {\n        customAttributes: {\n            [PROGRAMM_INCREMENT.ATTR.PERIOD_STATUS]: PROGRAMM_INCREMENT.ENUM.PERIOD_STATUS.DONE,\n        },\n    });\n    cplace.actions().updatePage(programIncrement, {\n        customAttributes: {\n            [PROGRAMM_INCREMENT.ATTR.PERIOD_STATUS]: PROGRAMM_INCREMENT.ENUM.PERIOD_STATUS.ACTIVE,\n        },\n    });\n    programIncrement.registerAttributeForRefresh(PROGRAMM_INCREMENT.ATTR.PERIOD_STATUS);\n}\n\n/**\n *\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>} programIncrement\n */\nfunction getNextPi(programIncrement) {\n    const endDate = programIncrement.get(PROGRAMM_INCREMENT.ATTR.END_DATE);\n    if (!endDate) {\n        return null;\n    }\n    const result = new Search()\n        .add(Filters.type(PROGRAMM_INCREMENT.TYPE))\n        .add(Filters.customAttribute(PROGRAMM_INCREMENT.ATTR.START_DATE).gt(endDate))\n        .addCustomFieldSort(PROGRAMM_INCREMENT.ATTR.START_DATE, false)\n        .findAllPages();\n\n    return Iterables.getFirst(result, null);\n}\n\nreturn { checkAccess, call };",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.programIncrement"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*type:Epic\n*triggering attributes jobSize,businessValue,timeCriticality,riskReduction\n*Calculates Weighted shortest job first\n*/\n\ncplace.setLogName('CL: calculate WSJF');\n\nconst CAPABILITY = {\n    TYPE:'cf.cplace.solution.safe.capability',\n    ATTR: {\n        JOB_SIZE: 'cf.cplace.solution.safe.jobSize',\n        BUSINESS_VALUE: 'cf.cplace.solution.safe.businessValue',\n        TIME_CRITICALITY: 'cf.cplace.solution.safe.timeCriticality',\n        RISK_REDUCTION: 'cf.cplace.solution.safe.riskReduction',\n        WSJF: 'cf.cplace.solution.safe.wsjf'\n    }\n}\n\nfunction main(){\nconst page = changeEvent.getEntity();\n\n// get input parameters for calculation\nconst jobSize = page.get(CAPABILITY.ATTR.JOB_SIZE);\nconst businessValue = page.get(CAPABILITY.ATTR.BUSINESS_VALUE);\nconst timeCriticality = page.get(CAPABILITY.ATTR.TIME_CRITICALITY);\nconst riskReduction = page.get(CAPABILITY.ATTR.RISK_REDUCTION);\n\nconst wSJF = calculateWSJF(jobSize, businessValue, timeCriticality, riskReduction);\ncplace.log('wsjf'+wSJF);\nupdatePage(page, {\n    'cf.cplace.solution.safe.wsjf': wSJF\n}\n);\n}\n\nmain();\n\n/*\n*Calculate the weighted shortest job first(wSJF)\n*@template {keyof CplaceTypes} T\n*@param {number} jobSizeOfEpic\n*@param {number} businessValueOfEpic\n*@param {number} timeCriticalityOfEpic\n*@param {number} riskReductionOfEpic\n*@returns {number} wSJF\n*/\nfunction calculateWSJF(jobSizeOfEpic, businessValueOfEpic, timeCriticalityOfEpic, riskReductionOfEpic) {\n    let wSJF;\n    if (!jobSizeOfEpic || !businessValueOfEpic || !timeCriticalityOfEpic || !riskReductionOfEpic) {\n        //no value if any input parameter is missing\n        wSJF = null;\n    }\n    else {\n        // CoD = value + time + risk\n        let costOfDelay = businessValueOfEpic + timeCriticalityOfEpic + riskReductionOfEpic;\n        // WSJF = CoD / size\n        wSJF = (jobSizeOfEpic > 0 ? Math.round(costOfDelay / jobSizeOfEpic * 100) / 100 : null);\n    }\n    return wSJF;\n}\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n    let key = null;\n    for (key in customAttributes) {\n        if (customAttributes.hasOwnProperty(key)) {\n            page.registerAttributeForRefresh(key)\n        }\n    }\n    return cplace.actions().updatePage(page, {\n        customAttributes: customAttributes,\n    }\n        , {\n            setGeneratedName: true\n        }\n    );\n}",
        "attributes": [
            "cf.cplace.solution.safe.riskReduction",
            "cf.cplace.solution.safe.jobSize",
            "cf.cplace.solution.safe.businessValue",
            "cf.cplace.solution.safe.timeCriticality"
        ],
        "type_name": "cf.cplace.solution.safe.capability"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * @author Rakshit Midha\n * @description Calculates Flow Time metric\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\ncplace.setLogName('changelistener-calculate-flow-time-metric');\n\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY = {\n  TYPE: 'cf.cplace.solution.safe.capability',\n  ATTR: {\n    'ACTUAL_START_DATE': 'cf.cplace.solution.safe.actualStartDate',\n    'ACTUAL_END_DATE': 'cf.cplace.solution.safe.actualEndDate',\n    'FLOW_TIME': 'cf.cplace.solution.safe.flowTime'\n  }\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n\nfunction main(){\nconst capability = changeEvent.getEntity();\n\nconst flowMetric = calculateFlowTimeMetric(capability);\n\nif (flowMetric !== -1) {\n  setFlowTime(capability, flowMetric);\n}\n}\nmain();\n\nfunction calculateFlowTimeMetric(capability) {\n  const actualStartDate = capability.get(CAPABILITY.ATTR.ACTUAL_START_DATE);\n  const actualEndDate = capability.get(CAPABILITY.ATTR.ACTUAL_END_DATE);\n\n  if (!actualStartDate || !actualEndDate) {\n    return -1;\n  }\n\n  if (actualStartDate.equals(actualEndDate)) {\n    return 0;\n  }\n\n  if (actualEndDate.isAfter(actualStartDate)) {\n    return Days.daysBetween(actualStartDate.withTimeAtStartOfDay(), actualEndDate.withTimeAtStartOfDay()).getDays();\n  }\n  \n  return -1;\n}\n\nfunction setFlowTime(capability, flowMetric) {\n  const attributes = {};\n  attributes[CAPABILITY.ATTR.FLOW_TIME] = flowMetric;\n\n  cplace.actions().updatePage(capability, {customAttributes: attributes});\n  capability.registerAttributeForRefresh(CAPABILITY.ATTR.FLOW_TIME);\n}",
        "attributes": [
            "cf.cplace.solution.safe.actualEndDate",
            "cf.cplace.solution.safe.actualStartDate"
        ],
        "type_name": "cf.cplace.solution.safe.capability"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.capability\n * @attribute cf.cplace.solution.safe.features\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Sets the cf.cplace.solution.safe.program attribute of a capability to the programms, which work on features of the capability.\n */\nconst FEATURE = {\n    TYPE: \"cf.cplace.solution.safe.feature\",\n    ATTR: {\n        CAPABILITY: \"cf.cplace.solution.safe.capability\",\n    },\n};\n\n/**\n * Get all features of a capability and store a unique list of the features Programms on the capability\n */\nfunction main() {\n    /** @type {Page<'cf.cplace.solution.safe.capability'>} */\n    const capability = changeEvent.getEntity();\n    /** @type {Page<'cf.cplace.solution.safe.feature'>[]} */\n    // @ts-ignore\n    const features = capability.get(\"cf.cplace.solution.safe.features\")\n\n    const programmIds = features.map((feature) => feature.get(\"cf.cplace.solution.safe.program\")?.getId());\n    const uniqueProgrammIdeas = [...new Set(programmIds)];\n    cplace.log(`Capability ${capability.getName()} unique programms: ${uniqueProgrammIdeas}`);\n    cplace.actions().updatePage(capability, {\n        customAttributes: {\n            // @ts-ignore\n            \"cf.cplace.solution.safe.program\": uniqueProgrammIdeas,\n        },\n    });\n  capability.registerAttributeForRefresh(\"cf.cplace.solution.safe.program\");\n}\nmain();",
        "attributes": [
            "cf.cplace.solution.safe.features"
        ],
        "type_name": "cf.cplace.solution.safe.capability"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.capability\n * @attribute cf.cplace.solution.safe.state\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Sets the start date of the capability once it has entered the funnel and sets the end date once it has been marked as done\n */\n\nconst STATUS = /** @type {const} */ ({\n    ATTR: \"cf.cplace.solution.safe.state\",\n});\n\n/**\n * Update start and end date depending on the capability status\n */\nfunction main() {\n    /** @type {Page<'cf.cplace.solution.safe.capability'>} */\n    const page = changeEvent.getEntity();\n    const status = page.get(STATUS.ATTR);\n\n    if (status === \"#15 - Funnel\") {\n        cplace.actions().updatePage(page, {\n            customAttributes: {\n                \"cf.cplace.solution.safe.actualStartDate\": new DateTime(),\n            },\n        });\n        page.registerAttributeForRefresh(\"cf.cplace.solution.safe.actualStartDate\");\n    }\n    if (status === \"#85 - Done\") {\n        cplace.actions().updatePage(page, {\n            customAttributes: {\n                \"cf.cplace.solution.safe.actualEndDate\": new DateTime(),\n            },\n        });\n        page.registerAttributeForRefresh(\"cf.cplace.solution.safe.actualEndDate\");\n    }\n}\n\nmain();",
        "attributes": [
            "cf.cplace.solution.safe.state"
        ],
        "type_name": "cf.cplace.solution.safe.capability"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * VALIDATOR\n * @customType cf.cplace.solution.safe.capability\n * @attribute cf.cplace.solution.safe.state\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.1\n * @description Checks if a state transition is allowed (a capability has to go through every state one-by-one, jumping, e.g., from \"Funnel\" to \"Done\" is not allowed)\n */\n\nconst DEBUG = false;\n\nconst SOLUTION = {\n    TYPE: \"cf.cplace.solution.safe.solution\",\n};\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n/** Mapping of previous and next state */\nconst STATUS_MAP = /** @type {const} */ ({\n    \"#10 - Draft\": \"#15 - Funnel\",\n    \"#15 - Funnel\": \"#25 - Analyzing\",\n    \"#25 - Analyzing\": \"#35 - Backlog\",\n    \"#35 - Backlog\": \"#45 - Implementing\",\n    \"#45 - Implementing\": \"#55 - Validating\",\n    \"#55 - Validating\": \"#65 - Deploying\",\n    \"#65 - Deploying\": \"#75 - Releasing\",\n    \"#75 - Releasing\": \"#85 - Done\",\n});\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\n/**\n *\n * @param {Page<'cf.cplace.solution.safe.capability'>} page\n * @returns\n */\nfunction checkIfTransitionIsAllowed(page) {\n    /**\n     * don't run on view only\n     */\n    if (!!page.getBuiltinFeatureValue(\"creator\") && page.getId() === page.getRealId()) {\n        return;\n    }\n\n    const newStatus = page.get(CAPABILITY.ATTR.STATE);\n\n    DEBUG && cplace.log(page.getBuiltinFeatureValue(\"creator\"));\n\n    if (!page.getBuiltinFeatureValue(\"creator\")) {\n        // If page is created, only the draft state is allowed\n        DEBUG && cplace.log(\"creation dialog: \" + newStatus);\n        if (newStatus === \"#10 - Draft\") {\n            return;\n        }\n        return messages.get(\"creation-state-not-allowed\");\n    }\n\n    DEBUG && cplace.log(\"New Status: \" + newStatus);\n\n    // Get the real page (with previous values)\n    const search = new Search();\n    search.add(Filters.uid(page.getRealId()));\n    const realPage = Iterables.getFirst(search.findAllPages(), null);\n\n    if (realPage === null) {\n        return;\n    }\n    const currentStatus = realPage.get(CAPABILITY.ATTR.STATE);\n    DEBUG && cplace.log(currentStatus);\n\n    /**\n     * Status hasn't changed\n     */\n    if (currentStatus === newStatus) {\n        return;\n    }\n    if (newStatus === \"#85 - Done\") {\n        return;\n    }\n    // If the new status is not defined as successor in the STATUS MAP, then return an error\n    if (newStatus !== STATUS_MAP[currentStatus]) {\n        return messages.get(\"statechange-not-allowed\");\n    }\n    /** @type {number|null} */\n    const wipLimit = getSolution(page.getSpaceId()).get(WIP_MAP[newStatus]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return;\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(newStatus);\n    if (wipLimit - numberOfCapabilities <= 0) {\n        return messages.get(\"statechange-not-allowed\");\n    }\n}\n\n/**\n *\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\nreturn checkIfTransitionIsAllowed(page);",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.state"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * @author Rakshit Midha\n * @description Validates actual start and end date of the capability\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\ncplace.setLogName('validator-actual-start-and-end-date-capability');\n\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY = {\n  TYPE: 'cf.cplace.solution.safe.capability',\n  ATTR: {\n    'ACTUAL_START_DATE': 'cf.cplace.solution.safe.actualStartDate',\n    'ACTUAL_END_DATE': 'cf.cplace.solution.safe.actualEndDate',\n  }\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n\nconst VALIDATE_START_AND_END_DATES = \"validate-start-and-end-dates\";\nconst capability = page;\n\nreturn validateDates(capability);\n\nfunction validateDates(capability) {\n  let result = null;\n  const actualStartDate = capability.get(CAPABILITY.ATTR.ACTUAL_START_DATE);\n  const actualEndDate = capability.get(CAPABILITY.ATTR.ACTUAL_END_DATE);\n  if (actualStartDate && actualEndDate && actualStartDate.isAfter(actualEndDate)) {\n    result = messages.get(VALIDATE_START_AND_END_DATES);\n  }\n\n  return result;\n}",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.actualStartDate"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/**\n * @author Rakshit Midha\n * @description Validates actual start and end date of the capability\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\ncplace.setLogName('validator-actual-start-and-end-date-capability');\n\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY = {\n  TYPE: 'cf.cplace.solution.safe.capability',\n  ATTR: {\n    'ACTUAL_START_DATE': 'cf.cplace.solution.safe.actualStartDate',\n    'ACTUAL_END_DATE': 'cf.cplace.solution.safe.actualEndDate',\n  }\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n\nconst VALIDATE_START_AND_END_DATES = \"validate-start-and-end-dates\";\nconst capability = page;\n\nreturn validateDates(capability);\n\nfunction validateDates(capability) {\n  let result = null;\n  const actualStartDate = capability.get(CAPABILITY.ATTR.ACTUAL_START_DATE);\n  const actualEndDate = capability.get(CAPABILITY.ATTR.ACTUAL_END_DATE);\n  if (actualStartDate && actualEndDate && actualStartDate.isAfter(actualEndDate)) {\n    result = messages.get(VALIDATE_START_AND_END_DATES);\n  }\n\n  return result;\n}",
        "attributes": null,
        "type_name": "cf.cplace.solution.safe.actualEndDate"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.dependency\n * @attribute cf.cplace.solution.safe.plannedStartA, cf.cplace.solution.safe.dateA, cf.cplace.solution.safe.plannedEndB, cf.cplace.solution.safe.dateB, cf.cplace.solution.safe.type\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Conflict recognition\n */\n\ncplace.setLogName(\"listener_conflictRecognition\");\n\nconst DEBUG = true;\n\nconst DEPENDENCY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.dependency\",\n    ATTR: {\n        A: \"cf.cplace.solution.safe.successor\",\n        START_DATE_A: \"cf.cplace.solution.safe.plannedStartA\",\n        B: \"cf.cplace.solution.safe.predecessor\",\n        END_DATE_B: \"cf.cplace.solution.safe.plannedEndB\",\n        STATUS: \"cf.cplace.solution.safe.status\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n    },\n    ENUM: {\n        TYPE: {\n            BLOCKED_BY: \"blocked by\",\n            RELATED_TO: \"related to\",\n        },\n        STATUS: {\n            IDENTIFIED: \"15 - identified\",\n            CONFLICT: \"25 - conflict\",\n            CONFLICT_RESOLVED: \"35 - resolved\",\n        },\n    },\n});\n\nfunction main() {\n    /** @type {Page<'cf.cplace.solution.safe.dependency'>} */\n    const dependency = changeEvent.getEntity();\n\n    // Check if dependency is blocking\n    if (dependency.get(DEPENDENCY.ATTR.TYPE) !== DEPENDENCY.ENUM.TYPE.BLOCKED_BY) {\n        DEBUG && cplace.log(\"No blocked by\");\n        \n        // If the status is set to \"related to\" and the dependency type is still \"25 - conflict\" we should set the status to \"15 - identified\"\n        if(dependency.get(DEPENDENCY.ATTR.STATUS) !== DEPENDENCY.ENUM.STATUS.CONFLICT){\n            DEBUG && cplace.log(\"No conflict status\");\n            return\n        }\n        cplace.actions().updatePage(dependency, {\n            customAttributes: {\n                [DEPENDENCY.ATTR.STATUS]: DEPENDENCY.ENUM.STATUS.IDENTIFIED,\n            },\n        });\n        dependency.registerAttributeForRefresh(DEPENDENCY.ATTR.STATUS);\n        return;\n    }\n\n    if (!isConflict(dependency)) {\n        DEBUG && cplace.log(\"No conflict\");\n        return;\n    }\n    // Dependency is a conflict\n    cplace.actions().updatePage(dependency, {\n        customAttributes: {\n            [DEPENDENCY.ATTR.STATUS]: DEPENDENCY.ENUM.STATUS.CONFLICT,\n        },\n    });\n    dependency.registerAttributeForRefresh(DEPENDENCY.ATTR.STATUS);\n}\n/**\n * @param {Page<'cf.cplace.solution.safe.dependency'>} dependency\n */\nfunction isConflict(dependency) {\n    const dateA = dependency.get(DEPENDENCY.ATTR.START_DATE_A);\n\n    const dateB = dependency.get(DEPENDENCY.ATTR.END_DATE_B);\n\n    if (dateA && dateB && dateB.isAfter(dateA)) {\n        return true;\n    }\n    return false;\n}\n\n\nmain();",
        "attributes": [
            "cf.cplace.solution.safe.type",
            "cf.cplace.solution.safe.plannedStartA",
            "cf.cplace.solution.safe.plannedEndB"
        ],
        "type_name": "cf.cplace.solution.safe.dependency"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.dependency\n * @attribute cf.cplace.solution.safe.plannedStartA, cf.cplace.solution.safe.dateA, cf.cplace.solution.safe.plannedEndB, cf.cplace.solution.safe.dateB, cf.cplace.solution.safe.type\n * @author Anja Priglmeir\n * @version 1.0\n * @description setting conflict state on capabilities\n */\n\ncplace.setLogName(\"listener_setConflictToCapabilities\");\n\nconst DEBUG = true;\n\nconst DEPENDENCY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.dependency\",\n    ATTR: {\n        A: \"cf.cplace.solution.safe.successor\",\n        START_DATE_A: \"cf.cplace.solution.safe.plannedStartA\",\n        DATE_A: \"cf.cplace.solution.safe.dateA\",\n        B: \"cf.cplace.solution.safe.predecessor\",\n        END_DATE_B: \"cf.cplace.solution.safe.plannedEndB\",\n        DATE_B: \"cf.cplace.solution.safe.dateB\",\n        STATUS: \"cf.cplace.solution.safe.status\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n    },\n    ENUM: {\n        TYPE: {\n            BLOCKED_BY: \"blocked by\",\n            RELATED_TO: \"related to\",\n        },\n        STATUS: {\n            IDENTIFIED: \"15 - identified\",\n            CONFLICT: \"25 - conflict\",\n            CONFLICT_RESOLVED: \"35 - resolved\",\n        },\n    },\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        CONFLICT_STATE: \"cf.cplace.solution.safe.conflictState\"\n    },\n    ENUM: {\n        CONFLICT: '#25 - conflict'\n    }\n});\n\nfunction main() {\n\n    /** @type {Page<'cf.cplace.solution.safe.dependency'>} */\n    const dependency = changeEvent.getEntity();\n\n    const a = dependency.get(DEPENDENCY.ATTR.A);\n    const b = dependency.get(DEPENDENCY.ATTR.B);\n    const status = dependency.get(DEPENDENCY.ATTR.STATUS);\n    \n    /*//case1: a or b changed; re-calculation only necessary if dependency has conflict\n    if (changeEvent.didChange(DEPENDENCY.ATTR.A) && status === DEPENDENCY.ENUM.STATUS.CONFLICT) {\n        //tbd\n        const old_a = '';\n        checkForConflicts(old_a);\n    }\n\n    if (changeEvent.didChange(DEPENDENCY.ATTR.B) && status === DEPENDENCY.ENUM.STATUS.CONFLICT) {\n        //tbd\n        const old_b = '';\n        checkForConflicts(old_b);\n    }*/\n\n    //case2: dependency status changed\n    if (changeEvent.didChange(DEPENDENCY.ATTR.STATUS)) {\n        if (a.getBuiltinFeatureValue('customType') === CAPABILITY.TYPE) {\n            checkForConflicts(a);\n        }\n\n        if (b.getBuiltinFeatureValue('customType') === CAPABILITY.TYPE) {\n            checkForConflicts(b);\n        }\n    }\n}\n\n/**\n * @param {Page<'cf.cplace.solution.safe.dependency'>} dependency\n */\nfunction checkForConflicts(capability) {\n    const dependenciesAsA = capability.getIncomingPages(DEPENDENCY.TYPE, DEPENDENCY.ATTR.A);\n    const dependenciesAsB = capability.getIncomingPages(DEPENDENCY.TYPE, DEPENDENCY.ATTR.B);\n\n    let conflictValue = null;\n\n    cplace.each(dependenciesAsA, dependency => {\n        const status = dependency.get(DEPENDENCY.ATTR.STATUS);\n        if (status === DEPENDENCY.ENUM.STATUS.CONFLICT) {\n            conflictValue = CAPABILITY.ENUM.CONFLICT;\n        }\n    })\n    cplace.each(dependenciesAsB, dependency => {\n        const status = dependency.get(DEPENDENCY.ATTR.STATUS);\n        if (status === DEPENDENCY.ENUM.STATUS.CONFLICT) {\n            conflictValue = CAPABILITY.ENUM.CONFLICT;\n        }\n    })\n    cplace.actions().updatePage(capability, {\n        customAttributes: {\n            [CAPABILITY.ATTR.CONFLICT_STATE]: conflictValue\n        }\n    })\n\n    capability.registerAttributeForRefresh(CAPABILITY.ATTR.CONFLICT_STATE);\n}\n\n\nmain();",
        "attributes": [
            "cf.cplace.solution.safe.status"
        ],
        "type_name": "cf.cplace.solution.safe.dependency"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.dependency\n * @attribute cf.cplace.solution.safe.status\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Sync the dependendy status to the capabilities\n */\ncplace.setLogName(\"listener_syncConflicStateToCapabilities\");\n\nfunction main() {\n    /** @type {Page<'cf.cplace.solution.safe.dependency'>} */\n    const dependency = changeEvent.getEntity();\n\n    const predecessor = dependency.get(\"cf.cplace.solution.safe.predecessor\");\n    const successor = dependency.get(\"cf.cplace.solution.safe.successor\");\n\n    if (!predecessor || !successor) {\n        cplace.log(\"No predecessor or successor found for dependency \" + dependency.getName());\n        return;\n    }\n    cplace.log(\"Updating predecessor\");\n    updateCapabilityConflictState(dependency, predecessor);\n    cplace.log(\"Updating successor\");\n    updateCapabilityConflictState(dependency, successor);\n}\n\n/**\n * Set the cf.cplace.solution.safe.conflictState parameter of the capabilities that are dependent\n * @param {Page<'cf.cplace.solution.safe.dependency'>} dependency\n * @param {Page<\"cf.cplace.solution.safe.capability\" | \"cf.cplace.solution.safe.safeMilestone\">} capabilityOrMilestone\n * @returns\n */\nfunction updateCapabilityConflictState(dependency, capabilityOrMilestone) {\n    const dependencyStatus = dependency.get(\"cf.cplace.solution.safe.status\");\n    /** @type {CplaceTypes[\"cf.cplace.solution.safe.capability\"][\"cf.cplace.solution.safe.conflictState\"]} */\n    let newConflictState;\n    const isCapability =\n        capabilityOrMilestone?.getBuiltinFeatureValue(\"customType\") === \"cf.cplace.solution.safe.capability\";\n\n    if (!isCapability) {\n        // Only the capability has the conflictState\n        return;\n    }\n\n    if (dependencyStatus === \"25 - conflict\") {\n        newConflictState = \"#25 - conflict\";\n    } else {\n        // No conflict\n        newConflictState = null;\n    }\n\n    cplace.actions().updatePage(capabilityOrMilestone, {\n        customAttributes: {\n            \"cf.cplace.solution.safe.conflictState\": newConflictState,\n        },\n    });\n    capabilityOrMilestone.registerAttributeForRefresh(\"cf.cplace.solution.safe.conflictState\");\n}\n\nmain();",
        "attributes": [
            "cf.cplace.solution.safe.status"
        ],
        "type_name": "cf.cplace.solution.safe.dependency"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * CHANGE LISTENER\n * @customType cf.cplace.solution.safe.safeMilestone\n * @attribute cf.cplace.solution.safe.date\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Syncs the milestone date to the start and end date (these are needed for dependencies)\n */\n\nfunction main() {\n    /** @type {Page<'cf.cplace.solution.safe.safeMilestone'>} */\n    const safeMilestone = changeEvent.getEntity();\n\n    const date = safeMilestone.get(\"cf.cplace.solution.safe.date\");\n\n    cplace.actions().updatePage(safeMilestone, {\n        customAttributes: {\n            \"cf.cplace.solution.safe.plannedStart\": date,\n            \"cf.cplace.solution.safe.plannedEnd\": date,\n        },\n    });\n  safeMilestone.registerAttributeForRefresh('cf.cplace.solution.safe.plannedStart')\n  safeMilestone.registerAttributeForRefresh('cf.cplace.solution.safe.plannedEnd')\n}\nmain();",
        "attributes": [
            "cf.cplace.solution.safe.date"
        ],
        "type_name": "cf.cplace.solution.safe.safeMilestone"
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType cf.cplace.solution.safe.solution\n * @layout default layout\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Displays the PI statistics\n */\n\n/**\n * Identifier: highchart-programIncrement-progress\n * Type of chart: multi pie chart\n * Type of search pages: cf.cplace.solution.safe.team, cf.cplace.solution.safe.story\n * Functionality: visualizes different kinds of kpis\n *\n * INSTRUCTIONS TO ADD CHARTS\n * 1. Increase TOTAL_NUMBER_OF_KPIS +1\n * 2. Define Following Values\n *      - CX_TITLE\n *      - CX_ACTUAL\n *      - CX_ACTUAL_PERCENTAGE\n *      - CX_DISPLAY_NUMBER\n *      - CX_DISPLAY_TEXT\n *      - CX_COLOR\n * 3. Create chart\n *      - createChart(CX_TITLE, CX_ACTUAL_PERCENTAGE, CX_DISPLAY_NUMBER, CX_DISPLAY_TEXT, CX_COLOR) {\n *\n *\n * @author Lukas Scheiring (cF)\n * Last edited: 18.08.2022\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName(\"highchart-programStartPage-statistics\");\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\n//CHART COLOURS\nconst COLOURS = {\n    TEXT_COLOR: \"#003653\",\n    BACKGROUND_COLOR: \"#ffffff\",\n    GREY: \"gray\",\n    RED: \"#f30000\",\n    DARK_RED: \"#9e0000\",\n    YELLOW: \"#ffc700\",\n    GREEN: \"#5ab500\",\n    BLUE: \"#A6CAD8\",\n};\n\n//CHART SETTINGS\nconst TOTAL_NUMBER_OF_KPIS = 5;\nconst Y_POSITION = \"40%\";\n\n//LANGUAGE SETTINGS\nconst NAMINGS = {\n    de: {\n        CHART_TITLE: \"\",\n    },\n    en: {\n        CHART_TITLE: \"\",\n    },\n};\n\n//PLACEHOLDER\nconst PROGRAM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        PREDECESSOR: \"cf.cplace.solution.safe.predecessor\",\n        PERIOD_STATUS: \"cf.cplace.solution.safe.periodStatus\",\n        CAPACITY: \"cf.cplace.solution.safe.capacity\"\n    },\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        ACTUAL_START_DATE: \"cf.cplace.solution.safe.actualStartDate\",\n        ACTUAL_END_DATE: \"cf.cplace.solution.safe.actualEndDate\",\n        PROGRAM_INCREMENT: \"cf.cplace.solution.safe.programIncrement\",\n        STATE: \"cf.cplace.solution.safe.state\"\n    },\n    ENUM: {\n        STATE: {\n            DONE: \"#85 - Done\"\n        }\n    }\n});\n\nconst CONFIDENCE_VOTE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.confidenceVote\",\n    ATTR: {\n        PROGRAMM_INCREMENT: \"cf.cplace.solution.safe.confidenceVote.PI\",\n        RESULT: \"cf.cplace.solution.safe.confidenceVote.result\",\n        ONE_FINGER: \"cf.cplace.solution.safe.confidenceVote.oneFinger\",\n        TWO_FINGERS: \"cf.cplace.solution.safe.confidenceVote.twoFingers\",\n        THREE_FINGERS: \"cf.cplace.solution.safe.confidenceVote.threeFingers\",\n        FOUR_FINGERS: \"cf.cplace.solution.safe.confidenceVote.fourFingers\",\n        FIVE_FINGERS: \"cf.cplace.solution.safe.confidenceVote.fiveFingers\",\n    },\n});\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\nlog(\"Start...\");\nlet currentUser = cplace.utils().getCurrentUser();\nconst userLanguage = currentUser.getUserLanguage();\n\n/** @type {Page<'cf.cplace.solution.safe.solution'>} */\nlet solution = embeddingPage;\n\nlet programIncrement = solution.get(\"cf.cplace.solution.safe.currentPi\");\n\nlet chartIndex = 0;\n\n//Container\nlet capabilities = [];\n/** @type {Page<'cf.cplace.solution.safe.confidenceVote'> | undefined} */\nlet confidenceVote;\n\nlet series = [];\nlet yAxis = [];\nlet pane = [];\n\n//Dates\nlet piStartDate = programIncrement.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay();\nlet piEndDate = programIncrement.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay();\nlet today = new DateTime().withTimeAtStartOfDay();\n\n//KPIs\nlet totalDaysOfPI = Days.daysBetween(piStartDate, piEndDate).getDays();\nlet passedDaysOfPI = getPassedDays(piStartDate, piEndDate, today, totalDaysOfPI);\n\nlet totalCapacity = programIncrement.get(PROGRAM_INCREMENT.ATTR.CAPACITY);\nlet velocityOfLastPI = 0;\nlet totalCapabilities = 0;\nlet capabilitiesDone = 0;\nlet confidenceVoteAverage = 0;\n\n//--------------------------------------------------------------------------------------//\n//                                       PROCESSING STAGE                               //\n//--------------------------------------------------------------------------------------//\n\n// Group pages\ncplace.each(pages, (page) => {\n    switch (page.getBuiltinFeatureValue(\"customType\")) {\n        case CAPABILITY.TYPE:\n            capabilities.push(page);\n            break;\n        case CONFIDENCE_VOTE.TYPE:\n            confidenceVote = page;\n            break;\n        default:\n            break;\n    }\n});\n\ntotalCapabilities = capabilities.length\nvelocityOfLastPI = calculateVelocityOfLastPi(programIncrement);\nconfidenceVoteAverage = calculateConfidenceVoteAverage(confidenceVote);\n\ncapabilitiesDone = capabilities.filter(\n    (/** @type {Page<'cf.cplace.solution.safe.capability'>} */ c) =>\n        c.get(CAPABILITY.ATTR.STATE) === CAPABILITY.ENUM.STATE.DONE\n).length;\n\n//--------------------------------------------------------------------------------------//\n//                                       KPIs & CHART                                   //\n//--------------------------------------------------------------------------------------//\n\n//KPI 1 - Story Points done\nconst C1_TITLE = \"Done Capabilities Last PI\";\nconst C1_ACTUAL_VALUE = velocityOfLastPI || 0;\nconst C1_DISPLAY_NUMBER = C1_ACTUAL_VALUE;\nconst C1_DISPLAY_TEXT = \"<b>VELOCITY LAST PI</b><br>\";\nconst C1_COLOR = COLOURS.GREEN;\n\ncreateChart(C1_TITLE, C1_ACTUAL_VALUE, C1_DISPLAY_NUMBER, C1_DISPLAY_TEXT, C1_COLOR);\n\n// KPI 2 - Done Capabilities\nconst C2_TITLE = \"Done Capabilities\";\nconst C2_ACTUAL_PERCENTAGE = Math.round((capabilitiesDone / totalCapabilities) * 100) || 0;\nconst C2_DISPLAY_NUMBER = C2_ACTUAL_PERCENTAGE + \"%\";\nconst C2_DISPLAY_TEXT = \"<b>DONE CAPABILITIES</b><br>\" + capabilitiesDone + \"/\" + totalCapabilities;\nconst C2_COLOR = COLOURS.GREEN;\n\ncreateChart(C2_TITLE, C2_ACTUAL_PERCENTAGE, C2_DISPLAY_NUMBER, C2_DISPLAY_TEXT, C2_COLOR);\n\n// KPI 3 - Load vs Capacity\nconst C3_TITLE = \"Load vs. Capacity\";\nconst C3_ACTUAL_PERCENTAGE = (totalCapacity && Math.round((totalCapabilities / totalCapacity) * 100)) || 0;\nconst C3_DISPLAY_NUMBER = C3_ACTUAL_PERCENTAGE + \"%\";\nconst C3_DISPLAY_TEXT = \"<b>LOAD VS. CAPACITY</b><br>\" + totalCapabilities + \"/\" + totalCapacity;\n\nlet c3_color = COLOURS.GREEN;\nif (Math.round((totalCapabilities / totalCapacity) * 100) >= 90) {\n    c3_color = COLOURS.YELLOW;\n    if (Math.round((totalCapabilities / totalCapacity) * 100) > 100) {\n        c3_color = COLOURS.RED;\n    }\n}\n\ncreateChart(C3_TITLE, C3_ACTUAL_PERCENTAGE, C3_DISPLAY_NUMBER, C3_DISPLAY_TEXT, c3_color);\n\n// KPI 4 - passed days\nconst C4_TITLE = \"Days passed\";\nconst C4_ACTUAL_PERCENTAGE = Math.round((passedDaysOfPI / totalDaysOfPI) * 100) || 0;\nconst C4_DISPLAY_NUMBER = C4_ACTUAL_PERCENTAGE + \"%\";\nconst C4_DISPLAY_TEXT = \"<b>DAYS PASSED</b><br>\" + passedDaysOfPI + \"/\" + totalDaysOfPI;\nconst C4_COLOR = COLOURS.GREEN;\n\ncreateChart(C4_TITLE, C4_ACTUAL_PERCENTAGE, C4_DISPLAY_NUMBER, C4_DISPLAY_TEXT, C4_COLOR);\n\n// KPI 5 - Confidence Vote\nconst C5_TITLE = \"Average Confidence Vote\";\nconst C5_ACTUAL_PERCENTAGE = Math.round((confidenceVoteAverage / 5) * 100) || 0;\nconst C5_DISPLAY_NUMBER = confidenceVoteAverage.toFixed(1);\nconst C5_DISPLAY_TEXT = \"<b>AVG. CONFIDENCE VOTE</b><br>\";\nconst C5_COLOR = getConvidenceVoteColors(confidenceVoteAverage);\n\ncreateChart(C5_TITLE, C5_ACTUAL_PERCENTAGE, C5_DISPLAY_NUMBER, C5_DISPLAY_TEXT, C5_COLOR);\n\nlog(\"End...\");\n\n// @ts-ignore\nreturn {\n    chart: {\n        type: \"solidgauge\",\n    },\n\n    title: {\n        text: NAMINGS[userLanguage].CHART_TITLE,\n    },\n    series: series,\n    yAxis: yAxis,\n    pane: pane,\n    tooltip: {\n        enabled: false,\n    },\n    plotOptions: {\n        solidgauge: {\n            enableMouseTracking: false,\n        },\n    },\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n\nfunction createChart(title, actualRel, displayNumber, displayText, color) {\n    series.push(getSeriesObject(title, actualRel, displayNumber, chartIndex, color));\n    yAxis.push(getYAxisObject(displayText, chartIndex, 0, 100));\n    pane.push(getPaneObject(getXAxisPosition(chartIndex), Y_POSITION));\n    chartIndex++;\n}\n\nfunction getXAxisPosition(kpiIndex) {\n    return (120 * (kpiIndex + 1)) / (TOTAL_NUMBER_OF_KPIS + 1) - 10 + \"%\";\n}\n\nfunction getPassedDays(piStartDate, piEndDate, today, totalDaysOfPI) {\n    if (today.isBefore(piStartDate)) {\n        return 0;\n    }\n    if (piEndDate.isBefore(today)) {\n        return totalDaysOfPI;\n    }\n    // @ts-ignore\n    return Days.daysBetween(piStartDate, today).getDays();\n}\n\nfunction getSeriesObject(title, actual, label, index, color) {\n    return {\n        name: title,\n        data: [\n            {\n                name: title,\n                color: color,\n                y: actual,\n                innerRadius: \"80%\",\n                radius: \"100%\",\n                dataLabels: {\n                    format: '<span style=\"font-size:24px;font-wight: bold\">' + label + \"</span>\",\n                    borderWidth: 0,\n                    color: COLOURS.GREY,\n                    verticalAlign: \"middle\",\n                    useHTML: true,\n                },\n            },\n        ],\n        yAxis: index,\n    };\n}\n\nfunction getYAxisObject(axisTitle, index, min, max) {\n    return {\n        min: min,\n        max: max,\n        pane: index,\n        title: {\n            text: axisTitle,\n            useHTML: true,\n            y: 110,\n        },\n        labels: {\n            enabled: false,\n        },\n        /*stops: [\n            [0.1, COLOURS.GREEN], // green\n            [0.9, COLOURS.YELLOW], // yellow\n            [0.99, COLOURS.RED] // red\n        ],*/\n        lineWidth: 0,\n        tickWidth: 0,\n        tickAmount: 0,\n        minorTickWidth: 0,\n    };\n}\n\nfunction getPaneObject(xPosition, yPosition) {\n    return {\n        center: [xPosition, yPosition],\n        size: \"50%\",\n        startAngle: 0,\n        endAngle: 360,\n        background: {\n            backgroundColor: \"#EEE\",\n            borderColor: null,\n            innerRadius: \"80%\",\n            outerRadius: \"100%\",\n            shape: \"arc\",\n        },\n    };\n}\n\nfunction getConvidenceVoteColors(value) {\n    if (value <= 2) {\n        return COLOURS.RED;\n    } else if (value <= 3) {\n        return COLOURS.YELLOW;\n    } else {\n        return COLOURS.GREEN;\n    }\n}\n\n/**\n * Calculates the average confidence vote\n * @param {Page<'cf.cplace.solution.safe.confidenceVote'> | undefined | null} confidenceVote\n */\nfunction calculateConfidenceVoteAverage(confidenceVote) {\n    if (!confidenceVote) {\n        return 0;\n    }\n    const oneFinger = confidenceVote.get(CONFIDENCE_VOTE.ATTR.ONE_FINGER);\n    const twoFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.TWO_FINGERS);\n    const threeFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.THREE_FINGERS);\n    const fourFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.FOUR_FINGERS);\n    const fiveFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.FIVE_FINGERS);\n    const totalFingers = oneFinger + 2 * twoFingers + 3 * threeFingers + 4 * fourFingers + 5 * fiveFingers;\n    const numberOfConvidenceVotes = oneFinger + twoFingers + threeFingers + fourFingers + fiveFingers;\n\n    return totalFingers / numberOfConvidenceVotes;\n}\n\n/**\n * Calculate the velocity of last PI as number of capabilities that were done in the last PI\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>} currentPi\n */\nfunction calculateVelocityOfLastPi(currentPi) {\n    let lastPI = currentPi.get(PROGRAM_INCREMENT.ATTR.PREDECESSOR);\n    if (!lastPI) {\n        return 0;\n    }\n    const velocity = Array.from(lastPI.getIncomingPages(CAPABILITY.TYPE, CAPABILITY.ATTR.PROGRAM_INCREMENT)).filter(\n        (/** @type {Page<'cf.cplace.solution.safe.capability'>} */ c) =>\n            c.get(CAPABILITY.ATTR.STATE) === CAPABILITY.ENUM.STATE.DONE\n    ).length;\n    return velocity;\n}\n// //--------------------------------------------------------------------------------------//\n// //                                       HELPER FUNCTIONS                               //\n// //--------------------------------------------------------------------------------------//\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    let logOutput = typeof text !== \"string\" ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType cf.cplace.solution.safe.solution\n * @layout default layout\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Displays the timeline with Programm Increments, Safe Events and Safe Milestones. Chart is zoomable and draggable\n */\n\n// set the distinguishing log name\ncplace.setLogName(\"Highcharts - Timeline Overview\");\n\n/***** Start configuration *****/\nconst chartBackgroundColor = \"#FFFFFF\";\nconst lineColor = \"#303038\";\n\nconst piColor = \"#dddddd\";\nconst safeMilestoneColor = \"#3D8F8C\";\nconst eventColor = \"#366C81\";\n\nconst milestonePlotBandColor = \"#E2F3F2\";\nconst eventPlotBandColor = \"#E2EEF3\";\nconst todayPlotline = \"lightgrey\";\n\nconst showMonthsBeforeToday = 3;\nconst showMonthsAfterToday = 9;\n/***** End configuration *****/\n\nconst MILESTONE = {\n    TYPE: \"cf.milestone\",\n    ATTR: {\n        SCHEDULE: \"containingSchedule\",\n        DATE: \"date\",\n        FEATURE_DEPENDENCY: \"cf.cplace.solution.safe.dependency\",\n        TASKCLASS: \"activityClass\",\n    },\n};\nconst FEATURE = {\n    TYPE: \"cf.cplace.solution.safe.feature\",\n    ATTR: {\n        PROGRAM: \"cf.cplace.solution.safe.program\",\n    },\n};\nconst SCHEDULE = {\n    TYPE: \"cf.schedule\",\n    ATTR: {},\n};\nconst TASK_CLASS = {\n    TYPE: \"cf.activityClass\",\n    ATTR: {\n        COLOR: \"barColor\",\n        BORDERCOLOR: \"borderColor\",\n        SHAPE: \"milestoneShape\",\n    },\n};\nconst SAFE_MILESTONE = {\n    TYPE: \"cf.cplace.solution.safe.safeMilestone\",\n    ATTR: {\n        DATE: \"cf.cplace.solution.safe.date\",\n    },\n};\nconst PI = {\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START: \"cf.cplace.solution.safe.startDate\",\n        END: \"cf.cplace.solution.safe.endDate\",\n    },\n};\nconst EVENT = {\n    TYPE: \"cf.cplace.solution.safe.event\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n    },\n};\n\nfunction main() {\n    /** @type {ChartContext} */\n    const context = {\n        today: new Date(),\n        start: getStartDate(showMonthsBeforeToday),\n        end: getEndDate(showMonthsAfterToday),\n        solution: embeddingPage,\n        schedules: [],\n        programIncrements: [],\n        events: [],\n        safeMilestones: [],\n        series: [],\n        plotlines: [],\n        categories: [\"<b>Program Increments</b>\", \"<b>Events</b>\", \"<b>SAFe Milestones</b>\"],\n        yIndex: 0,\n    };\n\n    categorizeData(pages, context);\n    createPiSeries(context);\n    createEventSeries(context);\n    createMilestoneSeries(context);\n    //create plotline between SAFe parts and schedules\n    //ctx.plotLines.push(createPlotline(yIndex - 0.5, 1.25));\n    createScheduleSeries(context);\n\n    return createChartConfig(context);\n}\n\n/**\n * Sort pages by their type and them to the context\n * @param {Page[]} pages\n * @param {ChartContext} ctx\n */\nfunction categorizeData(pages, ctx) {\n    cplace.each(pages, (page) => {\n        let type = page.getBuiltinFeatureValue(\"customType\");\n        if (type === SCHEDULE.TYPE) {\n            ctx.schedules.push(page);\n        } else if (type === PI.TYPE) {\n            ctx.programIncrements.push(page);\n        } else if (type === SAFE_MILESTONE.TYPE) {\n            ctx.safeMilestones.push(page);\n        } else if (type === EVENT.TYPE) {\n            ctx.events.push(page);\n        }\n    });\n}\n\n/**\n * Create pi series\n * @param {ChartContext} ctx\n */\nfunction createPiSeries(ctx) {\n    const piData = [];\n    cplace.each(ctx.programIncrements, (pi) => {\n        piData.push(createDataItem(pi.getName(), pi.get(PI.ATTR.START), pi.get(PI.ATTR.END), ctx.yIndex, piColor));\n    });\n    ctx.yIndex++;\n    ctx.series.push({\n        name: \"Program Increments\",\n        showInLegend: false,\n          tooltip: {\n            headerFormat: \"\",\n            pointFormat: \"<b>{point.name}</b><br/>Start: {point.x: %Y-%m-%d}<br/> End: {point.x2: %Y-%m-%d}\",\n            useHTML: true,\n        },\n        data: piData,\n        dataLabels: {\n            enabled: true,\n            format: \"<b>{point.name}</b>\",\n        },\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    });\n    return piData;\n}\n\n/**\n * Create event series\n * @param {ChartContext} ctx\n */\nfunction createEventSeries(ctx) {\n    let eventData = [];\n    cplace.each(ctx.events, (event) => {\n        eventData.push(\n            createDataItem(\n                event.getName(),\n                event.get(EVENT.ATTR.START_DATE),\n                event.get(EVENT.ATTR.END_DATE),\n                ctx.yIndex,\n                eventColor\n            )\n        );\n    });\n    ctx.yIndex++;\n    ctx.series.push({\n        name: \"Events\",\n        showInLegend: false,\n          tooltip: {\n            headerFormat: \"\",\n            pointFormat: \"<b>{point.name}</b><br/>Start: {point.x: %Y-%m-%d}<br/> End: {point.x2: %Y-%m-%d}\",\n            useHTML: true,\n        },\n        data: eventData,\n        dataLabels: {\n            enabled: true,\n            format: \"<b>{point.name}</b>\",\n        },\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    });\n}\n\n/**\n * Create safe milestone series\n * @param {ChartContext} ctx\n */\nfunction createMilestoneSeries(ctx) {\n    let safeMilestoneData = [];\n    cplace.each(ctx.safeMilestones, (safeMilestone) => {\n        safeMilestoneData.push(\n            createMilestoneDataItem(\n                safeMilestone.getName(),\n                safeMilestone.get(SAFE_MILESTONE.ATTR.DATE),\n                ctx.yIndex,\n                safeMilestoneColor,\n                safeMilestoneColor\n            )\n        );\n    });\n    ctx.yIndex++;\n    ctx.series.push(createMilestoneSerie(\"SAFe Milestones\", safeMilestoneData));\n}\n/**\n * Create Chart configuration\n * @param {ChartContext} ctx\n * @returns\n */\nfunction createChartConfig(ctx) {\n    return {\n        chart: {\n            type: \"xrange\",\n            backgroundColor: chartBackgroundColor,\n            panning: true,\n            panKey: \"shift\",\n            zoomType: \"x\",\n        },\n        title: {\n            text: \"\",\n        },\n        yAxis: {\n            title: {\n                text: \"\",\n            },\n            categories: ctx.categories,\n            reversed: true,\n            type: \"category\",\n            plotBands: [\n                {\n                    color: eventPlotBandColor,\n                    from: 0.5,\n                    to: 1.5,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    zIndex: 0,\n                },\n                {\n                    color: milestonePlotBandColor,\n                    from: 1.5,\n                    to: 2.5,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    zIndex: 0,\n                },\n            ],\n        },\n        xAxis: {\n            type: \"datetime\",\n            min: Date.UTC(ctx.start.getFullYear(), ctx.start.getMonth(), ctx.start.getDate(), 0, 0, 0, 0),\n            max: Date.UTC(ctx.end.getFullYear(), ctx.end.getMonth(), ctx.end.getDate(), 23, 59, 59, 59),\n            plotLines: [\n                {\n                    dashStyle: \"dash\",\n                    color: todayPlotline,\n                    width: 2,\n                    value: Date.UTC(ctx.today.getFullYear(), ctx.today.getMonth(), ctx.today.getDate(), 0, 0, 0, 0),\n                    zIndex: 1,\n                },\n                ...ctx.plotlines,\n            ],\n        },\n        tooltip: {\n            enabled: true,\n        },\n        series: ctx.series,\n    };\n}\n\n/**\n * Create schedule series\n * @param {ChartContext} ctx\n */\nfunction createScheduleSeries(ctx) {\n    cplace.each(ctx.schedules, (schedule) => {\n        let relevantSchedule = false;\n        let scheduleData = [];\n        let milestones = schedule.getIncomingPages(MILESTONE.TYPE, MILESTONE.ATTR.SCHEDULE);\n        cplace.each(milestones, (milestone) => {\n            let featureDependency = milestone.get(MILESTONE.ATTR.FEATURE_DEPENDENCY);\n            let isProgramRelevant = false;\n            cplace.each(featureDependency, (feature) => {\n                let featureProgram = feature.get(FEATURE.ATTR.PROGRAM);\n                if (featureProgram && featureProgram.getId() === ctx.solution.getId()) {\n                    isProgramRelevant = true;\n                }\n            });\n            if (isProgramRelevant) {\n                relevantSchedule = true;\n                scheduleData.push(createScheduleMilestoneDataItem(milestone, ctx.yIndex));\n            }\n        });\n        if (relevantSchedule) {\n            ctx.categories.push(createCategory(schedule));\n            ctx.series.push(createMilestoneSerieSchedule(schedule.getName(), scheduleData));\n            ctx.yIndex++;\n        }\n    });\n}\n\n//FUNCTIONS\nfunction createDataItem(name, start, end, y, color) {\n    let startDate = new Date(start);\n    let endDate = new Date(end);\n    return {\n        name: name,\n        x: Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0, 0, 0),\n        x2: Date.UTC(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23, 59, 59, 99),\n        y: y,\n        color: color,\n    };\n}\n\nfunction getMilestoneShape(milestoneShape) {\n    if (milestoneShape === \"Diamond\") return \"diamond\";\n    if (milestoneShape === \"Arrow Up\") return \"diamond\";\n    if (milestoneShape === \"Arrow Down\") return \"diamond\";\n    if (milestoneShape === \"Triangle Up\") return \"triangle\";\n    if (milestoneShape === \"Triangle Down\") return \"triangle-down\";\n    if (milestoneShape === \"Triangle Left\") return \"triangle\";\n    if (milestoneShape === \"Triangle Right\") return \"triangle\";\n    if (milestoneShape === \"Circle\") return \"circle\";\n    if (milestoneShape === \"Square\") return \"square\";\n    if (milestoneShape === \"Star\") return \"diamond\";\n    if (milestoneShape === \"Ramp Down\") return \"diamond\";\n    if (milestoneShape === \"Ramp Up\") return \"diamond\";\n}\n\nfunction createMilestoneDataItem(name, date, y, color, borderColor) {\n    let milestoneDate = new Date(date);\n    return {\n        name: name,\n        x: Date.UTC(milestoneDate.getFullYear(), milestoneDate.getMonth(), milestoneDate.getDate(), 0, 0, 0, 0),\n        y: y,\n        marker: {\n            fillColor: color,\n            lineColor: borderColor,\n            lineWidth: 1,\n        },\n    };\n}\n\nfunction createScheduleMilestoneDataItem(milestone, y) {\n    let name = milestone.getName();\n    let milestoneDate = new Date(milestone.get(MILESTONE.ATTR.DATE));\n    let color = milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.COLOR);\n    let borderColor = milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.BORDERCOLOR);\n    let milestoneShape = getMilestoneShape(milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.SHAPE));\n    let features = milestone.get(MILESTONE.ATTR.FEATURE_DEPENDENCY);\n    let featureList = \"<b>Requested Features:</b>\";\n    cplace.each(features, (feature) => {\n        featureList = featureList + \"<br>\" + feature.getName();\n    });\n\n    return {\n        name: name,\n        x: Date.UTC(milestoneDate.getFullYear(), milestoneDate.getMonth(), milestoneDate.getDate(), 0, 0, 0, 0),\n        y: y,\n        features: featureList,\n        marker: {\n            fillColor: color,\n            lineColor: borderColor,\n            lineWidth: 1,\n            symbol: milestoneShape,\n        },\n    };\n}\n\nfunction createMilestoneSerie(name, dataSeries) {\n    return {\n        name: name,\n        type: \"scatter\",\n        //stickyTracking: false,\n        showInLegend: false,\n        marker: {\n            enabled: true,\n            symbol: \"diamond\",\n            lineWidth: 5,\n            radius: 12,\n        },\n        tooltip: {\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"{point.x: %Y-%m-%d}\",\n        },\n        data: dataSeries,\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    };\n}\n\nfunction createMilestoneSerieSchedule(name, dataSeries) {\n    return {\n        name: name,\n        type: \"scatter\",\n        //stickyTracking: false,\n        showInLegend: false,\n        marker: {\n            enabled: true,\n            symbol: \"diamond\",\n            lineWidth: 5,\n            radius: 12,\n        },\n        tooltip: {\n            useHTML: true,\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"{point.x: %Y-%m-%d}<br>{point.features}\",\n        },\n        data: dataSeries,\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    };\n}\n\nfunction createPlotline(value, width) {\n    return {\n        color: lineColor,\n        width: width,\n        value: value,\n        dashStyle: \"solid\",\n    };\n}\n\nfunction getStartDate(months) {\n    let today = new Date();\n    let startDate = today;\n    startDate.setMonth(today.getMonth() - months);\n    return startDate;\n}\n\nfunction getEndDate(months) {\n    let today = new Date();\n    let endDate = today;\n    endDate.setMonth(today.getMonth() + months);\n    return endDate;\n}\n\nfunction createCategory(object) {\n    let name = object.getName();\n    let url = object.getUrl();\n    return '<a href=\"' + url + '\">' + name + \"</a>\";\n}\n\n/**\n * Object containing context information for the chart.\n * @typedef {Object} ChartContext\n * @property {Date} today - The current date.\n * @property {Date} start - The start date for the chart.\n * @property {Date} end - The end date for the chart.\n * @property {Page} solution - The embeddingPage object representing the current solution.\n * @property {Page[]} schedules - An array of pages representing schedules.\n * @property {Page[]} programIncrements - An array of pages representing program increments.\n * @property {Page[]} events - An array of pages representing events.\n * @property {Page[]} safeMilestones - An array of pages representing SAFe milestones.\n * @property {any[]} series - An array of series\n * @property {any[]} plotlines - An array of plotlines\n * @property {string[]} categories - An array of categories\n * @property {number} yIndex - y-index\n */\n\n// @ts-ignore\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('Current PI');\n//Configurations\nconst PI_DASHBOARD = {\n    TYPE:'cf.cplace.solution.safe.currentPiDashboard',\n    ATTR:{\n      PARENT:'cf.cplace.solution.safe.parent'\n    }\n  }\n  \n  let finallink='';\n  let link, name;\n  let piDashboardSearch = new Search()\n    .add(Filters.space(embeddingPage.getSpaceId()))\n    .add(Filters.type(PI_DASHBOARD.TYPE))\n    .add(Filters.customAttributeNonempty(PI_DASHBOARD.ATTR.PARENT))\n    .findAllPages();\n\nlet result = Iterables.getFirst(piDashboardSearch, null);\n\nif (result) {\n    link = result.getUrl();\n    name = result.getName();\n}\n  \nreturn '<a href=\"'+link+'\"class=\"current-color\">Open Current PI Dashboard</a>';",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Solution -> Solution Train Engineer [0..1]\n * Solution -> Solution Train Architect [0..1]\n * Solution -> Solution Management [0..1]\n * \n */\n\nconst SOLUTION = {\n    TYPE: 'cf.cplace.solution.safe.solution',\n    ATTR: {\n        ST_ENGINEER: 'cf.cplace.solution.safe.solutionTrainEngineer',\n        ST_ARCHITECT: 'cf.cplace.solution.safe.solutionTrainArchitect',\n        SOL_MANAGEMENT: 'cf.cplace.solution.safe.solutionManagement'\n    }\n}\n\nconst THUMBNAIL_SIZE = '60px';\n\n\n//find all relevant roles / responsibles\n\nlet solution = embeddingPage;\n\nlet users = [];\n\nlet ste = solution.get(SOLUTION.ATTR.ST_ENGINEER);\nlet sta = solution.get(SOLUTION.ATTR.ST_ARCHITECT);\nlet solMan = solution.get(SOLUTION.ATTR.SOL_MANAGEMENT);\n\n\nif (ste) {\n    addUser(ste, \"Solution Train Engineer\")\n}\nif (sta) {\n    addUser(sta, \"Solution Train Architect\")\n}\nif (solMan) {\n    addUser(solMan, \"Solution Management\")\n}\n\n//users.sort((user1, user2) => user1.name > user2.name ? 1 : -1);\n\n\nlet output = '';\n\n\nfor (let i = 0; i < users.length; i++) {\n  output += generateUserMarkupNew(users[i]);\n}\n\nreturn '<div style=\"display:flex;flex-flow:row wrap;\">' + output + '</div>';\n\n\nfunction addUser(member, title) {\n    users.push({\n        name: member.getName(),\n        id: member.getId().split('/').pop(),\n        url: member.getUrl(),\n        title: title\n    })\n}\n\nfunction getTenantName(page){\n let url=embeddingPage.getUrl().split('/pages/')[0];\n let tenantName= url.split('/')[3];\n  return tenantName;\n}\n\nfunction generateUserMarkup (user) {\n    return '<div style=\"margin:8px;text-align: center;\">'\n        + '<img class=\"cplace-person__image\" style=\"margin: 5px\" src=\"/person/downloadThumbnail?id=' + user.id + '\" width=\"' + THUMBNAIL_SIZE + '\" height=\"' + THUMBNAIL_SIZE + '\" title=\"' + user.name + '\"/>'\n        + '<div style=\"font-size: 9pt;margin:3px;\">' + user.name + '</div>'\n        + '<div style=\"font-size: 8pt;margin:3px;\">' + user.title + '</div>'\n      + '</div>';\n  }\n\n//<img class=\"custom-profile-image\" src='+ tenantUrl +'person/downloadThumbnail?id=' + userHref + '>'\n\nfunction generateUserMarkupNew (user) {\n    return '<div style=\"margin:8px;text-align: center;\">'\n        + '<img class=\"cplace-person__image\" style=\"margin: 5px;height:60px;width:60px\" src=\"/'+getTenantName(embeddingPage)+'/person/downloadThumbnail?id=' + user.id + '\" width=\"' + THUMBNAIL_SIZE + '\" height=\"' + THUMBNAIL_SIZE + '\" title=\"' + user.name + '\"/>'\n        + '<div style=\"font-size: 10pt;margin:3px;\">' + user.name + '</div>'\n        + '<div style=\"font-size: 9pt;margin:3px;\">' + user.title + '</div>'\n      + '</div>';\n  }",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Displays all work items of the backlog as Pie grouped by the classification of their type\n *\n * @author Daniel Fader\n * @version 12.07.2023\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName('highchart_capacity-allocation');\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\nconst COLORS = {\n    TYPE_CLASSIFICATION: {\n        CAPABILITIY: '#61a89d',\n        ENABLER: '#ffb600'\n    }\n};\n\nconst NAMES = {\n    TYPE_CLASSIFICATION: {\n        CAPABILITY: 'Capability',\n        ENABLER: 'Enabler'\n    }\n};\n\nconst CAPABILITIY = /** @type {const} */ ({\n    TYPE: 'cf.cplace.solution.safe.capability',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        TYPE: 'cf.cplace.solution.safe.capabilityType', // TYPE_WORK_ITEM_TYPE\n        STATE: 'cf.cplace.solution.safe.state' // ENUM\n    },\n    ENUMS: {\n        STATUS: {\n            DRAFT: \"#10 - Draft\",\n            FUNNEL: \"#15 - Funnel\",\n            DEFINING: \"#25 - Analyzing\",\n            REDAY: \"#35 - Backlog\",\n            IMPLEMENTING: \"#45 - Implementing\",\n            READYFORTESTING: \"#55 - Validating\",\n            INTEGRATING: \"#65 - Deploying\",\n            READY: \"#75 - Releasing\",\n            DONE: \"#85 - Done\",\n            OBSOLETE: \"#95 - Obsolete\",\n        },\n        TYPE: {\n            ENABLER: 'enabler',\n            CAPABILITY: 'capability',\n        }\n    }\n});\n\n\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\nconst items = Array.from(pages);\n\n//--------------------------------------------------------------------------------------//\n//                                       PROCESSING STAGE                               //\n//--------------------------------------------------------------------------------------//\nconst series = createPieSeries(items);\n\nconst chart = {\n    chart: {\n        type: 'pie'\n    },\n    title: {\n        text: null,\n    },\n    legend: {\n        enabled: false,\n    },\n    tooltip: {\n        useHTML: true,\n        followPointer: false,\n    },\n    plotOptions: {\n        series: {\n            borderColor: '#ffffff',\n            borderWidth: 2,\n            stickyTracking: false,\n            tooltip: {\n                headerFormat: '',\n                pointFormat: '<b>{point.name}</b><br>{point.y} ({point.custom.percent:.0f} %)',\n                findNearestPointBy: 'xy'\n            }\n        }\n    },\n    series: [series]\n};\n\n// noinspection JSAnnotator\nreturn chart;\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n/**\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} items\n * @return {Object}\n */\nfunction createPieSeries(items) {\n    const classifications = Object.keys(CAPABILITIY.ENUMS.TYPE);\n    const data = classifications.map(classification => {\n        const itemsWithClassification = items.filter(item => {\n            const itemType = item.get(CAPABILITIY.ATTR.TYPE);\n            return itemType && itemType === CAPABILITIY.ENUMS.TYPE[classification];\n        });\n        const percent = Math.min(100, (itemsWithClassification.length === 0 || items.length === 0) ? 0 : (itemsWithClassification.length / items.length * 100));\n        return {\n            name: NAMES.TYPE_CLASSIFICATION[classification],\n            color: COLORS.TYPE_CLASSIFICATION[classification],\n            y: itemsWithClassification.length,\n            custom: {\n                percent: percent\n            }\n        };\n    });\n    return {\n        name: 'Work items by classification',\n        data: data\n    };\n}\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    const logOutput = typeof text !== 'string' ? JSON.stringify(text) : text;\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType cf.cplace.solution.safe.currentIterationDashboard\n * @layout cf.cplace.solution.safe.iterationStatistics\n * @author Bastian Rang\n * @version 1.0\n * @description\n */\n\nconst DEBUG = false;\n\nconst PROGRAM_INCREMENT = {\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        STATISTICS: \"cf.cplace.solution.safe.statsJson\",\n    },\n};\n\nconst CAPABILITY = {\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATUS: \"\",\n    },\n    STATUS: {\n        DRAFT: \"#10 - Draft\",\n        FUNNEL: \"#15 - Funnel\",\n        DEFINING: \"#25 - Analyzing\",\n        REDAY: \"#35 - Backlog\",\n        IMPLEMENTING: \"#45 - Implementing\",\n        READYFORTESTING: \"#55 - Validating\",\n        INTEGRATING: \"#65 - Deploying\",\n        READY: \"#75 - Releasing\",\n        DONE: \"#85 - Done\",\n        OBSOLETE: \"#95 - Obsolete\",\n    },\n    STATUS_MAP: {\n        \"#10 - Draft\": \"Draft\",\n        \"#15 - Funnel\": \"Funnel\",\n        \"#25 - Analyzing\": \"Analyzing\",\n        \"#35 - Backlog\": \"Backlog\",\n        \"#45 - Implementing\": \"Implementing\",\n        \"#55 - Validating\": \"Validating\",\n        \"#65 - Deploying\": \"Deploying\",\n        \"#75 - Releasing\": \"Releasing\",\n        \"#85 - Done\": \"Done\",\n        \"#95 - Obsolete\": \"Obsolete\",\n    },\n    CLASSIFICATION: {\n        ENABLER: \"#15 - enabler\",\n        STORY: \"#25 - story\",\n        MAINTENANCE: \"#35 - maintenance\",\n    },\n};\n\nconst pi = Array.from(pages)[0];\n\nif (pi?.getBuiltinFeatureValue(\"customType\") !== PROGRAM_INCREMENT.TYPE) {\n    throw new Error(\"Please provide a single program increment in the chart search.\");\n}\n\nconst startDate = pi.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay();\nconst endDate = pi.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay();\n\nlet statistics = null;\ntry {\n    statistics = JSON.parse(pi.get(PROGRAM_INCREMENT.ATTR.STATISTICS));\n    DEBUG && cplace.log(statistics);\n} catch (e) {\n    // @ts-ignore\n    return {\n        title: {\n            text: null,\n        },\n    };\n}\n\nif (!statistics || !statistics.archive || !statistics.current) {\n    // @ts-ignore\n    return {\n        title: {\n            text: null,\n        },\n    };\n}\n\nconst today = DateTime.parse(statistics.current.date).withTimeAtStartOfDay();\n\n// Define the data for Release Burndown\n/**\n * @type {Array}\n */\nlet data = statistics.archive.map((element) => {\n    const currentDate = DateTime.parse(element.date);\n\n    const currentData = {\n        day: currentDayNumber(startDate, currentDate),\n    };\n\n    DEBUG && cplace.log(element.cumulativeFlow);\n    Object.values(CAPABILITY.STATUS).forEach((statusName) => (currentData[statusName] = element.cumulativeFlow[statusName] || 0));\n\n    return currentData;\n});\n\nDEBUG && cplace.log(data);\n\ndata = sortByKey(data, \"day\");\n\nconst series = [];\n\nObject.values(CAPABILITY.STATUS).forEach((statusName) => {\n    series.push({\n        name: CAPABILITY.STATUS_MAP[statusName],\n        data: data.map((e) => e[statusName]),\n    });\n});\n\n// Create the chart\n// @ts-ignore\nreturn {\n    chart: {\n        type: \"area\",\n    },\n    title: {\n        text: \"Cumulative Flow Diagram\",\n    },\n    xAxis: {\n        categories: data.map((data) => data.day),\n    },\n    yAxis: {\n        title: {\n            text: \"Number of Capabilities\",\n        },\n    },\n    plotOptions: {\n        area: {\n            stacking: \"normal\",\n        },\n    },\n    series: series,\n};\n\nfunction sortByKey(array, key) {\n    return array.sort(function (a, b) {\n        var x = a[key];\n        var y = b[key];\n        return x < y ? -1 : x > y ? 1 : 0;\n    });\n}\n\nfunction currentDayNumber(startDate, currentDate) {\n    return Days.daysBetween(startDate.withTimeAtStartOfDay(), currentDate.withTimeAtStartOfDay()).getDays();\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n *\n */\n\nconst DEBUG = false;\n\nconst PROGRAM_INCREMENT = {\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        STATISTICS: \"cf.cplace.solution.safe.statsJson\",\n    },\n};\n\nconst pi = Array.from(pages)[0];\n\nif (pi?.getBuiltinFeatureValue(\"customType\") !== PROGRAM_INCREMENT.TYPE) {\n    throw new Error(\"Please provide a single team iteration in the chart search.\");\n}\n\nconst startDate = pi.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay();\nconst endDate = pi.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay();\n/** @type {Statistics} */\nlet statistics = null;\ntry {\n    statistics = JSON.parse(pi.get(PROGRAM_INCREMENT.ATTR.STATISTICS));\n    DEBUG && cplace.log(statistics);\n} catch (e) {\n    return {\n        title: {\n            text: null,\n        },\n    };\n}\n\nif (!statistics || !statistics.archive || !statistics.current) {\n    return {\n        title: {\n            text: null,\n        },\n    };\n}\n\nconst today = DateTime.parse(statistics.current.date).withTimeAtStartOfDay();\n\n// Sort statistics by Date\nconst sortedStatistics = statistics.archive.sort((a, b) => Days.daysBetween(new DateTime(Date.parse(b.date)), new DateTime(Date.parse(a.date))).getDays());\n\n// Define the data for Release Burndown\nlet data = sortedStatistics\n    .map((element) => {\n        const currentDate = DateTime.parse(element.date);\n        return {\n            day: currentDayNumber(startDate, currentDate),\n            planned: linearPercentageDegression(element.burndown.planned, currentDate, startDate, endDate),\n            actual: element.burndown.planned - element.burndown.done,\n            forecast: null,\n        };\n    })\n    .sort((a, b) => a.day - b.day);\n\nconst lastDataPoint = sortedStatistics[sortedStatistics.length - 1];\n\nlet currentDate = new DateTime(Date.parse(lastDataPoint.date));\n\nwhile (!currentDate.isAfter(endDate.plusSeconds(5))) {\n    const currentDateKey = currentDayNumber(startDate, currentDate);\n\n    // DEBUG && cplace.log(currentDateKey)\n\n    if (!data.some((el) => currentDateKey === el.day)) {\n        data.push({\n            day: currentDateKey,\n            planned: linearPercentageDegression(statistics.current.burndown.planned, currentDate, startDate, endDate),\n            actual: null,\n            forecast: linearPercentageDegressionForecast(statistics.current.burndown.planned, statistics.current.burndown.done, currentDate, today, endDate),\n        });\n    }\n\n    currentDate = currentDate.plusDays(1);\n}\n\ndata = sortByKey(data, \"day\");\n\n// Create the chart\nreturn {\n    chart: {\n        type: \"line\",\n    },\n    title: {\n        text: \"Program Increment Burn-Down Chart\",\n    },\n    xAxis: {\n        title: {\n            text: \"Day\",\n        },\n        categories: data.map((data) => data.day),\n    },\n    yAxis: {\n        title: {\n            text: \"Story Points\",\n        },\n    },\n    plotLines: [\n        {\n            color: \"#33ff33\",\n            width: 1,\n            zIndex: 9999,\n            value: 12,\n        },\n    ],\n    series: [\n        {\n            name: \"Ideal Burndown\",\n            data: data.map((data) => data.planned),\n            color: \"lightblue\",\n        },\n        {\n            name: \"Forecast\",\n            data: data.map((data) => data.forecast || data.actual),\n            color: {\n                pattern: {\n                    color: \"#ccccff\",\n                    opacity: 0.5,\n                },\n            },\n        },\n        {\n            name: \"Remaining Storypoints\",\n            data: data.map((data) => data.actual),\n            color: \"#6666ff\",\n        },\n    ],\n};\n\nfunction linearPercentageDegression(planned, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    return planned * (daysLeft / daysFullIteration);\n}\n\nfunction linearPercentageDegressionForecast(planned, done, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    if (daysFullIteration === 0) {\n        return done;\n    }\n\n    return (planned - done) * (daysLeft / daysFullIteration);\n}\n\nfunction sortByKey(array, key) {\n    return array.sort(function (a, b) {\n        var x = a[key];\n        var y = b[key];\n        return x < y ? -1 : x > y ? 1 : 0;\n    });\n}\n\nfunction currentDayNumber(startDate, currentDate) {\n    return Days.daysBetween(startDate.withTimeAtStartOfDay(), currentDate.withTimeAtStartOfDay()).getDays();\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n *\n */\n\nconst DEBUG = false;\n\nconst PROGRAM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        STATISTICS: \"cf.cplace.solution.safe.statsJson\",\n    },\n});\n\nfunction main() {\n    const teamIteration = Array.from(pages)[0];\n\n    if (teamIteration?.getBuiltinFeatureValue(\"customType\") !== PROGRAM_INCREMENT.TYPE) {\n        throw new Error(\"Please provide a single team iteration in the chart search.\");\n    }\n\n    let statistics = null;\n    try {\n        statistics = JSON.parse(teamIteration.get(PROGRAM_INCREMENT.ATTR.STATISTICS));\n        DEBUG && cplace.log(statistics);\n    } catch (e) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n\n    if (!statistics || !statistics.archive || !statistics.current) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n    const data = createData(teamIteration, statistics);\n\n    // Create the chart\n    return {\n        chart: {\n            type: \"line\",\n        },\n        title: {\n            text: \"Team Iteration Burn-Up Chart\",\n        },\n        xAxis: {\n            title: {\n                text: \"Day\",\n            },\n            categories: data.map((data) => data.day),\n        },\n        yAxis: {\n            title: {\n                text: \"Story Points\",\n            },\n        },\n        plotLines: [\n            {\n                color: \"#33ff33\",\n                width: 1,\n                zIndex: 9999,\n                value: 12,\n            },\n        ],\n        series: [\n            {\n                name: \"Ideal Burn-Up\",\n                data: data.map((data) => data.planned),\n                color: \"lightblue\",\n            },\n            {\n                name: \"Forecast\",\n                data: data.map((data) => data.forecast || data.actual),\n                color: {\n                    pattern: {\n                        color: \"#ccccff\",\n                        opacity: 0.5,\n                    },\n                },\n            },\n            {\n                name: \"Done Storypoints\",\n                data: data.map((data) => data.actual),\n                color: \"#6666ff\",\n            },\n        ],\n    };\n}\n/**\n * Create the data for the chart\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>} pi\n * @param {Statistics} statistics\n * @returns\n */\nfunction createData(pi, statistics) {\n    const today = DateTime.parse(statistics.current.date).withTimeAtStartOfDay();\n\n    const startDate = pi.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay();\n    const endDate = pi.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay();\n\n    // Define the data for Release Burn-Up\n\n    const sortedStatistics = statistics.archive.sort((a, b) => Days.daysBetween(new DateTime(Date.parse(b.date)), new DateTime(Date.parse(a.date))).getDays());\n\n    let data = sortedStatistics.map((element) => {\n        const currentDate = DateTime.parse(element.date);\n        return {\n            day: currentDayNumber(startDate, currentDate),\n            planned: linearPercentageDegression(element.burndown.planned, currentDate, startDate, endDate),\n            actual: element.burndown.done,\n            forecast: null,\n        };\n    });\n\n    const lastDataPoint = sortedStatistics[sortedStatistics.length - 1];\n\n    let currentDate = new DateTime(Date.parse(lastDataPoint.date));\n\n    while (!currentDate.isAfter(endDate.plusSeconds(5))) {\n        const currentDateKey = currentDayNumber(startDate, currentDate);\n\n        DEBUG && cplace.log(currentDateKey);\n\n        if (!data.some((el) => currentDateKey === el.day)) {\n            const entry = {\n                day: currentDateKey,\n                planned: linearPercentageDegression(statistics.current.burndown.planned, currentDate, startDate, endDate),\n                actual: null,\n                forecast:\n                    linearPercentageDegressionForecast(statistics.current.burndown.planned, statistics.current.burndown.done, currentDate, today, endDate) +\n                    statistics.current.burndown.done,\n            };\n            data.push(entry);\n        }\n\n        currentDate = currentDate.plusDays(1);\n    }\n\n    DEBUG && cplace.log(data);\n\n    data = sortByKey(data, \"day\");\n\n    return data;\n}\n\n/**\n * Calculates linear percentage degression based on the given parameters.\n * The function calculates the percentage degression from the initial value (`planned`) to 0\n * over a specific period between `startDate` and `endDate`, based on the `currentDate`.\n *\n * @param {number} planned - The initial value or planned value at the `startDate`.\n * @param {DateTime} currentDate - The current date for which the degression needs to be calculated.\n * @param {DateTime} startDate - The start date of the degression period.\n * @param {DateTime} endDate - The end date of the degression period.\n * @returns {number} The calculated value after linear percentage degression.\n *\n */\nfunction linearPercentageDegression(planned, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    return planned * (1 - daysLeft / daysFullIteration);\n}\n/**\n * Calculates linear percentage degression based on the given parameters.\n * The function calculates the percentage degression from the initial value (`planned`) to 0\n * over a specific period between `startDate` and `endDate`, based on the `currentDate`.\n *\n * @param {number} planned - The initial value or planned value at the `startDate`.\n * @param {number} done - The done value at the `startDate`.\n * @param {DateTime} currentDate - The current date for which the degression needs to be calculated.\n * @param {DateTime} startDate - The start date of the degression period.\n * @param {DateTime} endDate - The end date of the degression period.\n * @returns {number} The calculated value after linear percentage degression.\n *\n */\nfunction linearPercentageDegressionForecast(planned, done, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    if (daysFullIteration === 0) {\n        return done;\n    }\n\n    return (planned - done) * (1 - daysLeft / daysFullIteration);\n}\n\n/**\n * Sorts an array of objects based on the values of a specified key in each object.\n * The function sorts the array in ascending order based on the values of the specified `key`.\n *\n * @template T\n * @param {T[]} array - The array of objects to be sorted.\n * @param {keyof T} key - The key based on which the objects should be sorted.\n * @returns {T[]} The sorted array of objects.\n */\nfunction sortByKey(array, key) {\n    return array.sort(function (a, b) {\n        var x = a[key];\n        var y = b[key];\n        return x < y ? -1 : x > y ? 1 : 0;\n    });\n}\n\n/**\n * Calulcates the amount of days after the start date for the currentDate provided\n * @param {DateTime} startDate\n * @param {DateTime} currentDate\n * @returns\n */\nfunction currentDayNumber(startDate, currentDate) {\n    return Days.daysBetween(startDate.withTimeAtStartOfDay(), currentDate.withTimeAtStartOfDay()).getDays();\n}\n\n// @ts-ignore\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('Current PI');\n//Configurations\nconst PI_DASHBOARD = {\n    TYPE:'cf.cplace.solution.safe.currentPiDashboard',\n    ATTR:{\n      PARENT:'cf.cplace.solution.safe.parent'\n    }\n  }\n  \n  let finallink='';\n  let link, name;\n  let piDashboardSearch = new Search()\n    .add(Filters.space(embeddingPage.getSpaceId()))\n    .add(Filters.type(PI_DASHBOARD.TYPE))\n    .add(Filters.customAttributeNonempty(PI_DASHBOARD.ATTR.PARENT))\n    .findAllPages();\n\nlet result = Iterables.getFirst(piDashboardSearch, null);\n\nif (result) {\n    link = result.getUrl();\n    name = result.getName();\n}\n  \nreturn '<a href=\"'+link+'\"class=\"current-color\">Open Current PI Dashboard</a>';",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Identifier: highchart-programIncrement-progress\n * Type of chart: multi pie chart\n * Type of search pages: cf.cplace.solution.safe.team, cf.cplace.solution.safe.story\n * Functionality: visualizes different kinds of kpis\n * \n * INSTRUCTIONS TO ADD CHARTS\n * 1. Increase TOTAL_NUMBER_OF_KPIS +1\n * 2. Define Following Values\n *      - CX_TITLE \n *      - CX_ACTUAL\n *      - CX_ACTUAL_PERCENTAGE\n *      - CX_DISPLAY_NUMBER \n *      - CX_DISPLAY_TEXT \n *      - CX_COLOR \n * 3. Create chart\n *      - createChart(CX_TITLE, CX_ACTUAL_PERCENTAGE, CX_DISPLAY_NUMBER, CX_DISPLAY_TEXT, CX_COLOR) {\n * \n * \n * @author Lukas Scheiring (cF)\n * Last edited: 18.08.2022\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName('highchart-programIncrement-progress');\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\n//CHART COLOURS\nconst COLOURS = {\n    TEXT_COLOR : '#003653',\n    BACKGROUND_COLOR : '#ffffff',\n    GREY : 'gray',\n    RED: '#f30000',\n    DARK_RED : '#9e0000',\n    YELLOW: '#ffc700',\n    GREEN: '#5ab500',\n    BLUE : '#A6CAD8'\n}\n\n//CHART SETTINGS\nconst TOTAL_NUMBER_OF_KPIS = 4\nconst Y_POSITION = '40%'\n\n//LANGUAGE SETTINGS\nconst NAMINGS = {\n    de: {\n        CHART_TITLE: '',\n    },\n    en: {\n        CHART_TITLE: '',\n    }\n};\n\n//PLACEHOLDER\nconst PROGRAM_INCREMENT = {\n    TYPE : 'cf.cplace.solution.safe.programIncrement',\n    ATTR : {\n        TITLE : 'cf.cplace.solution.safe.title',\n        PROGRAM : 'cf.cplace.solution.safe.program',\n        START_DATE : 'cf.cplace.solution.safe.startDate',\n        END_DATE : 'cf.cplace.solution.safe.endDate',\n        PREDECESSOR : 'cf.cplace.solution.safe.predecessor',\n        PERIOD_STATUS : 'cf.cplace.solution.safe.periodStatus',\n        CAPACITY : 'cf.cplace.solution.safe.capacity'\n    }\n}\n\nconst TEAM = {\n    TYPE : 'cf.cplace.solution.safe.team',\n    ATTR : {\n        VELOCITY : 'cf.cplace.solution.safe.velocity',\n        CAPACITY : 'cf.cplace.solution.safe.capacity',\n    }\n}\n\nconst STORY = {\n    TYPE : 'cf.cplace.solution.safe.story',\n    ATTR : {\n        ITERATION : 'cf.cplace.solution.safe.iteration',\n        STATUS : 'cf.cplace.solution.safe.status',\n        STORY_POINTS : 'cf.cplace.solution.safe.storyPoints'\n    },\n    ENUM_STATUS : {\n        ANALYSIS : '#10 - analysis',\n        BACKLOG : '#20 - backlog',\n        IN_PROGRESS : '#40 - in progress',\n        DONE : '#50 - done',\n        OBSOLETE : '#60 - obsolete'\n    }\n}\n\nconst ITERATION = {\n    TYPE : 'cf.cplace.solution.safe.iteration',\n    ATTR: {\n        ITERATION : 'cf.cplace.solution.safe.iteration',\n        PI: 'cf.cplace.solution.safe.programIncrement',\n    }\n}\n\n\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\nlog('Start...')\nlet currentUser = cplace.utils().getCurrentUser()\nconst userLanguage = currentUser.getUserLanguage()\nlet programIncrement = embeddingPage;\nlet chartIndex = 0\n\n//Container\nlet teams = []\nlet stories = []\n\nlet series = []\nlet yAxis = []\nlet pane = []\n\n//Dates\nlet piStartDate = programIncrement.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay()\nlet piEndDate = programIncrement.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay()\nlet today = new DateTime().withTimeAtStartOfDay()\n\n//KPIs\nlet totalDaysOfPI = Days.daysBetween(piStartDate,piEndDate).getDays();\nlet passedDaysOfPI = getPassedDays (piStartDate, piEndDate, today, totalDaysOfPI)\n\n\n\n//let totalCapacity = 0;\nlet velocityOfLastPI = 0\nlet totalLoad = 0\nlet spDone = 0\n\n\n//--------------------------------------------------------------------------------------//\n//                                       PROCESSING STAGE                               //\n//--------------------------------------------------------------------------------------//\n\n//Group pages\ncplace.each(pages, page => {\n    switch (page.getBuiltinFeatureValue('customType')) {\n        case TEAM.TYPE:\n            teams.push(page)\n            break;\n        case STORY.TYPE:\n            stories.push(page)\n            break;\n        default:\n            break;\n    }\n})\n\n//calculate velocity\nlet lastPI = programIncrement.get(PROGRAM_INCREMENT.ATTR.PREDECESSOR)\nif (lastPI) {\n    log('Last PI: ' + lastPI.getName())\n    let iterations = lastPI.getIncomingPages(ITERATION.TYPE, ITERATION.ATTR.PI)\n    cplace.each(iterations, iteration => {\n        log('Check iteration: ' + iteration.getName())\n        let storiesOfIteration = iteration.getIncomingPagesFromAllSpaces(STORY.TYPE, STORY.ATTR.ITERATION)\n        cplace.each(storiesOfIteration, storyOfIteration => {\n            log('Check story: ' + storyOfIteration.getName())\n            if (storyOfIteration.get(STORY.ATTR.STATUS) === STORY.ENUM_STATUS.DONE) {\n                velocityOfLastPI += (storyOfIteration.get(STORY.ATTR.STORY_POINTS) || 0)\n            }\n        })\n    })\n}\n\n\n\n\n//Load + SP done\ncplace.each(stories, story => {\n    let storyPoints = story.get(STORY.ATTR.STORY_POINTS) || 0\n    totalLoad += storyPoints\n\n    if (story.get(STORY.ATTR.STATUS) === STORY.ENUM_STATUS.DONE) {\n        spDone += storyPoints\n    }\n\n})\n\n\n\n//--------------------------------------------------------------------------------------//\n//                                       KPIs & CHART                                   //\n//--------------------------------------------------------------------------------------//\n\n//Chart 1 - passed days\nconst C1_TITLE = 'Days passed'\nconst C1_ACTUAL = passedDaysOfPI\nconst C1_ACTUAL_PERCENTAGE = Math.round((passedDaysOfPI / totalDaysOfPI) * 100)  ? Math.round((passedDaysOfPI / totalDaysOfPI) * 100) : 0;\nconst C1_DISPLAY_NUMBER = C1_ACTUAL_PERCENTAGE + '%'\nconst C1_DISPLAY_TEXT = '<b>DAYS PASSED</b><br>' + passedDaysOfPI + '/' + totalDaysOfPI\nconst C1_COLOR = COLOURS.GREEN\n\ncreateChart(C1_TITLE, C1_ACTUAL_PERCENTAGE, C1_DISPLAY_NUMBER, C1_DISPLAY_TEXT, C1_COLOR)\n\n\n//KPI 2 - Load vs Capacity\n//Capacity + Velocity\nlet totalCapacity = programIncrement.get(PROGRAM_INCREMENT.ATTR.CAPACITY);\nif(totalCapacity){\nconst C2_TITLE = 'Load vs. Capacity'\nconst C2_ACTUAL = totalLoad\nconst C2_ACTUAL_PERCENTAGE= Math.round((totalLoad / totalCapacity) * 100) || 0\nconst C2_DISPLAY_NUMBER = C2_ACTUAL_PERCENTAGE + '%'\nconst C2_DISPLAY_TEXT = '<b>LOAD VS. CAPACITY</b><br>' + totalLoad + '/' + totalCapacity\n\nlet c2_color = COLOURS.GREEN\nif (Math.round((totalLoad / totalCapacity) * 100) >= 90) {\n    c2_color = COLOURS.YELLOW\n    if (Math.round((totalLoad / totalCapacity) * 100) > 100) {\n        c2_color = COLOURS.RED\n    }    \n}    \n\ncreateChart(C2_TITLE, C2_ACTUAL_PERCENTAGE, C2_DISPLAY_NUMBER, C2_DISPLAY_TEXT, c2_color)\n}\n\n//KPI 3 - Story Points done\nconst C3_TITLE = 'Done SP'\nconst C3_ACTUAL = spDone\nconst C3_ACTUAL_PERCENTAGE = Math.round((spDone / totalLoad) * 100) || 0\nconst C3_DISPLAY_NUMBER = C3_ACTUAL_PERCENTAGE + '%'\nconst C3_DISPLAY_TEXT = '<b>DONE SP</b><br>' + spDone + '/' + totalLoad\nconst C3_COLOR = COLOURS.GREEN\n\ncreateChart(C3_TITLE, C3_ACTUAL_PERCENTAGE, C3_DISPLAY_NUMBER, C3_DISPLAY_TEXT, C3_COLOR)\n\n\n//KPI 4 - Velocity\nconst C4_TITLE = 'Velocity of Last PI'\nconst C4_ACTUAL = 100\nconst C4_ACTUAL_PERCENTAGE = 100\nconst C4_DISPLAY_NUMBER = Math.round(velocityOfLastPI)\nconst C4_DISPLAY_TEXT = '<b>VELOCITY OF LAST PI</b><br>over all Teams'\nconst C4_COLOR = COLOURS.BLUE\n\ncreateChart(C4_TITLE, C4_ACTUAL_PERCENTAGE, C4_DISPLAY_NUMBER, C4_DISPLAY_TEXT, C4_COLOR)\n\n\n\n\nlog('End...')\nreturn {\n    chart: {\n        type: 'solidgauge',\n    },\n    \n    title: {\n        text: NAMINGS[userLanguage].CHART_TITLE\n    },\n    series: series,\n    yAxis: yAxis,\n    pane: pane,\n    tooltip : {\n        enabled: false\n    },\n    plotOptions: {\n        solidgauge : {\n            enableMouseTracking: false,\n        }\n    },\n}\n\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n\nfunction createChart(title, actualRel, displayNumber, displayText, color) {\n    series.push(getSeriesObject(title, actualRel, displayNumber, chartIndex, color))\n    yAxis.push(getYAxisObject(displayText, chartIndex, 0, 100))\n    pane.push(getPaneObject(getXAxisPosition(chartIndex), Y_POSITION))\n    chartIndex++;\n}\n\nfunction getXAxisPosition (kpiIndex) {\n    return 120 * (kpiIndex + 1) / (TOTAL_NUMBER_OF_KPIS + 1) -10 + '%'\n}\n\nfunction getPassedDays (piStartDate, piEndDate, today, totalDaysOfPI) {\n    if (today.isBefore(piStartDate)) {\n        return 0\n    }\n    if (piEndDate.isBefore(today)) {\n        return totalDaysOfPI\n    }\n    return Days.daysBetween(piStartDate,today).getDays()\n}\n\nfunction getSeriesObject (title, actual, label, index, color) {\n    return {\n        name : title,\n        data : [{\n            name : title,\n            color : color,\n            y : actual,\n            innerRadius: '80%',\n            radius: '100%',\n            dataLabels : {\n                format :  '<h1 style=\"font-size:13\">' + label+ '</h1>',\n                borderWidth: 0,\n                color: COLOURS.GREY,\n                verticalAlign: 'middle',\n                useHTML: true\n            },\n        }],\n        yAxis: index,\n    }\n}\n\n\nfunction getYAxisObject (axisTitle, index, min, max) {\n    return {\n        min: min,\n        max: max,\n        pane : index,\n        title: {\n            text: axisTitle,\n            useHTML: true,\n            y: 110,\n        },\n        labels: {\n            enabled : false\n        },\n        /*stops: [\n            [0.1, COLOURS.GREEN], // green\n            [0.9, COLOURS.YELLOW], // yellow\n            [0.99, COLOURS.RED] // red\n        ],*/\n        lineWidth: 0,\n        tickWidth: 0,\n        tickAmount : 0,\n        minorTickWidth: 0\n    }\n}\n\nfunction getPaneObject (xPosition, yPosition) {\n    return {\n        center: [xPosition, yPosition],\n        size: '50%',\n        startAngle: 0,\n        endAngle: 360,\n        background: {\n            backgroundColor: '#EEE',\n            borderColor: null,\n            innerRadius: '80%',\n            outerRadius: '100%',\n            shape: 'arc'\n        }\n    }\n}\n\n//--------------------------------------------------------------------------------------//\n//                                       HELPER FUNCTIONS                               //\n//--------------------------------------------------------------------------------------//\n\n\n/**\n * Log to cplace\n * @param {any} text \n */\nfunction log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}\n\n/**\n * \n * @param {any} msg \n * @returns \n */\nfunction timeSinceStart(msg) {\n    if (!DEBUG) {\n        return\n    }\n    let now = new Date().getTime();\n    cplace.log([(now - START_TIME) + 'ms', (now - LAST_TIME) + 'ms', msg].join(' -- '))\n    LAST_TIME = now;\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Displays all items grouped by Program (ART/Agile Release Train) and iteration.\n * Items can be of type Capability (Feature is a missing feature).\n * Dependencies between items are displayed as a line.\n *\n * Milestones that lie within the period of the iterations are displayed in a separate row.\n *\n * @author Daniel Fader\n * @version 15.03.2023\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName('highcharts-dependency-map-capability');\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst TYPE_CAPABILITY = {\n    TYPE: 'cf.cplace.solution.safe.capability',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        TYPE: 'cf.cplace.solution.safe.capabilityType',\n        FEATURES: 'cf.cplace.solution.safe.feature',\n        PROGRAM: 'cf.cplace.solution.safe.program',\n        SOLUTION: 'cf.cplace.solution.safe.solution.reference',\n        PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n        TEMP_ITERATIONS: 'cf.cplace.solution.safe.iteration'\n    },\n    ENUM: {\n        TYPE: {\n            CAPABILITY: 'capability',\n            ENABLER: 'enabler'\n        }\n    }\n};\n\nconst TYPE_FEATURE = {\n    TYPE: 'cf.cplace.solution.safe.feature',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        ITERATIONS: 'cf.cplace.solution.safe.iterations',\n        PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n        CAPABILITY: 'cf.cplace.solution.safe.capability',\n        PROGRAM: 'cf.cplace.solution.safe.program'\n    }\n};\n\nconst TYPE_MILESTONE = {\n    TYPE: 'cf.cplace.solution.safe.safeMilestone',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        DATE: 'cf.cplace.solution.safe.date',\n        TYPE: 'cf.cplace.solution.safe.type',\n        RELEVANT_FOR: 'cf.cplace.solution.safe.relevantFor' // refers to Program\n    },\n    ENUM: {\n        TYPE: {\n            PI_MILESTONE: '#15 - PI Meilenstein',\n            FIXED_DATE: '#25 - Fixiertes Datum',\n            LEARNING_MILESTONE: '#35 - Learning Meilenstein'\n        }\n    }\n};\n\nconst TYPE_DEPENDENCY = {\n    TYPE: 'cf.cplace.solution.safe.dependency',\n    ATTR: {\n        A: 'cf.cplace.solution.safe.successor',\n        B: 'cf.cplace.solution.safe.predecessor',\n        TYPE: 'cf.cplace.solution.safe.type',\n        STATUS: 'cf.cplace.solution.safe.status',\n        DESCRIPTION: 'cf.cplace.solution.safe.description'\n    },\n    ENUM: {\n        TYPE: {\n            RELATED_TO: 'related to',\n            BLOCKED_BY: 'blocked by'\n        },\n        STATUS: {\n            IDENTIFIED: '15 - identified',\n            CONFLICT: '25 - conflict',\n            RESOLVED: '35 - resolved'\n        }\n    }\n};\n\nconst TYPE_PROGRAM_INCREMENT = {\n    TYPE: 'cf.cplace.solution.safe.programIncrement',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        START: 'cf.cplace.solution.safe.startDate',\n        END: 'cf.cplace.solution.safe.endDate',\n        PREDECESSOR: 'cf.cplace.solution.safe.predecessor' // Program Increment\n    }\n};\n\nconst TYPE_ITERATION = {\n    TYPE: 'cf.cplace.solution.safe.iteration',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n        START: 'cf.cplace.solution.safe.startDate',\n        END: 'cf.cplace.solution.safe.endDate',\n        PREDECESSOR: 'cf.cplace.solution.safe.predecessor' // Iteration\n    }\n};\n\nconst COLORS = {\n    INACTIVE: '#88bbee',\n    ACTIVE: '#4488aa',\n    DEPEND: '#888888',\n    DEPEND_HIGHLIGHT: '#A21622',\n    DEPEND_RESOLVED: '#19ad48',\n    SAFE_MILESTONE: '#3D8F8C',\n    RELEASE: '#366C81',\n    MILESTONE_PLOTBAND: '#E2F3F2',\n    RELEASE_PLOTBAND: '#E2EEF3',\n    CAPABILITY: '#0aa5ff',\n    ENABLER: '#ffc80c',\n    TODAY_PLOTLINE: 'lightgrey'\n};\n\nconst CATEGORY = {\n    SAFE_MILESTONE: 'SAFe Milestones'\n};\n\nconst ROW_SIZE = {\n    PERIOD: 2,\n    ITEM: 1\n};\n\nconst HEIGHTS = {\n    HEADER: 40,\n    ITEM: 25\n};\n\nconst MAX_DATA_LABEL_LENGTH = 25;\nconst DATA_LABEL_PADDING = 0.05;\n\nconst SEPARATOR = {\n    V: ' //VSEP// ',\n    H: ' --HSEP-- '\n};\n\nconst EMPTY_DIAGRAM = {\n    title: {\n        text: 'No data to display'\n    }\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n/*\n*****************\nThis highchart is based on a heatmap, i.e. the chart is divided into a set of X * Y equally sized cells.\n* The first column(s) of the cells are used to show the vertical categories (categoriesVertical), which are provided as separate \"category\" series\n* The first row(s) of the cells are used to show the horizontal categories (categoriesHorizontal), which are provided as separate \"category\" series\n* The rest of the cells represent the data itself\n    * each cell can be identified by its set of vertical and horizontal categories saved as 'key' in the 'keys'-array in the form of a string like \"X Cat Level 1 - X Cat Level 2 / Y Cat Level 1 - Y Cat Level 2 - Y Cat Level 3\" (in theory the levels can be \"dynamic\", which is not used in this specific example. In this example only 1 level is used)\n    * for each cell the number of entities to be shown is counted as 'value' in the 'values'-array.\n    * the entities for each cell are represented as boxes/cards within the cell and are pushed as separate serie to the main data series\n    * dependencies between entities are represented as separate spline series, whereas start and end point of the splines are the left or right edge of the corresponding entity boxes/cards on the map\n\n/***** config options *****/\n\n// 1) category colors horizontal (for each level)\nlet catColorsH = ['#000000', '#dddddd', '#dddddd', '#cccccc', '#cccccc'];\n\n// 2) category colors vertical (for each level)\nlet catColorsV = ['#000000', '#dddddd', '#dddddd', '#cccccc', '#cccccc'];\nlet catColors = ['#dddddd', '#dddddd', '#dddddd', '#dddddd'];\n\n// 3) sort category names on this order\nconst sortOrders = [CATEGORY.SAFE_MILESTONE];\n\nconst maxCols = 1;\nconst maxRows = 1;\n\n\n/***** build up our category structures *****/\nlet categoriesHorizontal = { names: [], subs: [], startDates: [], endDates: [], colors: [], links: [] };\nlet categoriesVertical = { names: [], subs: [], startDates: [], endDates: [], colors: [], links: [] };\nlet keys = [];\nlet values = [];\nlet tooltips = [];\nlet shortNameMap = new Map();\nlet nameMap = new Map();\nlet titleMap = new Map();\nlet colorMap = new Map();\nlet depends = [];\nlet itemValues = [];\nlet itemCats = [];\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n\n// If embedding page is Capability then itself is the item. Otherwise, use pages from connected table\nconst items = isPageOfTypeCapability(embeddingPage) ? [embeddingPage] : Array.from(pages);\nlog('items :'+items)\nlog('Items in pages: ' + items.length);\nif (items.length === 0) {\n    // noinspection JSAnnotator\n    return EMPTY_DIAGRAM;\n}\n\nconst missingDependencies = getMissingDependencies(items);\nitems.push(...missingDependencies);\nlog(`Added ${missingDependencies.length} missing items that the input items depend on.`);\n\nconst allPeriods = getAllPeriods(items);\nlog('allPeriods'+allPeriods)\nif (allPeriods.length === 0) {\n    // noinspection JSAnnotator\n    return EMPTY_DIAGRAM;\n}\n// const allPeriodNames = allPeriods.map(period => period.getName());\nconst allPeriodIds = allPeriods.map(period => period.getId());\nlog('Periods: ' + allPeriods.length);\n\nconst allPrograms = getPrograms(items);\nlog('Programs: ' + allPrograms.length);\n\n\n// Find release planning dashboard, needed for link in the release swimlane\n// const releasePlanningDashboard = Iterables.getFirst(solution.getIncomingPages(RELEASE_DASHBOARD.TYPE, RELEASE_DASHBOARD.ATTR.PROGRAM), null);\n// const releasesLink = releasePlanningDashboard.getUrl();\nconst releasesLink = 'wip';\n// Find PI Planning dashboard, needed for link in the safe milestone swimlane\n// const piManagementDashboard = Iterables.getFirst(solution.getIncomingPages(PI_PLANNING_DASHBOARD.TYPE, PI_PLANNING_DASHBOARD.ATTR.PROGRAM), null);\n// const piManagementLink = piManagementDashboard.getUrl();\nconst piManagementLink = 'wip';\n// Find solution train, needed for finding all programs\n// const solutionTrain = Iterables.getFirst(solution.getIncomingPages(TYPE_CAPABILITY.TYPE, TYPE_CAPABILITY.ATTR.SOLUTION), null);\n\n//find relevant Pis of the program\n// const piSearch = new Search();\n// piSearch.add(Filters.embeddingSpace());\n// piSearch.add(Filters.type(PI.TYPE));\n// piSearch.add(Filters.customAttribute(PI.ATTR.PROGRAM).references(solution));\n// let allPeriods = [];\n// cplace.each(pis, pi => {\n//     const periodStatus = pi.get(PI.ATTR.PERIOD_STATUS);\n//     if (periodStatus && periodStatus.get(PERIOD_STATUS.ATTR.ORDER) != null && periodStatus.get(PERIOD_STATUS.ATTR.ORDER) > -1) {\n//         relevantPiIds.push(pi.getId());\n//         allPeriods.push(pi);\n//     }\n// })\n\n// Create categories based on items\ncplace.each(items, item => {\n    let itemName = item.getName();\n    let itemTitle = item.get(TYPE_CAPABILITY.ATTR.TITLE);\n\n    // Determine dependencies\n    const itemDependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n    log('dependencies'+itemDependencies)\n    const lastItemIteration = getLastIteration(item);\n    const itemIterations = [];\n    if (lastItemIteration !== null) {\n        //only continue with feature, if it is in a relevant PI\n        const iterationId = lastItemIteration.getId();\n        if (allPeriodIds.includes(iterationId)) {\n            itemIterations.push(lastItemIteration);\n        } else {\n            return;\n        }\n    }\n\n    let itemPrograms = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n\n    cplace.each(itemIterations, iteration => {\n        const iterationName = iteration.getName();\n        const iterationUrl = iteration.getUrl();\n\n        // a) format/drilldown of horizontal (xAxis) categories\n        let catX = [\n            (iterationName == null ? ' ' : iterationName)\n        ];\n        // b) format/drilldown of vertical (yAxis) categories\n        let catYs = [];\n\n        cplace.each(itemPrograms, program => {\n            catYs.push({\n                name: [program.getName()],\n                link: program.getUrl()\n            })\n        })\n\n        if (catYs.length === 0) {\n            catYs.push({\n                name: ['w/o Program'],\n                link: null\n            });\n        }\n\n        // c) common keys across both axes (= name of cell within the chart)\n        const categories = [];\n        catYs.forEach(catY => {\n            const cat = [catX.join(SEPARATOR.H), catY.name.join(SEPARATOR.H)].join(SEPARATOR.V);\n            categories.push(cat)\n        });\n\n        // now add them to internal category model\n        categoriesHorizontal = addCategories(categoriesHorizontal, catX, 1, iteration, null, null, (iterationUrl == null ? ' ' : iterationUrl));\n        cplace.each(catYs, catY => {\n            categoriesVertical = addCategories(categoriesVertical, catY.name, 1, null, null, null, (catY.link == null ? ' ' : catY.link));\n        });\n\n        cplace.each(categories, cat => {\n            let idx = keys.indexOf(cat);\n            if (idx < 0) {\n                // key (category) not found -> add a new value\n                keys.push(cat);\n                values.push(1);\n                tooltips.push([itemName]);\n                // add feature name to name Map\n                nameMap.set(cat + 1, '<a href=\"' + item.getUrl() + '\">' + itemName + '</a>');\n                shortNameMap.set(cat + 1, '<a href=\"' + item.getUrl() + '\">' + item.getName().replace(itemTitle, '') + '</a>');\n                titleMap.set(cat + 1, itemTitle);\n                colorMap.set(cat + 1, (item.get(TYPE_CAPABILITY.ATTR.TYPE) === TYPE_CAPABILITY.ENUM.TYPE.CAPABILITY ? COLORS.CAPABILITY : COLORS.ENABLER));\n                //cplace.log ('1st entry nameMap: ' + nameMap.get(cat+1));\n                idx = keys.length - 1;\n            } else {\n                // found -> just update value\n                values[idx] = (values[idx] + 1);\n                tooltips[idx].push(itemName);\n                nameMap.set(cat + values[idx], '<a href=\"' + item.getUrl() + '\">' + itemName + '</a>');\n                shortNameMap.set(cat + values[idx], '<a href=\"' + item.getUrl() + '\">' + item.getName().replace(itemTitle, '') + '</a>');\n                titleMap.set(cat + values[idx], itemTitle);\n                colorMap.set(cat + values[idx], (item.get(TYPE_CAPABILITY.ATTR.TYPE) === TYPE_CAPABILITY.ENUM.TYPE.CAPABILITY ? COLORS.CAPABILITY : COLORS.ENABLER));\n                //cplace.log ('additional entry nameMap: ' + nameMap.get(cat+values[idx]));\n            }\n\n            // add dependencies\n            const itemId = item.getId();\n            if (itemCats[itemId] != null) {\n                itemCats[itemId].push(cat);\n                itemValues[itemId].push(values[idx]);\n            } else {\n                itemCats[itemId] = [cat];\n                itemValues[itemId] = [values[idx]];\n            }\n            itemDependencies.forEach(itemDependency => {\n                const from = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n                if (from && isPageOfTypeCapability(from)) {\n                    depends.push({ to: item, from: from, dependency: itemDependency });\n                }\n            });\n        });\n    });\n});\n\n// Manually add categories for missing ARTs and iterations (if no capability is in there, they were not added so far)\ncplace.each(allPeriods, period => {\n    let name = period.getName();\n    let url = period.getUrl();\n    let catX = [\n        (name == null ? ' ' : name)\n    ];\n    categoriesHorizontal = addCategories(categoriesHorizontal, catX, 1, period, null, null, (url == null ? ' ' : url));\n});\ncplace.each(allPrograms, program => {\n    let name = program.getName();\n    let url = program.getUrl();\n    let catY = [\n        (name == null ? ' ' : name)\n    ];\n    categoriesVertical = addCategories(categoriesVertical, catY, 1, null, null, null, (url == null ? ' ' : url));\n})\n\n// Add categories as swimlanes for the releases and SAFe milestones\n// categoriesVertical = addCategories(categoriesVertical, ['Releases'], 1, null, COLORS.RELEASE_PLOTBAND, 0, releasesLink);\ncategoriesVertical = addCategories(categoriesVertical, [CATEGORY.SAFE_MILESTONE], 1, null, COLORS.MILESTONE_PLOTBAND, 0, piManagementLink);\n\nlog('result H: ' + JSON.stringify(categoriesHorizontal));\nlog('result V: ' + JSON.stringify(categoriesVertical));\nlog('keys: ' + JSON.stringify(keys));\nlog('values: ' + JSON.stringify(values));\nlog('depends: ' + JSON.stringify(depends));\nlog('itemCats: ' + JSON.stringify(itemCats));\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n/**\n * Determines the periods used as columns of the board\n * @param {Page[]} items Capabilities\n * @returns {Page[]} Iterations in chronological order\n */\nfunction getAllPeriods(items) {\n    const periodsSet = new HashSet();\n    items.forEach(item => {\n        const pi = item.get(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT);\n        if (!pi) {\n            return;\n        }\n        const iterations = pi.getIncomingPagesFromAllSpaces(TYPE_ITERATION.TYPE, TYPE_ITERATION.ATTR.PROGRAM_INCREMENT);\n        cplace.each(iterations, iteration => {\n            periodsSet.add(iteration);\n        });\n    });\n    const periods = Array.from(periodsSet);\n    return periods.sort((a, b) => a.get(TYPE_ITERATION.ATTR.START).isBefore(b.get(TYPE_ITERATION.ATTR.START)) ? -1 : 1);\n}\n\n/**\n * Determines all programs/ARTs that are included in the input data.\n * These elements are used to define the rows of the boards\n * @param {Page[]} items\n * @returns {Page[]} Programs\n */\nfunction getPrograms(items) {\n    const programSet = new HashSet();\n    items.forEach(item => {\n        const programs = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n        if (!programs) {\n            return;\n        }\n        cplace.each(programs, program => programSet.add(program));\n    });\n    return Array.from(programSet);\n}\n\n/**\n * Searches dependencies of the items and returns those that are not yet included\n * @param {Page[]} items\n * @return {Page[]}\n */\nfunction getMissingDependencies(items) {\n    const dependencies = new HashSet();\n    items.forEach(item => {\n        const itemDependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n        itemDependencies.forEach(itemDependency => {\n            const dependency = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n            if (isPageOfTypeCapability(dependency)) {\n                dependencies.add(dependency);\n            }\n        });\n    });\n    return Array.from(dependencies).filter(a => !items.some(b => b.getId() === a.getId()));\n}\n\n/**\n * Determines the last iteration\n * @param {Page} item Category\n */\nfunction getLastIteration(item) {\n    const iterations = Array.from(item.get(TYPE_CAPABILITY.ATTR.TEMP_ITERATIONS));\n    // log(`Found ${iterations.length} iterations for item \"${item.getName()}\"`);\n    // TODO Use references of features to iterations once the data (model) is cleared\n    // const features = item.get(TYPE_CAPABILITY.ATTR.FEATURES);\n    // const iterationsSet = new HashSet();\n    // cplace.each(features, feature => {\n    //     const featureIterations = feature.get(TYPE_FEATURE.ATTR.ITERATIONS);\n    //     cplace.each(featureIterations, iteration => {\n    //         iterationsSet.add(iteration);\n    //     });\n    // });\n    //const iterations = Array.from(iterationsSet);\n    //log(`Found ${Iterables.size(features)} features and ${iterations.length} iterations for item \"${item.getName()}\"`);\n    let lastIteration = iterations.length > 0 ? iterations[0] : null;\n    iterations.forEach(iteration => {\n        if (lastIteration.get(TYPE_ITERATION.ATTR.END).isBefore(iteration.get(TYPE_ITERATION.ATTR.END))) {\n            lastIteration = iteration;\n        }\n    });\n    log(`Found ${iterations.length} iterations for item \"${item.getName()}\"`);\n    if (lastIteration) {\n        log(`Last iteration \"${lastIteration.getName()}\" ending ${lastIteration.get(TYPE_ITERATION.ATTR.END).toString()}`);\n    }\n    return lastIteration;\n}\n\n// helper function - insert new category into data structure (recursively)\nfunction addCategories(categories, names, level, iteration, color, order, link) {\n    // pop first name from stack and search\n    const categoryName = names.shift();\n    const idx = categories.names.indexOf(categoryName);\n    if (idx < 0) {\n        // not found yet -> insert new category name\n        let inserted = false;\n        const newOrder = sortOrders.indexOf(categoryName);\n        // now loop all current names and insert at right position (ordered!)\n        if (order != null) {\n            categories.names.forEach(cat => {\n                let currOrder = sortOrders.indexOf(cat);\n                if ((!inserted && newOrder >= 0 && currOrder >= 0 && newOrder < currOrder)\n                    || (!inserted && newOrder >= 0 && currOrder < 0) // if order of new category is specified and others are not\n                    || (!inserted && categoryName !== '' && categoryName < cat)) {\n                    categories.names.splice(order, 0, categoryName);\n\n                    // If there is an iteration, add StartDate and Enddate at catIdx Position\n                    categories.startDates.splice(order, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.START) : null));\n                    categories.endDates.splice(order, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.END) : null));\n\n                    // If there is a color, add it at catIdx Position\n                    categories.colors.splice(order, 0, (color ? color : null));\n\n                    // Add link for the category\n                    categories.links.splice(order, 0, (link ? link : null));\n\n                    if (names.length > 0) {\n                        // If there is more to check, go one level deeper\n                        categories.subs.splice(order, 0, addCategories({\n                            names: [],\n                            subs: [],\n                            startDates: [],\n                            endDates: [],\n                            colors: [],\n                            links: []\n                        }, names, level + 1, iteration, color, link));\n                    }\n                    inserted = true;\n                }\n            });\n        } else {\n            categories.names.forEach((cat, catIdx) => {\n                let currOrder = sortOrders.indexOf(cat);\n                if ((!inserted && newOrder >= 0 && currOrder >= 0 && newOrder < currOrder)\n                    || (!inserted && categoryName !== '' && categoryName < cat)) {\n                    categories.names.splice(catIdx, 0, categoryName);\n\n                    // if there is an iteration, add StartDate and Enddate at catIdx Position\n                    categories.startDates.splice(catIdx, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.START) : null));\n                    categories.endDates.splice(catIdx, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.END) : null));\n\n                    // if there is a color, add it at catIdx Position\n                    categories.colors.splice(catIdx, 0, (color ? color : null));\n\n                    // add link for the category\n                    categories.links.splice(catIdx, 0, (link ? link : null));\n\n                    if (names.length > 0) {\n                        // if there is more to check, go one level deeper\n                        categories.subs.splice(catIdx, 0, addCategories({\n                            names: [],\n                            subs: [],\n                            startDates: [],\n                            endDates: [],\n                            colors: [],\n                            links: []\n                        }, names, level + 1, iteration, color, link));\n                    }\n                    inserted = true;\n                }\n            });\n        }\n        // nothing found -> add as last element in array\n        if (!inserted) {\n            log('Category not inserted');\n            categories.names.push(categoryName);\n\n            // there is an iteration, push new StartDate and Enddate\n            categories.startDates.push((iteration ? iteration.get(TYPE_ITERATION.ATTR.START) : null));\n            categories.endDates.push((iteration ? iteration.get(TYPE_ITERATION.ATTR.END) : null));\n\n            // if there is a color, add it at catIdx Position\n            categories.colors.push((color ? color : null));\n\n            // add link for the category\n            categories.links.push((link ? link : null));\n\n            if (names.length > 0) {\n                // if there is more to check, go one level deeper\n                categories.subs.push(addCategories({\n                    names: [],\n                    subs: [],\n                    startDates: [],\n                    endDates: [],\n                    colors: [],\n                    links: []\n                }, names, level + 1, iteration, color, link));\n            }\n        }\n    } else {\n        // found -> just go one level deeper\n        if (names.length > 0) {\n            // if there is more to check, go one level deeper\n            categories.subs[idx] = addCategories(categories.subs[idx], names, level + 1, iteration, color);\n        }\n    }\n    return categories;\n}\n\n// now build up highcharts data series\nconst series = [];\n\n// helper function - count (sub-) categories to derive x- and y-offsets (recursively)\nfunction countCategories(categories, xOffset, yOffset, level, maxLevel, dir) {\n    let cnt = 0;\n    // starting coordinate (depending on direction, vertical/horizontal)\n    if (dir === 'H') {\n        categories.start = xOffset;\n    } else {\n        categories.start = yOffset;\n    }\n\n    // loop all category names\n    categories.names.forEach((name, idx) => {\n        let subCnt = 1;\n        // go one level deeper, if there is more, and add up sub-categories\n        if (categories.subs && idx < categories.subs.length) {\n            categories.subs[idx] = countCategories(categories.subs[idx], xOffset, yOffset, level + 1, maxLevel, dir);\n            subCnt = categories.subs[idx].cnt;\n        }\n\n        // calc coordinates\n        let colSize = 1;//(level == maxLevel ? maxCols : 1);\t\t// last level will be size 2x1\n        let rowSize = 1;//(level == maxLevel ? maxRows : 1);\t\t// last level will be size 1x2\n        let rotation = 0;\n        let x = xOffset;\n        let y = yOffset;\n        let color = categories.colors[idx] !== null ? categories.colors[idx] : catColors[level]; //'#ffffff';\t\t// coloring by level\n        let fontColor = '#000000';\n        if (dir === 'H') {\n            // horizontal categories\n            colSize = subCnt;\t\t\t\t\t\t\t\t// span multiple columns\n            rotation = 0;                                 // no rotation (level == maxLevel ? -90 : 0);\t\t// rotate only on max level\n            x += (subCnt - 1) / 2;\n            y += level + (level === maxLevel ? (maxRows - 1) / 2.0 : 0);\n            //color = catColorsH[1+xOffset%2];\t\t\t\t// alternating colors from config object (1 or 2)\n            //fontColor = catColorsH[0];\t\t\t\t\t// first color from config object\n        } else {\n            // vertical categories\n            rowSize = subCnt;\t\t\t\t\t\t\t\t// span multiple rows\n            rotation = (level === maxLevel ? 0 : -90);\t\t// rotate all but max level\n            x += level + (level === maxLevel ? (maxCols - 1) / 2.0 : 0);\n            y += (subCnt - 1) / 2;\n            //color = catColorsV[1+yOffset%2];\t\t\t\t// alternating colors from config object (1 or 2)\n            //fontColor = catColorsV[0];\t\t\t\t\t// first color from config object\n        }\n\n        // Find link to the page the category should lead to\n        let link = categories.links[idx];\n\n        if (name != null && name.length > 1) {\n            // now add categories cell to series\n            series.push({\n                name: name,\n                colsize: colSize,\n                rowsize: rowSize,\n                dataLabels: { rotation: rotation, color: fontColor },\n                enableMouseTracking: false,\n                data: [{ x: x, y: y, value: level, name: '<a href=\"' + link + '\">' + name + '</a>', color: color }]\n            });\n        }\n\n        // update coordinates\n        if (dir === 'H') {\n            xOffset += subCnt;\n        } else {\n            yOffset += subCnt;\n        }\n        cnt += subCnt;\n    });\n    categories.cnt = cnt;\n    categories.end = categories.start + cnt;\n    return categories;\n}\n\n\n// helper function - maximum depth of categories\nfunction findMaxLevel(categories, level) {\n    let maxLevel = level;\n    if (categories.subs) {\n        categories.subs.forEach(sub => {\n            maxLevel = findMaxLevel(sub, level + 1);\n        });\n    }\n    return maxLevel;\n}\n\n// find maximum depth in both directions\nlet maxLevelV = findMaxLevel(categoriesVertical, 1);\nlet maxLevelH = findMaxLevel(categoriesHorizontal, 1);\n\n// count and build series objects for categories\ncategoriesVertical = countCategories(categoriesVertical, 0, maxLevelH + maxRows, 1, maxLevelV, 'V');\n//let maxOffsetV = categoriesVertical.cnt;\ncategoriesHorizontal = countCategories(categoriesHorizontal, maxLevelV + maxCols, 0, 1, maxLevelH, 'H');\n//let maxOffsetH = categoriesHorizontal.cnt;\n\nlog('result H: ' + JSON.stringify(categoriesHorizontal));\nlog('result V: ' + JSON.stringify(categoriesVertical));\n\n\nconst maxValue = Math.max(...values);\n\n// finally add cells for each value of the matrix\n// loop all keys (= joined category for both axes)\nkeys.forEach((key, idx) => {\n    // split key into categories and names\n    const cat = key.split(SEPARATOR.V);\n    const catX = cat[0].split(SEPARATOR.H);\n    const catY = cat[1].split(SEPARATOR.H);\n    const x = findCategory(categoriesHorizontal, catX);\n    const y = findCategory(categoriesVertical, catY);\n\n    let val = values[idx];\n\n    // special build up name of cell for tooltip\n    let name = '<b>' + key + '</b><br>';\n\n    const data = [];\n    let offset = -0.4 + 0.4 / maxValue;\n    for (let n = 0; n < val; n++) {\n        let mapKey = n + 1;\n        data.push({\n            x: x,\n            y: y + offset,\n            value: n,\n            name: nameMap.get(key + mapKey),\n            shortName: shortNameMap.get(key + mapKey),\n            color: colorMap.get(key + mapKey),\n            title: titleMap.get(key + mapKey)\n        });\n        offset += 0.8 / maxValue;\n    }\n\n    // add series for new data value (= single cell in matrix) ///TO DO: linking with same capability in other program swimlane\n    series.push({\n        name: tooltips[idx].join('<br>'),\n        colsize: 0.8,\n        rowsize: 0.7 / maxValue, //1,\n        pointPadding: 0,\n        borderRadius: 0, //25,\n        borderWidth: 1,\n        borderColor: 'rgba(0,0,0,0)',\n        dataLabels: {\n            enabled: true,\n            color: '#000000',\n            format: '{point.shortName}'\n        },\n        enableMouseTracking: true,\n        data: data //[{ x: x, y: y, value: val, name: val, color: color }]\n    });\n});\n\n\n// helper function - evaluate coordinates of given key (= category along both axes)\nfunction findCategory(categories, names) {\n    const categoryName = names.shift();\n    const idx = categories.names.indexOf(categoryName);\n    if (names.length > 0 && idx >= 0 && categories.subs && categories.subs.length > 0) {\n        return findCategory(categories.subs[idx], names);\n    }\n    return categories.start + idx;\n}\n\n// Iterate through all dependencies in order to draw them\ndepends.forEach(depend => {\n    const fromId = depend.from.getId();\n    const toId = depend.to.getId();\n    // split key into categories and names\n    const fromCats = itemCats[fromId];\n    if (!fromCats) {\n        return;\n    }\n    fromCats.forEach((fromCat, idx1) => {\n        const cat1 = fromCat.split(SEPARATOR.V);\n        const catX1 = [cat1[0]];//.split(\" - \");\n        //catX1.push(cat1[0]);\n        const catY1 = [cat1[1]];//.split(\" - \");\n        //catY1.push(cat1[1]);\n        const x1 = findCategory(categoriesHorizontal, catX1);\n        let y1 = findCategory(categoriesVertical, catY1);\n        y1 += -0.4 + 0.4 / maxValue + (itemValues[depend.from.getId()][idx1] - 1) * 0.8 / maxValue;\n\n        const toCats = itemCats[toId];\n        if (!toCats) {\n            // Dependency is not included in diagram scope and cannot be drawn\n            return;\n        }\n        toCats.forEach((toCat, idx2) => {\n            const cat2 = toCat.split(SEPARATOR.V);\n            const catX2 = [cat2[0]];\n            const catY2 = [cat2[1]];\n            const x2 = findCategory(categoriesHorizontal, catX2);\n            let y2 = findCategory(categoriesVertical, catY2);\n            y2 += -0.4 + 0.4 / maxValue + (itemValues[depend.to.getId()][idx2] - 1) * 0.8 / maxValue;\n            const description = depend.dependency.get(TYPE_DEPENDENCY.ATTR.DESCRIPTION) || ' ';\n            const dependencyType = depend.dependency.get(TYPE_DEPENDENCY.ATTR.TYPE);\n            const status = depend.dependency.get(TYPE_DEPENDENCY.ATTR.STATUS);\n\n            const dependencySeries = {\n                type: 'spline',\n                name: '<b>' + depend.to.getName() + '</b><br/>relates to:<br/>' + depend.from.getName() + '<br>' + description,\n                lineWidth: 1.5,\n                color: COLORS.DEPEND,\n                dashStyle: 'shortdot',\n                findNearestPointBy: 'xy',\n                data: [\n                    { x: x1 + 0.4, y: y1 },\n                    { x: x1 + 0.45, y: (y1 === y2 ? y1 + 0.02 : y1) },\n                    { x: x2 - 0.45, y: (y1 === y2 ? y2 - 0.02 : y2) },\n                    { x: x2 - 0.4, y: y2, marker: { enabled: true, symbol: 'diamond' } }\n                ]\n            };\n            if (dependencyType === TYPE_DEPENDENCY.ENUM.TYPE.BLOCKED_BY) {\n                dependencySeries.name = '<b>' + depend.to.getName() + '</b><br/>blocked by:<br/>' + depend.from.getName() + '<br>' + description;\n                dependencySeries.dashStyle = null;\n            }\n            if (status === TYPE_DEPENDENCY.ENUM.STATUS.CONFLICT) {\n                dependencySeries.color = COLORS.DEPEND_HIGHLIGHT;\n            } else if (status === TYPE_DEPENDENCY.ENUM.STATUS.RESOLVED) {\n                dependencySeries.color = COLORS.DEPEND_RESOLVED;\n            }\n            series.push(dependencySeries);\n        });\n    });\n});\n\n\n// Add releases\n// let releaseDateSearch = new Search();\n// releaseDateSearch.add(Filters.embeddingSpace());\n// releaseDateSearch.add(Filters.type(TYPE_RELEASE.TYPE));\n// releaseDateSearch.add(Filters.customAttribute(RELEASE.ATTR.PROGRAM).references(solution));\n// let releases = releaseDateSearch.findAllPages();\n//  let releaseData = [];\n//\n// cplace.each(releases, function (release) {\n//     let releaseName = release.getName();\n//     let releaseDate = release.get(RELEASE.ATTR.DATE);\n//     let releaseDateString = releaseDate.toString('dd.MM.yyyy');\n//     // get release Position\n//     let releasePosition = getDatePosition(releaseDate.getMillis());\n//     // add release only if releasePosition is not null\n//     if (releasePosition > 0) {\n//         releaseData.push({\n//             x: releasePosition,\n//             y: 2,\n//             name: '<a href=\"' + release.getUrl() + '\">' + releaseName + '</a>',\n//             value: releaseDateString\n//         });\n//     }\n// });\n//\n// series.push({\n//     type: 'scatter',\n//     lineWidth: 0,\n//     findNearestPointBy: 'xy',\n//     data: releaseData,\n//     marker: {\n//         fillColor: COLORS.RELEASE\n//     }\n// });\n\n// Add SAFe milestones\nconst periodStartDate = allPeriods.length > 0 ? allPeriods[0].get(TYPE_ITERATION.ATTR.START) : new DateTime();\nconst periodEndDate = allPeriods.length > 0 ? allPeriods[allPeriods.length - 1].get(TYPE_ITERATION.ATTR.END) : new DateTime();\nconst safeMilestoneSearch = new Search();\nsafeMilestoneSearch.add(Filters.embeddingSpace());\nsafeMilestoneSearch.add(Filters.type(TYPE_MILESTONE.TYPE));\nsafeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).gte(periodStartDate));\nsafeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).lte(periodEndDate));\nconst safeMilestones = safeMilestoneSearch.findAllPages();\nconst safeMilestoneData = [];\n\nlog('Milestones: ' + safeMilestones.length);\n\ncplace.each(safeMilestones, safeMilestone => {\n    const safeMilestoneName = safeMilestone.getName();\n    const safeMilestoneDate = safeMilestone.get(TYPE_MILESTONE.ATTR.DATE);\n    const safeMilestoneDateString = safeMilestoneDate.toString('dd.MM.yyyy');\n    // get milestone Position\n    const safeMilestonePosition = getDatePosition(safeMilestoneDate.getMillis());\n    // add milestone only if position is not null\n    if (safeMilestonePosition > 0) {\n        safeMilestoneData.push({\n            x: safeMilestonePosition,\n            y: 2,\n            name: '<a href=\"' + safeMilestone.getUrl() + '\">' + safeMilestoneName + '</a>',\n            value: safeMilestoneDateString\n        });\n    }\n});\n\nseries.push({\n    type: 'scatter',\n    lineWidth: 0,\n    findNearestPointBy: 'xy',\n    data: safeMilestoneData,\n    marker: {\n        fillColor: COLORS.SAFE_MILESTONE\n    }\n});\n\n//define today line position\nconst today = new DateTime();\nlet todayPosition = getDatePosition(today.getMillis());\n\n\n//helper function for finding milestone/today line position\nfunction getDatePosition(date) {\n    let xPosition = 0;\n    categoriesHorizontal.names.every((categoryName, idx) => {\n        let categoryStartDate = categoriesHorizontal.startDates[idx].getMillis();\n        let categoryEndDate = categoriesHorizontal.endDates[idx].getMillis();\n        // Check whether release date lies in between start and end date of category\n        if (date >= categoryStartDate && date <= categoryEndDate) {\n            // find x-Value of category and substract 0.5 for starting point as offset\n            let x = findCategory(categoriesHorizontal, [categoryName]) - 0.5;\n            // calculate the relative position of date between Category StartDate and EndDate and add it to the offset value\n            xPosition = x + (date - categoryStartDate) / (categoryEndDate - categoryStartDate);\n            // exit the every loop\n            return false;\n        }\n        // continue the every loop\n        return true;\n    });\n    // if there was no match, just return null\n    return xPosition;\n}\n\n\n// Build the Highcharts configuration object\nconst chart = {\n    chart: {\n        type: 'heatmap',\n        marginTop: 0,\n        marginBottom: 0,\n        plotBorderWidth: 0\n    },\n    title: {\n        text: null\n    },\n    xAxis: {\n        categories: [],\n        title: null,\n        gridLineWidth: 0,\n        lineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        //min: -1,\n        //max: Math.max(categoriesVertical.end,categoriesHorizontal.end)-1\n        plotLines: [{\n            dashStyle: 'dash',\n            color: COLORS.TODAY_PLOTLINE,\n            width: 2,\n            value: todayPosition,\n            zIndex: 1\n        }]\n    },\n    yAxis: {\n        categories: [],\n        title: null,\n        gridLineWidth: 0,\n        lineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        reversed: true,\n        // min: -1,\n        // max: Math.max(categoriesVertical.end, categoriesHorizontal.end) - 1,\n        plotBands: [\n            {\n                color: COLORS.MILESTONE_PLOTBAND,\n                borderColor: 'white',\n                borderWidth: 2,\n                from: 1.5,\n                to: 2.5,\n                zIndex: 0\n            }\n            // {\n            //     color: COLORS.RELEASE_PLOTBAND,\n            //     borderColor: 'white',\n            //     borderWidth: 2,\n            //     from: 1.5,\n            //     to: 2.5,\n            //     zIndex: 0\n            // }\n        ]\n    },\n    colors: ['#D5001C', '#92D050'],\n    colorAxis: {\n        dataClassColor: 'category',\n        dataClasses: [{\n            to: 0.5\n        }, {\n            from: 0.5\n        }]\n    },\n    legend: {\n        enabled: false\n    },\n    tooltip: {\n        useHTML: true,\n        followPointer: false\n    },\n    plotOptions: {\n        series: {\n            borderColor: '#ffffff',\n            borderWidth: 2,\n            dataLabels: {\n                allowOverlap: false,\n                inside: true,\n                crop: true,\n                overflow: 'justify',\n                position: 'left',\n                shape: 'circle',\n                enabled: true,\n                color: '#000000',\n                format: '{point.name}',\n                style: {\n                    textOutline: 'none',\n                    textOverflow: 'clip'\n                }\n            },\n            stickyTracking: false,\n            tooltip: {\n                headerFormat: '',\n                pointFormat: '<b>{point.name}</b>',\n                findNearestPointBy: 'xy',\n            },\n            states: {\n                inactive: {\n                    opacity: 1\n                }\n            }\n        },\n        spline: {\n            tooltip: {\n                headerFormat: '{series.name}',\n                pointFormat: '',\n                findNearestPointBy: 'xy',\n            },\n            marker: {\n                enabled: false,\n                fillColor: COLORS.DEPEND,\n                radius: 6,\n                states: {\n                    hover: {\n                        enabled: false\n                    }\n                }\n            }\n        },\n        scatter: {\n            tooltip: {\n                headerFormat: '',\n                pointFormat: '<b>{point.name}</b><br>{point.value}',\n                findNearestPointBy: 'xy'\n            },\n            dataLabels: {\n                enabled: true\n            },\n            marker: {\n                enabled: true,\n                symbol: 'diamond',\n                radius: 10,\n                states: {\n                    hover: {\n                        enabled: true\n                    }\n                }\n            }\n        }\n    },\n    series: series\n};\n\n// noinspection JSAnnotator\nreturn chart;\n\n//--------------------------------------------------------------------------------------//\n//                                       HELPER FUNCTIONS                               //\n//--------------------------------------------------------------------------------------//\n\nfunction isPageOfTypeCapability(page) {\n    return page.getBuiltinFeatureValue('customType') === TYPE_CAPABILITY.TYPE;\n}\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    const logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('HC: Prioritization Matrix')\n\n/**\n * Define colors for the chart\n */\n const CHART_LABELS = {\n   XAXIS_TITLE: '<- Cost of Delay ->',\n   YAXIS_TITLE: '<- Job Duration ->'\n }\n const CHART_COLORS = {\n  PLOTLINES: '#b5b5b5',\n  DONT_DO_TEXT: '#EC7E80',\n  DO_NEXT_TEXT: '#3A4454',\n  DO_LATER_TEXT: '#313C4E',\n  DO_NOW_TEXT:  '#7EC587',\n  ENABLER: '#E6D32B',\n  FEATURE: '#0CA2D4',\n}\n\nconst FEATURE = {\n    ATTR: {\n      JOB_SIZE: 'cf.cplace.solution.safe.jobSize',\n      BUSINESS_VALUE: 'cf.cplace.solution.safe.businessValue',\n      TIME_CRITICALITY: 'cf.cplace.solution.safe.timeCriticality',\n      RISK_REDUCTION: 'cf.cplace.solution.safe.riskReduction',\n      WSJF: 'cf.cplace.solution.safe.wsjf',\n      STATUS: '',\n      TYPE: 'cf.cplace.solution.safe.featureType'\n    },\n    ENUM_STATUS: {\n\n    },\n    ENUM_TYPE: {\n        ENABLER: 'enabler',\n        FEATURE: 'feature'\n    }\n  }\n\n/*//find colors for types\nlet typeColorConfigurations = new Search()\n  .add(Filters.type('de.visualistik.visualRoadmap.visualRoadmapConfiguration'))\n  .add(Filters.customAttribute('de.visualistik.visualRoadmap.configurationTypeMap').eq('colorMap'))\n  .add(Filters.customAttribute('de.visualistik.visualRoadmap.propertyKey').eq('cf.cplace.solution.safe.type'))\n  .findAllPages();\n\n  cplace.each(typeColorConfigurations, configuration => {\n    let values = configuration.get('de.visualistik.visualRoadmap.propertyKeyValues');\n    let color = configuration.get('de.visualistik.visualRoadmap.displayedValue');\n    if (values.indexOf('#15 - Enabler') > -1){\n      CHART_COLORS.ENABLER = color\n    }\n    if (values.indexOf('#25 - Epic') > -1){\n      CHART_COLORS.EPIC = color\n    }\n  })*/\n\n  const language = cplace.utils().getCurrentUser().getUserLanguage();\n\n/**\n * create serie and data items\n */\nlet serie = createBubbleSerie()\nlet maxBubbleSize = 0;\n\ncplace.each(pages, function (feature) {\n    let z = feature.get(FEATURE.ATTR.WSJF);\n    if (z) {\n        let time = feature.get(FEATURE.ATTR.TIME_CRITICALITY);\n        let business = feature.get(FEATURE.ATTR.BUSINESS_VALUE);\n        let risk = feature.get(FEATURE.ATTR.RISK_REDUCTION);\n        let x = time + business + risk;\n        let jobSize = feature.get(FEATURE.ATTR.JOB_SIZE);\n        let y = switchSize(jobSize);\n        let type = feature.get(FEATURE.ATTR.TYPE);\n    \n        if (z > maxBubbleSize) {\n            maxBubbleSize = z;\n        }\n        serie.data.push(createDataItem(feature, x, y, z, type));\n    }\n});\n\nserie.data.push(createHiddenDataItem(0, 0, maxBubbleSize));\nserie.data.push(createHiddenDataItem(0, 20, maxBubbleSize));\nserie.data.push(createHiddenDataItem(60, 0, maxBubbleSize));\nserie.data.push(createHiddenDataItem(60, 20, maxBubbleSize));\n\nlet xAxisPlotLines = [];\nlet yAxisPlotLines = [];\n\n// Create quadrant divider\nxAxisPlotLines.push(createQuadrantPlotline(30));\nyAxisPlotLines.push(createQuadrantPlotline(10));\n\n// Create labels for each quadrant\nlet label = createLabelPlotline('DON\\'\\T DO', 0, 'left',  CHART_COLORS.DONT_DO_TEXT, -10, 37);\nyAxisPlotLines.push(label);\nlabel = createLabelPlotline('DO NEXT', 0, 'right',  CHART_COLORS.DO_NEXT_TEXT, 0, 37);\nyAxisPlotLines.push(label);\nlabel = createLabelPlotline('DO LATER', 20, 'left',  CHART_COLORS.DO_LATER_TEXT, -10, -25);\nyAxisPlotLines.push(label);\nlabel = createLabelPlotline('DO NOW', 20, 'right',  CHART_COLORS.DO_NOW_TEXT, 0, -25);\nyAxisPlotLines.push(label);\n\n/**\n * BUILD CHART\n */\nlet config = {\n    chart: {\n        type: 'bubble',\n    },\n\n    legend: {\n        enabled: false\n    },\n\n    title: {\n        text: ''\n    },\n\n    xAxis: {\n        title: {\n            text: CHART_LABELS.XAXIS_TITLE\n        },\n        lineWidth: 0,\n        gridLineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        tickWidth: 0,\n        tickInterval: 5,\n        startOnTick: false,\n        endOnTick: false,\n        showLastLabel: true,\n        plotLines: xAxisPlotLines\n    },\n\n    yAxis: {\n        title: {\n            text: CHART_LABELS.YAXIS_TITLE\n        },\n        lineWidth: 0,\n        gridLineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        tickWidth: 0,\n        tickInterval: 5,\n        startOnTick: false,\n        endOnTick: false,\n        plotLines: yAxisPlotLines\n    },\n\n    tooltip: {\n        useHTML: true,\n        headerFormat: '',\n        pointFormat: '{point.tooltip}',\n        style: {\n            pointerEvents: 'auto'\n        }\n    },\n\n    plotOptions: {\n        bubble: {\n            dataLabels: {\n                enabled: false,\n            },\n            minSize: 1,\n            maxSize: 50\n        }\n    },\n    series: [serie]\n};\n\nreturn config;\n\n/**\n * ================\n * HELPER FUNCTIONS\n * ================\n */\n\nfunction createBubbleSerie() {\n    return {\n        data: [],\n        marker: {\n            fillOpacity: 0.13,\n            lineWidth: 0\n        }\n    };\n}\n\nfunction createDataItem(page, x, y, z, type) {\n    let color = getColor(type);\n    let rgba = hexToRGBA(color, 0.1);\n    return {\n        name: page.getName(),\n        url: page.getUrl(),\n        x: x,\n        y: y,\n        z: z,\n        tooltip: getTooltip(page),\n        color: rgba,\n        marker: {\n            lineColor: color,\n        },\n        dataLabels: {\n            enabled: true,\n            format: '{point.name}',\n            style: {\n                textOutline: false,\n                color: color\n            }\n        }\n    }\n}\n\nfunction getTooltip(page) {\n    let tooltip = '<a style=\"font-weight:bold\" href=' + page.getUrl()+ 'target=\"_blank\">' + page.getName() + '</a><br/>'+\n    'Time Criticality: ' + page.get(FEATURE.ATTR.TIME_CRITICALITY) + '<br/>' +\n    'Business Value: ' + page.get(FEATURE.ATTR.BUSINESS_VALUE) + '<br/>' +\n    'Risk Reduction: ' + page.get(FEATURE.ATTR.RISK_REDUCTION) + '<br/>' +\n    'Job Size: ' + page.get(FEATURE.ATTR.JOB_SIZE) + '<br/>' +\n    '<b> WSJF: ' + page.get(FEATURE.ATTR.WSJF) + '<br/>';\n    //'Status: ' + page.get(FEATURE.ATTR.STATUS, language) + '</b>';\n    return tooltip;\n}\n\nfunction createHiddenDataItem(x, y, z) {\n    return {\n        x: x,\n        y: y,\n        z: z,\n        enableMouseTracking: false,\n        marker: {\n            enabled: false\n        }\n    }\n}\n\nfunction createQuadrantPlotline(value) {\n    return {\n        color: CHART_COLORS.PLOTLINES,\n        dashStyle: 'solid',\n        width: 1,\n        value: value,\n        zIndex: 3\n    }\n}\n\nfunction createLabelPlotline(text, value, align, color, xOffset, yOffset) {\n    return {\n        width: 0,\n        value: value,\n        zIndex: 3,\n        label: {\n            text: text,\n            align: align,\n            style: {\n                color: color,\n                fontWeight: 'bold'\n            },\n            x: xOffset,\n            y: yOffset\n        }\n    }\n}\n\nfunction hexToRGBA(hex, alpha) {\n    let r = parseInt(hex.slice(1, 3), 16),\n        g = parseInt(hex.slice(3, 5), 16),\n        b = parseInt(hex.slice(5, 7), 16);\n\n    return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + alpha + \")\";\n}\n\nfunction switchSize(size){\n    let switchedSize\n    switch (size) {\n        case 20:\n            switchedSize = 1;\n            break;\n        case 13:\n            switchedSize = 8;\n            break;\n        case 8:\n            switchedSize = 13;\n            break;\n        case 5:\n            switchedSize = 16;\n            break;\n        case 3:\n            switchedSize = 18;\n            break;\n        case 2:\n            switchedSize = 19;\n            break;\n        case 1:\n            switchedSize = 20;\n            break;\n    }\n    return switchedSize;\n}\n\nfunction getColor(type){\n    switch (type) {\n        case FEATURE.ENUM_TYPE.ENABLER:\n            return CHART_COLORS.ENABLER;\n        case FEATURE.ENUM_TYPE.FEATURE:\n            return CHART_COLORS.FEATURE\n        default: \n            return '#b5b5b5'\n    }\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType cf.cplace.solution.safe.solution\n * @layout default layout\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Displays the timeline with Programm Increments, Safe Events and Safe Milestones. Chart is zoomable and draggable\n */\n\n// set the distinguishing log name\ncplace.setLogName(\"Highcharts - Timeline Overview\");\n\n/***** Start configuration *****/\nconst chartBackgroundColor = \"#FFFFFF\";\nconst lineColor = \"#303038\";\n\nconst piColor = \"#dddddd\";\nconst safeMilestoneColor = \"#3D8F8C\";\nconst eventColor = \"#366C81\";\n\nconst milestonePlotBandColor = \"#E2F3F2\";\nconst eventPlotBandColor = \"#E2EEF3\";\nconst todayPlotline = \"lightgrey\";\n\nconst showMonthsBeforeToday = 3;\nconst showMonthsAfterToday = 9;\n/***** End configuration *****/\n\nconst MILESTONE = {\n    TYPE: \"cf.milestone\",\n    ATTR: {\n        SCHEDULE: \"containingSchedule\",\n        DATE: \"date\",\n        FEATURE_DEPENDENCY: \"cf.cplace.solution.safe.dependency\",\n        TASKCLASS: \"activityClass\",\n    },\n};\nconst FEATURE = {\n    TYPE: \"cf.cplace.solution.safe.feature\",\n    ATTR: {\n        PROGRAM: \"cf.cplace.solution.safe.program\",\n    },\n};\nconst SCHEDULE = {\n    TYPE: \"cf.schedule\",\n    ATTR: {},\n};\nconst TASK_CLASS = {\n    TYPE: \"cf.activityClass\",\n    ATTR: {\n        COLOR: \"barColor\",\n        BORDERCOLOR: \"borderColor\",\n        SHAPE: \"milestoneShape\",\n    },\n};\nconst SAFE_MILESTONE = {\n    TYPE: \"cf.cplace.solution.safe.safeMilestone\",\n    ATTR: {\n        DATE: \"cf.cplace.solution.safe.date\",\n    },\n};\nconst PI = {\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START: \"cf.cplace.solution.safe.startDate\",\n        END: \"cf.cplace.solution.safe.endDate\",\n    },\n};\nconst EVENT = {\n    TYPE: \"cf.cplace.solution.safe.event\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n    },\n};\n\nconst CAPABILITY = ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n    },\n});\n\nfunction main() {\n    /** @type {ChartContext} */\n    const context = {\n        today: new Date(),\n        start: getStartDate(showMonthsBeforeToday),\n        end: getEndDate(showMonthsAfterToday),\n        solution: embeddingPage.get(CAPABILITY.ATTR.SOLUTION),\n        schedules: [],\n        programIncrements: [],\n        events: [],\n        safeMilestones: [],\n        series: [],\n        plotlines: [],\n        categories: [\"<b>Program Increments</b>\", \"<b>Events</b>\", \"<b>SAFe Milestones</b>\"],\n        yIndex: 0,\n    };\n\n    categorizeData(pages, context);\n    createPiSeries(context);\n    createEventSeries(context);\n    createMilestoneSeries(context);\n    //create plotline between SAFe parts and schedules\n    //ctx.plotLines.push(createPlotline(yIndex - 0.5, 1.25));\n    createScheduleSeries(context);\n\n    return createChartConfig(context);\n}\n\n/**\n * Sort pages by their type and them to the context\n * @param {Page[]} pages\n * @param {ChartContext} ctx\n */\nfunction categorizeData(pages, ctx) {\n    cplace.each(pages, (page) => {\n        let type = page.getBuiltinFeatureValue(\"customType\");\n        if (type === SCHEDULE.TYPE) {\n            ctx.schedules.push(page);\n        } else if (type === PI.TYPE) {\n            ctx.programIncrements.push(page);\n        } else if (type === SAFE_MILESTONE.TYPE) {\n            ctx.safeMilestones.push(page);\n        } else if (type === EVENT.TYPE) {\n            ctx.events.push(page);\n        }\n    });\n}\n\n/**\n * Create pi series\n * @param {ChartContext} ctx\n */\nfunction createPiSeries(ctx) {\n    const piData = [];\n    cplace.each(ctx.programIncrements, (pi) => {\n        piData.push(createDataItem(pi.getName(), pi.get(PI.ATTR.START), pi.get(PI.ATTR.END), ctx.yIndex, piColor));\n    });\n    ctx.yIndex++;\n    ctx.series.push({\n        name: \"Program Increments\",\n        showInLegend: false,\n        tooltip: {\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"Start: {point.x: %Y-%m-%d}<br/> End: {point.x2: %Y-%m-%d}\",\n        },\n        data: piData,\n        dataLabels: {\n            enabled: true,\n            format: \"<b>{point.name}</b>\",\n        },\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    });\n    return piData;\n}\n\n/**\n * Create event series\n * @param {ChartContext} ctx\n */\nfunction createEventSeries(ctx) {\n    let eventData = [];\n    cplace.each(ctx.events, (event) => {\n        eventData.push(\n            createDataItem(\n                event.getName(),\n                event.get(EVENT.ATTR.START_DATE),\n                event.get(EVENT.ATTR.END_DATE),\n                ctx.yIndex,\n                eventColor\n            )\n        );\n    });\n    ctx.yIndex++;\n    ctx.series.push({\n        name: \"Events\",\n        showInLegend: false,\n        tooltip: {\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"Start: {point.x: %Y-%m-%d}<br/> End: {point.x2: %Y-%m-%d}\",\n        },\n        data: eventData,\n        dataLabels: {\n            enabled: true,\n            format: \"<b>{point.name}</b>\",\n        },\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    });\n}\n\n/**\n * Create safe milestone series\n * @param {ChartContext} ctx\n */\nfunction createMilestoneSeries(ctx) {\n    let safeMilestoneData = [];\n    cplace.each(ctx.safeMilestones, (safeMilestone) => {\n        safeMilestoneData.push(\n            createMilestoneDataItem(\n                safeMilestone.getName(),\n                safeMilestone.get(SAFE_MILESTONE.ATTR.DATE),\n                ctx.yIndex,\n                safeMilestoneColor,\n                safeMilestoneColor\n            )\n        );\n    });\n    ctx.yIndex++;\n    ctx.series.push(createMilestoneSerie(\"SAFe Milestones\", safeMilestoneData));\n}\n/**\n * Create Chart configuration\n * @param {ChartContext} ctx\n * @returns\n */\nfunction createChartConfig(ctx) {\n    return {\n        chart: {\n            type: \"xrange\",\n            backgroundColor: chartBackgroundColor,\n            panning: true,\n            panKey: \"shift\",\n            zoomType: \"x\",\n        },\n        title: {\n            text: \"\",\n        },\n        yAxis: {\n            title: {\n                text: \"\",\n            },\n            categories: ctx.categories,\n            reversed: true,\n            type: \"category\",\n            plotBands: [\n                {\n                    color: eventPlotBandColor,\n                    from: 0.5,\n                    to: 1.5,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    zIndex: 0,\n                },\n                {\n                    color: milestonePlotBandColor,\n                    from: 1.5,\n                    to: 2.5,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    zIndex: 0,\n                },\n            ],\n        },\n        xAxis: {\n            type: \"datetime\",\n            min: Date.UTC(ctx.start.getFullYear(), ctx.start.getMonth(), ctx.start.getDate(), 0, 0, 0, 0),\n            max: Date.UTC(ctx.end.getFullYear(), ctx.end.getMonth(), ctx.end.getDate(), 23, 59, 59, 59),\n            plotLines: [\n                {\n                    dashStyle: \"dash\",\n                    color: todayPlotline,\n                    width: 2,\n                    value: Date.UTC(ctx.today.getFullYear(), ctx.today.getMonth(), ctx.today.getDate(), 0, 0, 0, 0),\n                    zIndex: 1,\n                },\n                ...ctx.plotlines,\n            ],\n        },\n        tooltip: {\n            enabled: true,\n        },\n        series: ctx.series,\n    };\n}\n\n/**\n * Create schedule series\n * @param {ChartContext} ctx\n */\nfunction createScheduleSeries(ctx) {\n    cplace.each(ctx.schedules, (schedule) => {\n        let relevantSchedule = false;\n        let scheduleData = [];\n        let milestones = schedule.getIncomingPages(MILESTONE.TYPE, MILESTONE.ATTR.SCHEDULE);\n        cplace.each(milestones, (milestone) => {\n            let featureDependency = milestone.get(MILESTONE.ATTR.FEATURE_DEPENDENCY);\n            let isProgramRelevant = false;\n            cplace.each(featureDependency, (feature) => {\n                let featureProgram = feature.get(FEATURE.ATTR.PROGRAM);\n                if (featureProgram && featureProgram.getId() === ctx.solution.getId()) {\n                    isProgramRelevant = true;\n                }\n            });\n            if (isProgramRelevant) {\n                relevantSchedule = true;\n                scheduleData.push(createScheduleMilestoneDataItem(milestone, ctx.yIndex));\n            }\n        });\n        if (relevantSchedule) {\n            ctx.categories.push(createCategory(schedule));\n            ctx.series.push(createMilestoneSerieSchedule(schedule.getName(), scheduleData));\n            ctx.yIndex++;\n        }\n    });\n}\n\n//FUNCTIONS\nfunction createDataItem(name, start, end, y, color) {\n    let startDate = new Date(start);\n    let endDate = new Date(end);\n    return {\n        name: name,\n        x: Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0, 0, 0),\n        x2: Date.UTC(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23, 59, 59, 99),\n        y: y,\n        color: color,\n    };\n}\n\nfunction getMilestoneShape(milestoneShape) {\n    if (milestoneShape === \"Diamond\") return \"diamond\";\n    if (milestoneShape === \"Arrow Up\") return \"diamond\";\n    if (milestoneShape === \"Arrow Down\") return \"diamond\";\n    if (milestoneShape === \"Triangle Up\") return \"triangle\";\n    if (milestoneShape === \"Triangle Down\") return \"triangle-down\";\n    if (milestoneShape === \"Triangle Left\") return \"triangle\";\n    if (milestoneShape === \"Triangle Right\") return \"triangle\";\n    if (milestoneShape === \"Circle\") return \"circle\";\n    if (milestoneShape === \"Square\") return \"square\";\n    if (milestoneShape === \"Star\") return \"diamond\";\n    if (milestoneShape === \"Ramp Down\") return \"diamond\";\n    if (milestoneShape === \"Ramp Up\") return \"diamond\";\n}\n\nfunction createMilestoneDataItem(name, date, y, color, borderColor) {\n    let milestoneDate = new Date(date);\n    return {\n        name: name,\n        x: Date.UTC(milestoneDate.getFullYear(), milestoneDate.getMonth(), milestoneDate.getDate(), 0, 0, 0, 0),\n        y: y,\n        marker: {\n            fillColor: color,\n            lineColor: borderColor,\n            lineWidth: 1,\n        },\n    };\n}\n\nfunction createScheduleMilestoneDataItem(milestone, y) {\n    let name = milestone.getName();\n    let milestoneDate = new Date(milestone.get(MILESTONE.ATTR.DATE));\n    let color = milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.COLOR);\n    let borderColor = milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.BORDERCOLOR);\n    let milestoneShape = getMilestoneShape(milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.SHAPE));\n    let features = milestone.get(MILESTONE.ATTR.FEATURE_DEPENDENCY);\n    let featureList = \"<b>Requested Features:</b>\";\n    cplace.each(features, (feature) => {\n        featureList = featureList + \"<br>\" + feature.getName();\n    });\n\n    return {\n        name: name,\n        x: Date.UTC(milestoneDate.getFullYear(), milestoneDate.getMonth(), milestoneDate.getDate(), 0, 0, 0, 0),\n        y: y,\n        features: featureList,\n        marker: {\n            fillColor: color,\n            lineColor: borderColor,\n            lineWidth: 1,\n            symbol: milestoneShape,\n        },\n    };\n}\n\nfunction createMilestoneSerie(name, dataSeries) {\n    return {\n        name: name,\n        type: \"scatter\",\n        //stickyTracking: false,\n        showInLegend: false,\n        marker: {\n            enabled: true,\n            symbol: \"diamond\",\n            lineWidth: 5,\n            radius: 12,\n        },\n        tooltip: {\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"{point.x: %Y-%m-%d}\",\n        },\n        data: dataSeries,\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    };\n}\n\nfunction createMilestoneSerieSchedule(name, dataSeries) {\n    return {\n        name: name,\n        type: \"scatter\",\n        //stickyTracking: false,\n        showInLegend: false,\n        marker: {\n            enabled: true,\n            symbol: \"diamond\",\n            lineWidth: 5,\n            radius: 12,\n        },\n        tooltip: {\n            useHTML: true,\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"{point.x: %Y-%m-%d}<br>{point.features}\",\n        },\n        data: dataSeries,\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    };\n}\n\nfunction createPlotline(value, width) {\n    return {\n        color: lineColor,\n        width: width,\n        value: value,\n        dashStyle: \"solid\",\n    };\n}\n\nfunction getStartDate(months) {\n    let today = new Date();\n    let startDate = today;\n    startDate.setMonth(today.getMonth() - months);\n    return startDate;\n}\n\nfunction getEndDate(months) {\n    let today = new Date();\n    let endDate = today;\n    endDate.setMonth(today.getMonth() + months);\n    return endDate;\n}\n\nfunction createCategory(object) {\n    let name = object.getName();\n    let url = object.getUrl();\n    return '<a href=\"' + url + '\">' + name + \"</a>\";\n}\n\n/**\n * Object containing context information for the chart.\n * @typedef {Object} ChartContext\n * @property {Date} today - The current date.\n * @property {Date} start - The start date for the chart.\n * @property {Date} end - The end date for the chart.\n * @property {Page} solution - The embeddingPage object representing the current solution.\n * @property {Page[]} schedules - An array of pages representing schedules.\n * @property {Page[]} programIncrements - An array of pages representing program increments.\n * @property {Page[]} events - An array of pages representing events.\n * @property {Page[]} safeMilestones - An array of pages representing SAFe milestones.\n * @property {any[]} series - An array of series\n * @property {any[]} plotlines - An array of plotlines\n * @property {string[]} categories - An array of categories\n * @property {number} yIndex - y-index\n */\n\n// @ts-ignore\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('PI Dashboard');\n//Configurations\nconst DASHBOARD = {\n    TYPE:'cf.cplace.solution.safe.breakdownDashboard',\n    ATTR:{\n      PARENT:'cf.cplace.solution.safe.parent'\n    }\n  }\n  \n  let finallink='';\n  let link, name;\n  let dashboardSearch = new Search()\n    .add(Filters.space(embeddingPage.getSpaceId()))\n    .add(Filters.type(DASHBOARD.TYPE))\n    .add(Filters.customAttributeNonempty(DASHBOARD.ATTR.PARENT))\n    .findAllPages();\n\nlet result = Iterables.getFirst(dashboardSearch, null);\n\nif (result) {\n    link = result.getUrl();\n    name = result.getName();\n}\n  \nreturn '<a href=\"'+link+'\"class=\"current-color\">Open Capablities Dashboard</a>';",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('PI Dashboard');\n//Configurations\nconst DASHBOARD = {\n    TYPE:'cf.cplace.solution.safe.solutionRoadmapDashboard',\n    ATTR:{\n      PARENT:'cf.cplace.solution.safe.parent'\n    }\n  }\n  \n  let finallink='';\n  let link, name;\n  let dashboardSearch = new Search()\n    .add(Filters.space(embeddingPage.getSpaceId()))\n    .add(Filters.type(DASHBOARD.TYPE))\n    .add(Filters.customAttributeNonempty(DASHBOARD.ATTR.PARENT))\n    .findAllPages();\n\nlet result = Iterables.getFirst(dashboardSearch, null);\n\nif (result) {\n    link = result.getUrl();\n    name = result.getName();\n}\n  \nreturn '<a href=\"'+link+'\"class=\"current-color\">Open Solution Roadmap Dashboard</a>';",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('Current PI');\n//Configurations\nconst TIMELINE_DASHBOARD = {\n    TYPE:'cf.cplace.solution.safe.timelineDashboard',\n    ATTR:{\n      PARENT:'cf.cplace.solution.safe.parent'\n    }\n  }\n  \n  let finallink='';\n  let link, name;\n  let piDashboardSearch = new Search()\n    .add(Filters.space(embeddingPage.getSpaceId()))\n    .add(Filters.type(TIMELINE_DASHBOARD.TYPE))\n    .add(Filters.customAttributeNonempty(TIMELINE_DASHBOARD.ATTR.PARENT))\n    .findAllPages();\n\nlet result = Iterables.getFirst(piDashboardSearch, null);\n\nif (result) {\n    link = result.getUrl();\n    name = result.getName();\n}\n  \nreturn '<a href=\"'+link+'\"class=\"current-color\">Open Timeline Dashboard</a>';",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Displays all items grouped by Solution and PI.\n * Dependencies between items are displayed as a line.\n *\n * Milestones that lie within the period of the PIs are displayed in a separate row.\n *\n * @author Christopher W\u00f6lfle\n * @version 15.03.2023\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName(\"highcharts-solution-dependency-map\");\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY_HEIGHT = 0.3;\n\nconst TYPE_CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        TYPE: \"cf.cplace.solution.safe.capabilityType\",\n        FEATURES: \"cf.cplace.solution.safe.feature\",\n        PROGRAM: \"cf.cplace.solution.safe.program\",\n        SOLUTION: \"cf.cplace.solution.safe.solution.reference\",\n        PROGRAM_INCREMENT: \"cf.cplace.solution.safe.programIncrement\",\n        EPIC: \"cf.cplace.solution.safe.portfolioEpic\",\n        TEMP_ITERATIONS: \"cf.cplace.solution.safe.iteration\",\n    },\n    ENUM: {\n        TYPE: {\n            CAPABILITY: \"capability\",\n            ENABLER: \"enabler\",\n        },\n    },\n});\n\nconst TYPE_MILESTONE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.safeMilestone\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        DATE: \"cf.cplace.solution.safe.date\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        RELEVANT_FOR: \"cf.cplace.solution.safe.relevantFor\", // refers to Program\n    },\n    ENUM: {\n        TYPE: {\n            PI_MILESTONE: \"#15 - PI Meilenstein\",\n            FIXED_DATE: \"#25 - Fixiertes Datum\",\n            LEARNING_MILESTONE: \"#35 - Learning Meilenstein\",\n        },\n    },\n});\n\nconst TYPE_DEPENDENCY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.dependency\",\n    ATTR: {\n        A: \"cf.cplace.solution.safe.successor\",\n        B: \"cf.cplace.solution.safe.predecessor\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        STATUS: \"cf.cplace.solution.safe.status\",\n        DESCRIPTION: \"cf.cplace.solution.safe.description\",\n    },\n    ENUM: {\n        TYPE: {\n            RELATED_TO: \"related to\",\n            BLOCKED_BY: \"blocked by\",\n        },\n        STATUS: {\n            IDENTIFIED: \"15 - identified\",\n            CONFLICT: \"25 - conflict\",\n            RESOLVED: \"35 - resolved\",\n        },\n    },\n});\n\nconst TYPE_PROGRAM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        START: \"cf.cplace.solution.safe.startDate\",\n        END: \"cf.cplace.solution.safe.endDate\",\n        PREDECESSOR: \"cf.cplace.solution.safe.predecessor\", // Program Increment\n    },\n});\n\nconst COLORS = {\n    INACTIVE: \"#88bbee\",\n    ACTIVE: \"#4488aa\",\n    DEPEND: \"#888888\",\n    DEPEND_HIGHLIGHT: \"#A21622\",\n    DEPEND_RESOLVED: \"#19ad48\",\n    SAFE_MILESTONE: \"#3D8F8C\",\n    RELEASE: \"#366C81\",\n    MILESTONE_PLOTBAND: \"#E2F3F2\",\n    RELEASE_PLOTBAND: \"#E2EEF3\",\n    CAPABILITY: \"#0aa5ff\",\n    ENABLER: \"#ffc80c\",\n    TODAY_PLOTLINE: \"lightgrey\",\n};\n\nconst CATEGORY = {\n    SAFE_MILESTONE: \"SAFe Milestones\",\n};\n\nconst ROW_SIZE = {\n    PERIOD: 2,\n    ITEM: 1,\n};\n\nconst HEIGHTS = {\n    HEADER: 40,\n    ITEM: 25,\n};\n\nconst MAX_DATA_LABEL_LENGTH = 25;\nconst DATA_LABEL_PADDING = 0.05;\n\nconst SEPARATOR = {\n    V: \" //VSEP// \",\n    H: \" --HSEP-- \",\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n/*\n*****************\nThis highchart is based on a heatmap, i.e. the chart is divided into a set of X * Y equally sized cells.\n* The first column(s) of the cells are used to show the vertical categories (categoriesVertical), which are provided as separate \"category\" series\n* The first row(s) of the cells are used to show the horizontal categories (categoriesHorizontal), which are provided as separate \"category\" series\n* The rest of the cells represent the data itself\n    * each cell can be identified by its set of vertical and horizontal categories saved as 'key' in the 'keys'-array in the form of a string like \"X Cat Level 1 - X Cat Level 2 / Y Cat Level 1 - Y Cat Level 2 - Y Cat Level 3\" (in theory the levels can be \"dynamic\", which is not used in this specific example. In this example only 1 level is used)\n    * for each cell the number of entities to be shown is counted as 'value' in the 'values'-array.\n    * the entities for each cell are represented as boxes/cards within the cell and are pushed as separate serie to the main data series\n    * dependencies between entities are represented as separate spline series, whereas start and end point of the splines are the left or right edge of the corresponding entity boxes/cards on the map\n\n/***** config options *****/\n\nfunction main() {\n    const ctx = fetchData(Array.from(pages));\n\n    if (ctx.capabilities.length === 0 || ctx.periods.length === 0) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n\n    generateMatrix(ctx);\n\n    const chart = generateChartConfig(ctx);\n\n    return chart;\n}\n// @ts-ignore\nreturn main();\n//--------------------------------------------------------------------------------------//\n//                                    Data Fetching                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Fetches all required data\n * @param {Page[]} searchResults\n * @returns {Context}\n */\nfunction fetchData(searchResults) {\n    const capabilities = searchResults.filter((page) => page.getBuiltinFeatureValue(\"customType\") === TYPE_CAPABILITY.TYPE);\n    const missinCapabilities = getMissingCapabilities(capabilities);\n    capabilities.push(...missinCapabilities);\n    log(`Added ${missinCapabilities.length} missing items that the input items depend on.`);\n\n    const periods = getAllPeriods(capabilities);\n    log(\"Periods: \" + periods.length);\n\n    const programs = getPrograms(capabilities);\n    const milestones = getSafeMilestones(periods);\n    const dependencies = getDependencies(capabilities);\n\n    const capabilitiesById = capabilities.reduce((acc, capability) => {\n        acc[capability.getId()] = { x: 0, y: 0, capability };\n        return acc;\n    }, {});\n\n    const ctx = {\n        matrixData: undefined,\n        capabilities,\n        capabilitiesById,\n        periods,\n        programs,\n        milestones,\n        dependencies,\n        maxHeight: 1,\n    };\n    return ctx;\n}\n\n/**\n * Searches dependencies of the capabilities and returns those capabilities that are not yet included\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @return {Page<'cf.cplace.solution.safe.capability'>[]}\n */\nfunction getMissingCapabilities(capabilities) {\n    // @ts-ignore\n    const newCapabilities = new HashSet();\n    capabilities.forEach((item) => {\n        // @ts-ignore\n        const dependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n        dependencies.forEach((itemDependency) => {\n            const capability = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n            if (isPageOfType(capability, TYPE_CAPABILITY.TYPE)) {\n                newCapabilities.add(capability);\n            }\n        });\n    });\n    return Array.from(newCapabilities).filter((a) => !capabilities.some((b) => b.getId() === a.getId()));\n}\n\n/**\n * Determines the periods used as columns of the board\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities Capabilities\n * @returns {Page<'cf.cplace.solution.safe.programIncrement'>[]} PIs in chronological order\n */\nfunction getAllPeriods(capabilities) {\n    // @ts-ignore\n    const periodsSet = new HashSet();\n    capabilities.forEach((item) => {\n        const pi = item.get(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT);\n        if (!pi) {\n            return;\n        }\n        periodsSet.add(pi);\n    });\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>[]} */\n    const periods = Array.from(periodsSet);\n    return periods.sort((a, b) =>\n        // @ts-ignore\n        a.get(TYPE_PROGRAM_INCREMENT.ATTR.START).isBefore(b.get(TYPE_PROGRAM_INCREMENT.ATTR.START)) ? -1 : 1\n    );\n}\n/**\n * Gets all dependencies of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities Capabilities\n * @returns {Page<'cf.cplace.solution.safe.dependency'>[]} PIs in chronological order\n */\nfunction getDependencies(capabilities) {\n    const dependencies = [];\n    capabilities.forEach((capabilitiy) => {\n        const itemDependencies = Array.from(\n            // @ts-ignore\n            capabilitiy.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []\n        );\n        dependencies.push(...itemDependencies);\n    });\n    return dependencies;\n}\n/**\n *\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>[]} programmIncrements\n * @returns\n */\nfunction getSafeMilestones(programmIncrements) {\n    const periodStartDate =\n        // @ts-ignore\n        programmIncrements.length > 0 ? programmIncrements[0].get(TYPE_PROGRAM_INCREMENT.ATTR.START) : new DateTime();\n    const periodEndDate =\n        programmIncrements.length > 0\n            ? programmIncrements[programmIncrements.length - 1].get(TYPE_PROGRAM_INCREMENT.ATTR.END)\n            : // @ts-ignore\n              new DateTime();\n    const safeMilestoneSearch = new Search();\n    safeMilestoneSearch.add(Filters.embeddingSpace());\n    safeMilestoneSearch.add(Filters.type(TYPE_MILESTONE.TYPE));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).gte(periodStartDate));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).lte(periodEndDate));\n    safeMilestoneSearch.addBuiltinAttributeSort(TYPE_MILESTONE.ATTR.DATE, true);\n    const safeMilestones = safeMilestoneSearch.findAllPages();\n    // @ts-ignore\n    return Array.from(safeMilestones);\n}\n/**\n * Get all the programs of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @returns {Page<'cf.cplace.solution.safe.program'>[]}\n */\nfunction getPrograms(capabilities) {\n    // @ts-ignore\n    const programSet = new HashSet();\n    capabilities.forEach((item) => {\n        const programs = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n        if (!programs) {\n            return;\n        }\n        cplace.each(programs, (program) => programSet.add(program));\n    });\n    /** @type {Page<'cf.cplace.solution.safe.program'>[]} */\n    const programms = Array.from(programSet)\n    return programms.sort((a,b) => a.getName().localeCompare(b.getName()));\n}\n\n/**\n * Generate the matrix\n * @param {Context} ctx\n */\nfunction generateMatrix(ctx) {\n    /** @type {MatrixData} */\n    const matrixData = {\n        headerRow: ctx.periods.map((pi, index) => ({ programIncrement: pi, x: index + 2, y: 1 })),\n        milestoneRow: ctx.milestones,\n        programms: {},\n        capabilities: {},\n    };\n    let yOffset = 3;\n    ctx.programs.forEach((program) => {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n\n        const capabilitiesByPi = ctx.periods.map((programIncrement, indexPI) => {\n            const filteredCapabilities = ctx.capabilities.filter((capability) => {\n                const programIds = capability.get(TYPE_CAPABILITY.ATTR.PROGRAM)?.map((p) => p.getId()) || [];\n                // Get all capabilities that are associated to the current programm & the current program increment\n                return programIds.includes(program.getId()) && capability.getOptional(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT).getId() === programIncrement.getId();\n            });\n            // Check if the number of capabilities for this PI is the largest\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        // Iterate over the programm Increments to put the capabilities in the right place\n        matrixData.programms[program.getName()] = {\n            program,\n            data: capabilitiesByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: program.getId(),\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: program.getId(),\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight; //+ (rowHeight - 1) / 2;\n    });\n\n    const capabilitiesWithoutProgram = ctx.capabilities.filter(\n        (capability) =>\n            // @ts-ignore\n            !capability.get(TYPE_CAPABILITY.ATTR.PROGRAM) || capability.get(TYPE_CAPABILITY.ATTR.PROGRAM).length === 0\n    );\n\n    // Check if there are any capabilities without a programm and add them to the matrix\n    if (capabilitiesWithoutProgram.length > 0) {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n        // Ad capabilities without a program\n        const capabilitiesWithoutProgrammByPi = ctx.periods.map((programIncrement) => {\n            const filteredCapabilities = capabilitiesWithoutProgram.filter(\n                (capability) => capability.getOptional(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT).getId() === programIncrement.getId()\n            );\n\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        matrixData.programms[\"w/o Program\"] = {\n            program: null,\n            data: capabilitiesWithoutProgrammByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesWithoutProgrammByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: \"w/o Program\",\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: \"w/o Program\",\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight;\n    }\n    ctx.maxHeight = yOffset;\n    ctx.matrixData = matrixData;\n}\n/**\n *\n * @param {Context} ctx\n */\nfunction transformMatrixDataIntoSeries(ctx) {\n    const matrixData = ctx.matrixData;\n\n    const series = [];\n\n    if (!matrixData) {\n        return series;\n    }\n\n    // 1. Add PIs\n    series.push(\n        ...matrixData.headerRow.map((headerEntry, index) => {\n            return {\n                name: headerEntry.programIncrement.getName(),\n                colsize: 1,\n                rowsize: 1,\n                dataLabels: { rotation: 0, color: \"#000000\" },\n                enableMouseTracking: false,\n                data: [\n                    {\n                        x: headerEntry.x,\n                        y: headerEntry.y,\n                        value: 1,\n                        name: `<a href=\"${headerEntry.programIncrement.getUrl()}\">${headerEntry.programIncrement.getName()}</a>`,\n                        color: \"#dddddd\",\n                    },\n                ],\n            };\n        })\n    );\n\n    // 2. Add Milestones\n    series.push({\n        name: \"SAFe Milestones\",\n        colsize: 1,\n        rowsize: 1,\n        dataLabels: { rotation: 0, color: \"#000000\" },\n        enableMouseTracking: false,\n        data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n    });\n\n    let top = true;\n    const safeMilestoneData = [];\n\n    matrixData.milestoneRow.forEach((safeMilestone) => {\n        const safeMilestoneName = safeMilestone.getName();\n        const safeMilestoneDate = safeMilestone.get(TYPE_MILESTONE.ATTR.DATE);\n        // @ts-ignore\n        const safeMilestoneDateString = safeMilestoneDate?.toString(\"dd.MM.yyyy\");\n        // get milestone Position\n        // @ts-ignore\n        const safeMilestonePosition = getDatePosition(safeMilestoneDate.getMillis(), ctx);\n        // add milestone only if position is not null\n        if (safeMilestonePosition > 0) {\n            safeMilestoneData.push({\n                x: safeMilestonePosition,\n                y: 2,\n                name: '<a href=\"' + safeMilestone.getUrl() + '\">' + safeMilestoneName + \"</a>\",\n                value: safeMilestoneDateString,\n                dataLabels: {\n                    verticalAlign: top ? \"top\" : \"bottom\",\n                },\n            });\n            top = !top;\n        }\n    });\n\n    series.push({\n        type: \"scatter\",\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        data: safeMilestoneData,\n        marker: {\n            fillColor: COLORS.SAFE_MILESTONE,\n        },\n    });\n\n    // 3. Add Programms\n    let rowHeight = 2.5;\n    Object.keys(matrixData.programms).forEach((programName) => {\n        const data = matrixData.programms[programName];\n        // Add the Programms\n        series.push({\n            name: programName,\n            rowsize: data.rowHeight,\n            dataLabels: { rotation: 0, color: \"#000000\" },\n            enableMouseTracking: false,\n            data: [\n                {\n                    x: data.x,\n                    y: data.y,\n                    value: 1,\n                    name: `<a href=\\\"${data.program?.getUrl() || \"wip\"}\\\">${programName}</a>`,\n                    color: \"#dddddd\",\n                },\n            ],\n        });\n        // Add the capabilities of the programm\n        data.data.map((capabilitiesByPI, indexPI) => {\n            series.push({\n                name: programName + indexPI,\n                rowsize: CAPABILITY_HEIGHT,\n                colsize: 0.8,\n                dataLabels: { rotation: 0, color: \"#000000\", overflow: \"justify\" },\n                enableMouseTracking: false,\n                data: capabilitiesByPI.map((capabilityId, indexCapability) => {\n                    const capabilityData = matrixData.capabilities[capabilityId].filter((c) => c.programId === (data.program ? data.program.getId() : \"w/o Program\"))[0];\n                    const capability = capabilityData.capability;\n                    const isEnabler = capability.get(TYPE_CAPABILITY.ATTR.TYPE) === \"enabler\";\n                    return {\n                        x: capabilityData.x,\n                        y: capabilityData.y,\n                        value: 1,\n                        name: `<a href=\\\"${capability.getUrl() || \"wip\"}\\\">${limitStringSize(capability.getName(), 40)}</a>`,\n                        color: isEnabler ? \"#ffc80c\" : \"#0aa5ff\",\n                    };\n                }),\n            });\n        });\n        rowHeight += data.rowHeight;\n    });\n\n    // 4. Add Dependencies\n    ctx.dependencies.forEach((dependency) => {\n        const from = dependency.get(TYPE_DEPENDENCY.ATTR.B);\n        const to = dependency.get(TYPE_DEPENDENCY.ATTR.A);\n        if (!from || !to) {\n            return;\n        }\n        const fromId = from.getId();\n        const toId = to.getId();\n\n        const fromCapabilities = ctx.matrixData?.capabilities[fromId];\n        const toCapabilities = ctx.matrixData?.capabilities[toId];\n\n        if (!fromCapabilities) {\n            return;\n        }\n        const maxValue = ctx.maxHeight;\n        fromCapabilities.forEach((fromCapabilityData) => {\n            let x1 = fromCapabilityData.x;\n            let y1 = fromCapabilityData.y;\n            // y1 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n            if (!toCapabilities) {\n                return;\n            }\n            toCapabilities.forEach((toCapabilityData) => {\n                let x2 = toCapabilityData.x;\n                let y2 = toCapabilityData.y;\n                // y2 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n                const description = dependency.get(TYPE_DEPENDENCY.ATTR.DESCRIPTION) || \" \";\n                const dependencyType = dependency.get(TYPE_DEPENDENCY.ATTR.TYPE);\n                const status = dependency.get(TYPE_DEPENDENCY.ATTR.STATUS);\n                const dependencySeries = {\n                    type: \"spline\",\n                    name: \"<b>\" + to.getName() + \"</b><br/>relates to:<br/>\" + from.getName() + \"<br>\" + description,\n                    lineWidth: 1.5,\n                    color: COLORS.DEPEND,\n                    dashStyle: \"shortdot\",\n                    findNearestPointBy: \"xy\",\n                    data: [\n                        { x: x1 + 0.4, y: y1 },\n                        { x: x1 + 0.45, y: y1 === y2 ? y1 + 0.02 : y1 },\n                        { x: x2 - 0.45, y: y1 === y2 ? y2 - 0.02 : y2 },\n                        { x: x2 - 0.4, y: y2, marker: { enabled: true, symbol: \"diamond\" } },\n                    ],\n                };\n                if (dependencyType === TYPE_DEPENDENCY.ENUM.TYPE.BLOCKED_BY) {\n                    dependencySeries.name = \"<b>\" + to.getName() + \"</b><br/>blocked by:<br/>\" + from.getName() + \"<br>\" + description;\n                    // @ts-ignore\n                    dependencySeries.dashStyle = null;\n                }\n                if (status === TYPE_DEPENDENCY.ENUM.STATUS.CONFLICT) {\n                    dependencySeries.color = COLORS.DEPEND_HIGHLIGHT;\n                } else if (status === TYPE_DEPENDENCY.ENUM.STATUS.RESOLVED) {\n                    dependencySeries.color = COLORS.DEPEND_RESOLVED;\n                }\n                series.push(dependencySeries);\n            });\n        });\n    });\n\n    return series;\n}\n\n//--------------------------------------------------------------------------------------//\n//                                     Chart Config                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n *\n * @param {Context} ctx\n */\nfunction generateChartConfig(ctx) {\n    if (!ctx.matrixData) {\n        return;\n    }\n    const series = transformMatrixDataIntoSeries(ctx);\n    // @ts-ignore\n    const today = new DateTime();\n    let todayPosition = getDatePosition(today.getMillis(), ctx);\n\n    return {\n        chart: {\n            type: \"heatmap\",\n            marginTop: 0,\n            marginBottom: 0,\n            plotBorderWidth: 0,\n            scrollablePlotArea: {\n                minHeight: 1200,\n                minWidth: 2200,\n            },\n        },\n        title: {\n            text: null,\n        },\n        xAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 0,\n            lineWidth: 0,\n            labels: {\n                enabled: false,\n            },\n            plotLines: [\n                {\n                    dashStyle: \"dash\",\n                    color: COLORS.TODAY_PLOTLINE,\n                    width: 2,\n                    value: todayPosition,\n                    zIndex: 1,\n                },\n            ],\n        },\n        yAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 1,\n            tickInterval: 1,\n            lineWidth: 0,\n            min: 1,\n            max: ctx.maxHeight,\n            labels: {\n                enabled: false,\n            },\n            reversed: true,\n            scrollbar: {\n                enabled: true,\n            },\n            plotBands: [\n                {\n                    color: COLORS.MILESTONE_PLOTBAND,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    from: 1.5,\n                    to: 2.5,\n                    zIndex: 0,\n                },\n                // {\n                //     color: COLORS.RELEASE_PLOTBAND,\n                //     borderColor: 'white',\n                //     borderWidth: 2,\n                //     from: 1.5,\n                //     to: 2.5,\n                //     zIndex: 0\n                // }\n            ],\n        },\n        colors: [\"#D5001C\", \"#92D050\"],\n        colorAxis: {\n            dataClassColor: \"category\",\n            dataClasses: [\n                {\n                    to: 0.5,\n                },\n                {\n                    from: 0.5,\n                },\n            ],\n        },\n        legend: {\n            enabled: false,\n        },\n        tooltip: {\n            useHTML: true,\n            followPointer: false,\n        },\n        plotOptions: {\n            series: {\n                borderColor: \"#ffffff\",\n                borderWidth: 2,\n                dataLabels: {\n                    allowOverlap: false,\n                    inside: true,\n                    crop: true,\n                    overflow: \"justify\",\n                    position: \"left\",\n                    shape: \"circle\",\n                    enabled: true,\n                    color: \"#000000\",\n                    format: \"{point.name}\",\n                    style: {\n                        textOutline: \"none\",\n                        textOverflow: \"clip\",\n                    },\n                },\n                stickyTracking: false,\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b>\",\n                    findNearestPointBy: \"xy\",\n                },\n                states: {\n                    inactive: {\n                        opacity: 1,\n                    },\n                },\n            },\n            spline: {\n                tooltip: {\n                    headerFormat: \"{series.name}\",\n                    pointFormat: \"\",\n                    findNearestPointBy: \"xy\",\n                },\n                marker: {\n                    enabled: false,\n                    fillColor: COLORS.DEPEND,\n                    radius: 6,\n                    states: {\n                        hover: {\n                            enabled: false,\n                        },\n                    },\n                },\n            },\n            scatter: {\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b><br>{point.value}\",\n                    findNearestPointBy: \"xy\",\n                },\n                dataLabels: {\n                    enabled: true,\n                },\n                marker: {\n                    enabled: true,\n                    symbol: \"diamond\",\n                    radius: 10,\n                    states: {\n                        hover: {\n                            enabled: true,\n                        },\n                    },\n                },\n            },\n        },\n        series: series,\n        // series: [\n        //     {\n        //         name: \"PI 22.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 2,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/1bk9kpxn7s36vz3w80ji7t5oo/PI-22.4\">PI 22.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 3,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4l6jbaa8qgzinif5qetj499g5/PI-23.1\">PI 23.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.2\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 4,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/tksr708c2119mek2pzzopu9qb/PI-23.2\">PI 23.2</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.3\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 5,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/i4o8azmi8m0oqvqqu3hejgu80/PI-23.3\">PI 23.3</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 6,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/nrymz33xo7ew3x6qcgdk3fl7l/PI-23.4\">PI 23.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 24.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 7,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/0wtzrg3m4bdpfhut5xbgiza73/PI-24.1\">PI 24.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"SAFe Milestones\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n        //     },\n        //     {\n        //         name: \"Smart Infotainment\",\n        //         rowsize: 2,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 3.5,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/qg000odouviwwtx4rz2bvaoi8/Smart-Infotainment\">Smart Infotainment</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"Powertrain and Safety\",\n        //         rowsize: 4,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 5 + (4-1)/2,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4flf7a0349c5ximei6olrhife/Powertrain-and-Safety\">Powertrain and Safety</a>',\n        //                 color: \"red\",\n        //             },\n        //         ],\n        //     },\n        // ],\n    };\n}\n\n//--------------------------------------------------------------------------------------//\n//                                        Utils                                         //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Limit string to specified size\n * @param {string} str\n * @param {number} maxSize\n * @returns\n */\nfunction limitStringSize(str, maxSize) {\n    if (str.length > maxSize) {\n        return str.substring(0, maxSize - 3) + \"...\";\n    }\n    return str;\n}\n\n/**\n *\n * @param {number} date\n * @param {Context} ctx\n * @returns\n */\nfunction getDatePosition(date, ctx) {\n    let xPosition = 0;\n    ctx.periods.every((pi, idx) => {\n        // @ts-ignore\n        let categoryStartDate = pi.get(TYPE_PROGRAM_INCREMENT.ATTR.START)?.getMillis();\n        // @ts-ignore\n        let categoryEndDate = pi.get(TYPE_PROGRAM_INCREMENT.ATTR.END)?.getMillis();\n\n        // Check whether release date lies in between start and end date of category\n        if (categoryStartDate && categoryEndDate && date >= categoryStartDate && date <= categoryEndDate) {\n            // find x-Value of category and subtract 0.5 for starting point as offset\n            let x = idx + 2 - 0.5;\n            // calculate the relative position of date between Category StartDate and EndDate and add it to the offset value\n            xPosition = x + (date - categoryStartDate) / (categoryEndDate - categoryStartDate);\n            // exit the every loop\n            return false;\n        }\n        // continue the every loop\n        return true;\n    });\n    // if there was no match, just return null\n    return xPosition;\n}\n\n/**\n * Checks if a cplace page is of the specified type\n * @param {Page} page\n * @param {string} type\n * @returns {boolean}\n */\nfunction isPageOfType(page, type) {\n    return page.getBuiltinFeatureValue(\"customType\") === type;\n}\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    const logOutput = typeof text !== \"string\" ? JSON.stringify(text) : text;\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Set to false to suspend logging\n * @type {Boolean}\n */\n const DEBUG = true;\n\n /**\n  * Get millisecond starting time of the script\n  * @type {Number}\n  */\n const START_TIME = new Date().getTime()\n \n /** @type {Number} */\n let LAST_TIME = START_TIME;\n \n /**\n  * Hint: set a declarative name for all of your logs\n  */\n cplace.setLogName('Roadmap: Solution Roadmap');\n \n //--------------------------------------------------------------------------------------//\n //                                       CONFIGURATION                                  //\n //--------------------------------------------------------------------------------------//\n \n const CUSTOM_SETTINGS = {\n   UNDEFINED_GROUP_TITLE: 'No Portfolio Epics defined', // if the ROADMAP_STRUCTURE.BASEITEM.GROUP value is changed, adjust this title\n   UNDEFINED_SWIMLANE_TITLE: '',\n   UNDEFINED_SUBSWIMLANE_TITLE: ''\n }\n const ROADMAP_STRUCTURE = {\n   CONFIGURATION: {\n     TYPE: 'de.visualistik.visualRoadmap.visualRoadmapConfiguration',\n     TYPE_MAP: 'de.visualistik.visualRoadmap.configurationTypeMap',\n     ITEM_TYPE: 'de.visualistik.visualRoadmap.itemType',\n     DISPLAYED_VALUE: 'de.visualistik.visualRoadmap.displayedValue',\n     ATTRIBUTE: 'de.visualistik.visualRoadmap.propertyKey',\n     PROPERTY_KEY_VALUES: 'de.visualistik.visualRoadmap.propertyKeyValues'\n   },\n   BASEITEM: {\n     TYPE: 'cf.cplace.solution.safe.capability',\n     GROUP: 'cf.cplace.solution.safe.portfolioEpic',\n     LABEL_PREFIX: 'cf.cplace.solution.safe.progressOfFeatures',\n     LABEL: 'cf.cplace.solution.safe.title', // not used\n     SWIMLANE: 'cf.cplace.solution.safe.solution.reference',\n \n     START_DATE: 'cf.cplace.solution.safe.plannedStart',\n     END_DATE: 'cf.cplace.solution.safe.plannedEnd',\n \n     STATE: 'cf.cplace.solution.safe.state',\n \n     // state values\n     IMPLEMENTING: '#45 - Implementing',\n     FUNNEL: '#15 - Funnel',\n     \n   },\n   SUBITEM: {\n     TYPE: 'cf.cplace.solution.safe.feature',\n     SWIMLANE: 'cf.cplace.solution.safe.program',\n     LABEL: 'cf.cplace.solution.roadmap.title',\n     PART_OF: 'cf.cplace.solution.safe.capability',\n     START_DATE: 'cf.cplace.solution.safe.plannedStart',\n     END_DATE: 'cf.cplace.solution.safe.plannedEnd',\n \n     //STATE: 'cf.cplace.solution.roadmap.workflow',\n   },\n   QUALITY_LINES: {\n     TYPE: 'cf.cplace.solution.safe.safeMilestone',\n     DATE: 'cf.cplace.solution.safe.date',\n     IS_ROADMAP_RELEVANT : 'cf.cplace.solution.safe.isRoadmapRelevant'\n   }\n }\n \n //--------------------------------------------------------------------------------------//\n //                                       INITIALIZATION                                  //\n //--------------------------------------------------------------------------------------//\n \n const enableLinks = true; // enable links on items and subitems\n const branding = true; // display branding visualistik\n const allGroupsOpen = true; // true if all groups are open on default\n \n /**\n  * @type {import(\"../templates/data-model\").Configuration}\n  */\n let config = null;\n \n /**\n  * @type {Object}\n  */\n let groups = {}\n \n /** @type {import(\"../templates/data-model\").QualityLine[]} */\n let qualityLines = null;\n \n //--------------------------------------------------------------------------------------//\n //                                       OUTPUT                                         //\n //--------------------------------------------------------------------------------------//\n \n cplace.each(pages, function (page) {\n   if (page.getBuiltinFeatureValue('customType') !== ROADMAP_STRUCTURE.BASEITEM.TYPE || page.get(ROADMAP_STRUCTURE.BASEITEM.START_DATE) == null || page.get(ROADMAP_STRUCTURE.BASEITEM.END_DATE) == null) {\n     return;\n   }\n \n   if (config === null) {\n     config = loadConfiguration(enableLinks, branding, page);\n   }\n \n   if (qualityLines === null) {\n     qualityLines = createQualityLines(page);\n   }\n \n   let groupPages = preparePages(page, ROADMAP_STRUCTURE.BASEITEM.GROUP);\n   \n   cplace.each(groupPages, function(groupPage) {\n     cplace.log('groupPages'+groupPage)\n     let group = null;\n     let groupName = CUSTOM_SETTINGS.UNDEFINED_GROUP_TITLE;\n     let groupId = CUSTOM_SETTINGS.UNDEFINED_GROUP_TITLE;\n \n     if (groupPage != null) {\n       groupName = groupPage.getName();\n       groupId = groupPage.getId();\n     }\n \n     if (groups.hasOwnProperty(groupId)) {\n       group = groups[groupId]\n     } else {\n       group = {\n         name: groupName,\n         id: groupId,\n         swimlanes: [],\n         swimlaneObject: {}\n       }\n       if (allGroupsOpen) {\n         config.groupsOpen.push(groupId);\n       }\n \n       groups[groupId] = group;\n     }\n \n     let swimlanePages = preparePages(page, ROADMAP_STRUCTURE.BASEITEM.SWIMLANE);\n     cplace.log('swimlanePages'+swimlanePages)\n \n     cplace.each(swimlanePages, function (swimlanePage) {\n       cplace.log('swimlanePage'+swimlanePage)\n       let swimlane = null;\n       let swimlaneId = CUSTOM_SETTINGS.UNDEFINED_SWIMLANE_TITLE;\n       let swimlaneName = CUSTOM_SETTINGS.UNDEFINED_SWIMLANE_TITLE;\n \n       if (swimlanePage != null) { // using !== null does not work for some reason.\n         swimlaneId = swimlanePage.getId();\n         swimlaneName = swimlanePage.getName();\n       }\n \n       if (group.swimlaneObject.hasOwnProperty(swimlaneId)) {\n         swimlane = group.swimlaneObject[swimlaneId]\n       } else {\n         swimlane = {\n           name: '', //swimlaneName,\n           baseItemElements: []\n         }\n         group.swimlaneObject[swimlaneId] = swimlane;\n       }\n \n       let baseItem = baseItemElement(page);\n       if (baseItem === null) {\n         return;\n       }\n \n       let subItemPages = page.getIncomingPagesFromAllSpaces(ROADMAP_STRUCTURE.SUBITEM.TYPE, ROADMAP_STRUCTURE.SUBITEM.PART_OF);\n       cplace.log('subItemPages'+subItemPages);\n       cplace.log('pageName'+page.getName());\n       let features = page.get('cf.cplace.solution.safe.features');\n       cplace.log('features'+features)\n       buildSubItems(baseItem, subItemPages);\n \n       swimlane.baseItemElements.push(baseItem);\n     });\n   })\n \n });\n \n return roadmap(config, qualityLines, groups);\n \n //--------------------------------------------------------------------------------------//\n //                                       BUSINESS FUNCTIONS                             //\n //--------------------------------------------------------------------------------------//\n \n /**\n  * prepare pages for swimlane creation\n  * @param {Page} page\n  * @param {Attribute} attribute\n  * @returns {Page[]}\n  */\n function preparePages(page, attribute) {\n   let result = [];\n   let value = page.get(attribute, false);\n \n   if (value == null || value.length === 0) {\n     return [null];\n   }\n \n   const className = typeof value === 'object' ? String(value.getClass()) : 'String'\n   switch (className) {\n     case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPage':\n     case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPerson':\n       result.push(page.get(attribute));\n       break;\n     case 'class com.google.common.collect.SingletonImmutableList':\n     case 'class com.google.common.collect.RegularImmutableList':\n       result = page.get(attribute);\n       break;\n     default:\n       cplace.log('Class of ' + value + ' is \"' + value.class + '\"');\n       cplace.log(typeof value.class);\n       cplace.log(typeof value);\n   }\n \n   return result;\n }\n \n /**\n  * create subItems for base items\n  * @param {Object} baseItem\n  * @param {Page[]} subItems\n  */\n function buildSubItems(baseItem, subItems) {\n \n   // iterate through all sub items\n   cplace.each(subItems, function (subItem) {\n     if (subItem === null) {\n       return;\n     }\n \n     /**\n      * Show only certain sub items\n      */\n     /*if ([ROADMAP_STRUCTURE.BASEITEM.PLANNED,ROADMAP_STRUCTURE.BASEITEM.DEVELOPMENT,ROADMAP_STRUCTURE.BASEITEM.LAUNCHED].indexOf(subItem.get(ROADMAP_STRUCTURE.SUBITEM.STATE)) === -1) {\n       return;\n     }*/\n \n     let subSwimlane = null;\n     let subItemCategory = null;\n     let subItemCategoryName = CUSTOM_SETTINGS.UNDEFINED_SUBSWIMLANE_TITLE;\n     let subItemCategoryId = CUSTOM_SETTINGS.UNDEFINED_SUBSWIMLANE_TITLE;\n     \n     // get swimlane of subitem\n     subItemCategory = subItem.get(ROADMAP_STRUCTURE.SUBITEM.SWIMLANE);\n     // if not null save id. If null, a fallback subSwimlane should be used\n     if (subItemCategory) {\n       subItemCategoryId = subItemCategory.getId();\n       subItemCategoryName = subItemCategory.getName();\n     }\n \n     if (baseItem.subSwimlaneObject.hasOwnProperty(subItemCategoryId)) {\n       // if the subSwimlane for subItem exist get this subSwimlane\n       subSwimlane = baseItem.subSwimlaneObject[subItemCategoryId];\n     } else {\n       // if there is no subSwimlane -> create the subSwimlane\n       subSwimlane = {\n         name: subItemCategoryName,\n         subItemElements: []\n       }\n       baseItem.subSwimlaneObject[subItemCategoryId] = subSwimlane;\n     }\n     // create the subItem object and push to subSwimlane\n     let createdSubItem = subItemElement(subItem);\n \n     if (createdSubItem === null) {\n       return;\n     }\n \n     subSwimlane.subItemElements.push(createdSubItem);\n   });\n }\n \n /**\n  * create roadmap output\n  * @param {import(\"../templates/data-model\").Configuration} config\n  * @param {import(\"../templates/data-model\").QualityLine[]} qualityLines\n  * @param {Object} groups\n  * @returns\n  */\n function roadmap(config, qualityLines, groups) {\n   let groupArray = [];\n   for (let key in groups) {\n     for (let keys in groups[key].swimlaneObject) {\n \n       cplace.each(groups[key].swimlaneObject[keys].baseItemElements, function (baseItemElement) {\n         for (let subSwimlaneKey in baseItemElement.subSwimlaneObject) {\n           let subSwimlane = JSON.stringify(baseItemElement.subSwimlaneObject[subSwimlaneKey]);\n           baseItemElement.subSwimlanes.push(JSON.parse(subSwimlane));\n         }\n       });\n \n       let swimlane = JSON.stringify(groups[key].swimlaneObject[keys]);\n       groups[key].swimlanes.push(JSON.parse(swimlane));\n     }\n     groupArray.push(groups[key])\n   }\n   return {\n     configuration: config,\n     qualityLines: qualityLines,\n     groups: groupArray\n   }\n }\n \n /**\n  * create baseItemElement\n  * @param {Page} page\n  */\n function baseItemElement(page) {\n   if (page === null) {\n     return null;\n   }\n \n   let startDate = null;\n   let endDate = null;\n \n   startDate = page.get(ROADMAP_STRUCTURE.BASEITEM.START_DATE);\n   endDate = page.get(ROADMAP_STRUCTURE.BASEITEM.END_DATE);\n \n   // if start or end date not set -> nothing to do\n   if (startDate === null || endDate === null) {\n     return null;\n   }\n \n   const labelPrefix = page.get(ROADMAP_STRUCTURE.BASEITEM.LABEL_PREFIX);\n   let baseItem = {\n     name:page.getName(),\n     id: page.getId(),\n     url: page.getUrl(),\n     startDate: startDate.toString('MM-dd-yyyy'),\n     endDate: endDate.toString('MM-dd-yyyy'),\n     subSwimlanes: [],\n     subSwimlaneObject: {}\n   }\n \n   if (config !== null) {\n \n     if (config.colorMap !== null && config.colorMap.baseItem !== null && config.colorMap.baseItem.length > 0) {\n       const attribute = config.colorMap.baseItem[0].attribute;\n       // baseItem.color = page.get(attribute).get('cf.cplace.solution.roadmap.color');\n       baseItem.color = page.get(attribute);\n     }\n     if (config.hatchingMap !== null && config.hatchingMap.baseItem !== null && config.hatchingMap.baseItem.length > 0) {\n       const attribute = config.hatchingMap.baseItem[0].attribute;\n       baseItem.hatching = page.get(attribute);\n     }\n \n     if (config.iconMap !== null && config.iconMap.baseItem !== null && config.iconMap.baseItem.length > 0) {\n       const attribute = config.iconMap.baseItem[0].attribute;\n       baseItem.icon = page.get(attribute);\n     }\n   }\n \n   return baseItem;\n }\n \n /**\n  * create subItemElement\n  * @param {Page} page\n  */\n function subItemElement(page) {\n   cplace.log('subItemElement'+page)\n   if (page === null) {\n     return null;\n   }\n \n   let startDate = page.get(ROADMAP_STRUCTURE.SUBITEM.START_DATE);\n   let endDate = page.get(ROADMAP_STRUCTURE.SUBITEM.END_DATE);\n \n   // if start or end date not set -> nothing to do\n   if (startDate === null || endDate === null) {\n     return null;\n   }\n \n   let subItem = {\n     name: page.getName(),\n     id: page.getId(),\n     url: page.getUrl(),\n     startDate: startDate.toString('MM-dd-yyyy'),\n     endDate: endDate.toString('MM-dd-yyyy'),\n   }\n \n   if (config !== null) {\n \n     if (config.colorMap !== null && config.colorMap.subItem !== null && config.colorMap.subItem.length > 0) {\n       const attribute = config.colorMap.subItem[0].attribute;\n       subItem.color = page.get(attribute);\n     }\n     if (config.hatchingMap !== null && config.hatchingMap.subItem !== null && config.hatchingMap.subItem.length > 0) {\n       const attribute = config.hatchingMap.subItem[0].attribute;\n       subItem.hatching = page.get(attribute);\n     }\n     if (config.iconMap !== null && config.iconMap.subItem !== null && config.iconMap.subItem.length > 0) {\n       const attribute = config.iconMap.subItem[0].attribute;\n       subItem.icon = page.get(attribute);\n     }\n   }\n   cplace.log('subItem'+subItem)\n   return subItem;\n }\n \n //--------------------------------------------------------------------------------------//\n //                                       QUALITY LINES.                                 //\n //--------------------------------------------------------------------------------------//\n \n function createQualityLines(page) {\n   let result = [];\n \n   cplace.each(getPages(ROADMAP_STRUCTURE.QUALITY_LINES.TYPE, page), function (event) {\n     let date = event.get(ROADMAP_STRUCTURE.QUALITY_LINES.DATE);\n     let isRoadmapRelevant = true //!!event.get(ROADMAP_STRUCTURE.QUALITY_LINES.IS_ROADMAP_RELEVANT)\n \n     if (date === null || !isRoadmapRelevant) {\n       return;\n     }\n \n     result.push({\n       name: event.getName(),\n       date: date.toString('MM-dd-yyyy')\n     });\n   });\n \n   return result;\n }\n \n //--------------------------------------------------------------------------------------//\n //                                       CONFIGURATION.                                 //\n //--------------------------------------------------------------------------------------//\n \n function loadConfiguration(enableLinks, branding, page) {\n   let result = {\n     hatchingMap: {\n       baseItem: [],\n       subItem: []\n     },\n     colorMap: {\n       baseItem: [],\n       subItem: []\n     },\n     iconMap: {\n       baseItem: [],\n       subItem: []\n     },\n     groupsOpen: [],\n     enableLinks: enableLinks,\n     branding: branding\n   };\n \n   cplace.each(getPages(ROADMAP_STRUCTURE.CONFIGURATION.TYPE, page), function (configurationPage) {\n     let configurationType = configurationPage.get(ROADMAP_STRUCTURE.CONFIGURATION.TYPE_MAP);\n     let itemType = configurationPage.get(ROADMAP_STRUCTURE.CONFIGURATION.ITEM_TYPE);\n     let displayedValue = configurationPage.get(ROADMAP_STRUCTURE.CONFIGURATION.DISPLAYED_VALUE);\n     let attribute = configurationPage.get(ROADMAP_STRUCTURE.CONFIGURATION.ATTRIBUTE);\n     let values = configurationPage.get(ROADMAP_STRUCTURE.CONFIGURATION.PROPERTY_KEY_VALUES);\n \n     result[configurationType][itemType].push({\n       key: displayedValue,\n       value: values,\n       attribute: attribute\n     });\n   });\n \n   return result;\n }\n \n //--------------------------------------------------------------------------------------//\n //                                       HELPER FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n \n function getPages(type, page) {\n   return new Search()\n     .setEmbeddingEntity(page)\n     .add(Filters.embeddingSpace())\n     .add(Filters.type(type))\n     .findAllPages();\n }\n \n /**\n  * Log to cplace\n  * @param {any} text\n  */\n function log(text) {\n   if (!DEBUG) {\n     return\n   }\n   let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n \n   cplace.log(logOutput);\n }\n \n \n function timeSinceStart(msg) {\n   if (!DEBUG) {\n     return\n   }\n   let now = new Date().getTime();\n   cplace.log([(now - START_TIME) + 'ms', (now - LAST_TIME) + 'ms', msg].join(' -- '))\n   LAST_TIME = now;\n }",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#15 - Funnel\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#25 - Analyzing\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#35 - Backlog\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#45 - Implementing\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#55 - Validating\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#65 - Deploying\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#75 - Releasing\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#15 - Funnel\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#25 - Analyzing\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#35 - Backlog\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#45 - Implementing\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#55 - Validating\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#65 - Deploying\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/** @type {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} */\nconst STATE = \"#75 - Releasing\";\n\nconst WIP_MAP = /** @type {const} */ ({\n    \"#15 - Funnel\": \"cf.cplace.solution.safe.funnelWIPLimit\",\n    \"#25 - Analyzing\": \"cf.cplace.solution.safe.analyzingWIPLimit\",\n    \"#35 - Backlog\": \"cf.cplace.solution.safe.backlogWIPLimit\",\n    \"#45 - Implementing\": \"cf.cplace.solution.safe.implementingWIPLimit\",\n    \"#55 - Validating\": \"cf.cplace.solution.safe.validatingWIPLimit\",\n    \"#65 - Deploying\": \"cf.cplace.solution.safe.deployingWIPLimit\",\n    \"#75 - Releasing\": \"cf.cplace.solution.safe.releasingWIPLimit\",\n});\n\nconst SOLUTION = /** @type {const} */({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n});\n\nfunction main() {\n    const solution = getSolution(embeddingPage.getSpaceId());\n    /** @type {number | null} */\n    const wipLimit = solution.get(WIP_MAP[STATE]);\n\n    if (wipLimit === null) {\n        // No WIP limit set\n        return \"-\";\n    }\n\n    const numberOfCapabilities = getNumberOfCapabilitiesInState(solution, STATE);\n\n    return `${numberOfCapabilities.toString(10)}/${wipLimit.toString(10)}`;\n}\n\n/**\n * Get the solution of the embedding workspace\n * @param {string} workspace\n * @returns {Page<'cf.cplace.solution.safe.solution'>}\n */\nfunction getSolution(workspace) {\n    const result = new Search().add(Filters.type(SOLUTION.TYPE)).add(Filters.space(workspace)).findAllPages();\n    return Iterables.getFirst(result, null);\n}\n\n/**\n * Get the number of capabilities of the solution in the provided state\n * @param {Page<'cf.cplace.solution.safe.solution'>} solution\n * @param {CplaceTypes['cf.cplace.solution.safe.capability'][\"cf.cplace.solution.safe.state\"]} state\n */\nfunction getNumberOfCapabilitiesInState(solution, state) {\n    const numberOfCapabilities = new Search()\n        .add(Filters.space(solution.getSpaceId()))\n        .add(Filters.type(CAPABILITY.TYPE))\n        .add(Filters.customAttribute(CAPABILITY.ATTR.STATE).eq(state))\n        .getHitCount();\n    return numberOfCapabilities;\n}\n\n\nreturn main()",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('HC: Prioritization Matrix')\n\n/**\n * Define colors for the chart\n */\n const CHART_LABELS = {\n   XAXIS_TITLE: '<- Cost of Delay ->',\n   YAXIS_TITLE: '<- Job Duration ->'\n }\n const CHART_COLORS = {\n  PLOTLINES: '#b5b5b5',\n  DONT_DO_TEXT: '#EC7E80',\n  DO_NEXT_TEXT: '#3A4454',\n  DO_LATER_TEXT: '#313C4E',\n  DO_NOW_TEXT:  '#7EC587',\n  ENABLER: '#E6D32B',\n  CAPABILITY: '#0CA2D4',\n}\n\nconst CAPABILITY = {\n    TYPE:'cf.cplace.solution.safe.capability',\n    ATTR: {\n      JOB_SIZE: 'cf.cplace.solution.safe.jobSize',\n      BUSINESS_VALUE: 'cf.cplace.solution.safe.businessValue',\n      TIME_CRITICALITY: 'cf.cplace.solution.safe.timeCriticality',\n      RISK_REDUCTION: 'cf.cplace.solution.safe.riskReduction',\n      WSJF: 'cf.cplace.solution.safe.wsjf',\n      STATUS: '',\n      TYPE: 'cf.cplace.solution.safe.capabilityType'\n    },\n    ENUM_STATUS: {\n\n    },\n    ENUM_TYPE: {\n        ENABLER: 'enabler',\n        CAPABILITY: 'capability'\n    }\n  }\n\n/*//find colors for types\nlet typeColorConfigurations = new Search()\n  .add(Filters.type('de.visualistik.visualRoadmap.visualRoadmapConfiguration'))\n  .add(Filters.customAttribute('de.visualistik.visualRoadmap.configurationTypeMap').eq('colorMap'))\n  .add(Filters.customAttribute('de.visualistik.visualRoadmap.propertyKey').eq('cf.cplace.solution.safe.type'))\n  .findAllPages();\n\n  cplace.each(typeColorConfigurations, configuration => {\n    let values = configuration.get('de.visualistik.visualRoadmap.propertyKeyValues');\n    let color = configuration.get('de.visualistik.visualRoadmap.displayedValue');\n    if (values.indexOf('#15 - Enabler') > -1){\n      CHART_COLORS.ENABLER = color\n    }\n    if (values.indexOf('#25 - Epic') > -1){\n      CHART_COLORS.EPIC = color\n    }\n  })*/\n\n  const language = cplace.utils().getCurrentUser().getUserLanguage();\n\n/**\n * create serie and data items\n */\nlet serie = createBubbleSerie()\nlet maxBubbleSize = 0;\n\ncplace.each(pages, function (capability) {\n    let z = capability.get(CAPABILITY.ATTR.WSJF);\n    if (z) {\n        let time = capability.get(CAPABILITY.ATTR.TIME_CRITICALITY);\n        let business = capability.get(CAPABILITY.ATTR.BUSINESS_VALUE);\n        let risk = capability.get(CAPABILITY.ATTR.RISK_REDUCTION);\n        let x = time + business + risk;\n        let jobSize = capability.get(CAPABILITY.ATTR.JOB_SIZE);\n        let y = switchSize(jobSize);\n        let type = capability.get(CAPABILITY.ATTR.TYPE);\n    \n        if (z > maxBubbleSize) {\n            maxBubbleSize = z;\n        }\n        serie.data.push(createDataItem(capability, x, y, z, type));\n    }\n});\n\nserie.data.push(createHiddenDataItem(0, 0, maxBubbleSize));\nserie.data.push(createHiddenDataItem(0, 20, maxBubbleSize));\nserie.data.push(createHiddenDataItem(60, 0, maxBubbleSize));\nserie.data.push(createHiddenDataItem(60, 20, maxBubbleSize));\n\nlet xAxisPlotLines = [];\nlet yAxisPlotLines = [];\n\n// Create quadrant divider\nxAxisPlotLines.push(createQuadrantPlotline(30));\nyAxisPlotLines.push(createQuadrantPlotline(10));\n\n// Create labels for each quadrant\nlet label = createLabelPlotline('DON\\'\\T DO', 0, 'left',  CHART_COLORS.DONT_DO_TEXT, -10, 37);\nyAxisPlotLines.push(label);\nlabel = createLabelPlotline('DO NEXT', 0, 'right',  CHART_COLORS.DO_NEXT_TEXT, 0, 37);\nyAxisPlotLines.push(label);\nlabel = createLabelPlotline('DO LATER', 20, 'left',  CHART_COLORS.DO_LATER_TEXT, -10, -25);\nyAxisPlotLines.push(label);\nlabel = createLabelPlotline('DO NOW', 20, 'right',  CHART_COLORS.DO_NOW_TEXT, 0, -25);\nyAxisPlotLines.push(label);\n\n/**\n * BUILD CHART\n */\nlet config = {\n    chart: {\n        type: 'bubble',\n    },\n\n    legend: {\n        enabled: false\n    },\n\n    title: {\n        text: ''\n    },\n\n    xAxis: {\n        title: {\n            text: CHART_LABELS.XAXIS_TITLE\n        },\n        lineWidth: 0,\n        gridLineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        tickWidth: 0,\n        tickInterval: 5,\n        startOnTick: false,\n        endOnTick: false,\n        showLastLabel: true,\n        plotLines: xAxisPlotLines\n    },\n\n    yAxis: {\n        title: {\n            text: CHART_LABELS.YAXIS_TITLE\n        },\n        lineWidth: 0,\n        gridLineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        tickWidth: 0,\n        tickInterval: 5,\n        startOnTick: false,\n        endOnTick: false,\n        plotLines: yAxisPlotLines\n    },\n\n    tooltip: {\n        useHTML: true,\n        headerFormat: '',\n        pointFormat: '{point.tooltip}',\n        style: {\n            pointerEvents: 'auto'\n        }\n    },\n\n    plotOptions: {\n        bubble: {\n            dataLabels: {\n                enabled: false,\n            },\n            minSize: 1,\n            maxSize: 50\n        }\n    },\n    series: [serie]\n};\n\nreturn config;\n\n/**\n * ================\n * HELPER FUNCTIONS\n * ================\n */\n\nfunction createBubbleSerie() {\n    return {\n        data: [],\n        marker: {\n            fillOpacity: 0.13,\n            lineWidth: 0\n        }\n    };\n}\n\nfunction createDataItem(page, x, y, z, type) {\n    let color = getColor(type);\n    let rgba = hexToRGBA(color, 0.1);\n    return {\n        name: page.getName(),\n        url: page.getUrl(),\n        x: x,\n        y: y,\n        z: z,\n        tooltip: getTooltip(page),\n        color: rgba,\n        marker: {\n            lineColor: color,\n        },\n        dataLabels: {\n            enabled: true,\n            format: '{point.name}',\n            style: {\n                textOutline: false,\n                color: color\n            }\n        }\n    }\n}\n\nfunction getTooltip(page) {\n    let tooltip = '<a style=\"font-weight:bold\" href=' + page.getUrl()+ 'target=\"_blank\">' + page.getName() + '</a><br/>'+\n    'Time Criticality: ' + page.get(CAPABILITY.ATTR.TIME_CRITICALITY) + '<br/>' +\n    'Business Value: ' + page.get(CAPABILITY.ATTR.BUSINESS_VALUE) + '<br/>' +\n    'Risk Reduction: ' + page.get(CAPABILITY.ATTR.RISK_REDUCTION) + '<br/>' +\n    'Job Size: ' + page.get(CAPABILITY.ATTR.JOB_SIZE) + '<br/>' +\n    '<b> WSJF: ' + page.get(CAPABILITY.ATTR.WSJF) + '<br/>';\n    //'Status: ' + page.get(FEATURE.ATTR.STATUS, language) + '</b>';\n    return tooltip;\n}\n\nfunction createHiddenDataItem(x, y, z) {\n    return {\n        x: x,\n        y: y,\n        z: z,\n        enableMouseTracking: false,\n        marker: {\n            enabled: false\n        }\n    }\n}\n\nfunction createQuadrantPlotline(value) {\n    return {\n        color: CHART_COLORS.PLOTLINES,\n        dashStyle: 'solid',\n        width: 1,\n        value: value,\n        zIndex: 3\n    }\n}\n\nfunction createLabelPlotline(text, value, align, color, xOffset, yOffset) {\n    return {\n        width: 0,\n        value: value,\n        zIndex: 3,\n        label: {\n            text: text,\n            align: align,\n            style: {\n                color: color,\n                fontWeight: 'bold'\n            },\n            x: xOffset,\n            y: yOffset\n        }\n    }\n}\n\nfunction hexToRGBA(hex, alpha) {\n    let r = parseInt(hex.slice(1, 3), 16),\n        g = parseInt(hex.slice(3, 5), 16),\n        b = parseInt(hex.slice(5, 7), 16);\n\n    return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + alpha + \")\";\n}\n\nfunction switchSize(size){\n    let switchedSize\n    switch (size) {\n        case 20:\n            switchedSize = 1;\n            break;\n        case 13:\n            switchedSize = 8;\n            break;\n        case 8:\n            switchedSize = 13;\n            break;\n        case 5:\n            switchedSize = 16;\n            break;\n        case 3:\n            switchedSize = 18;\n            break;\n        case 2:\n            switchedSize = 19;\n            break;\n        case 1:\n            switchedSize = 20;\n            break;\n    }\n    return switchedSize;\n}\n\nfunction getColor(type){\n    switch (type) {\n        case CAPABILITY.ENUM_TYPE.ENABLER:\n            return CHART_COLORS.ENABLER;\n        case CAPABILITY.ENUM_TYPE.CAPABILITY:\n            return CHART_COLORS.CAPABILITY\n        default: \n            return '#b5b5b5'\n    }\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType cf.cplace.solution.safe.currentPiDashboard\n * @layout default layout\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Displays the confidence vote of a single PI which is passed in via search results as as bar chart\n */\n\nconst CONFIDENCE_VOTE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.confidenceVote\",\n    ATTR: {\n        PROGRAMM_INCREMENT: \"cf.cplace.solution.safe.confidenceVote.PI\",\n        RESULT: \"cf.cplace.solution.safe.confidenceVote.result\",\n        ONE_FINGER: \"cf.cplace.solution.safe.confidenceVote.oneFinger\",\n        TWO_FINGERS: \"cf.cplace.solution.safe.confidenceVote.twoFingers\",\n        THREE_FINGERS: \"cf.cplace.solution.safe.confidenceVote.threeFingers\",\n        FOUR_FINGERS: \"cf.cplace.solution.safe.confidenceVote.fourFingers\",\n        FIVE_FINGERS: \"cf.cplace.solution.safe.confidenceVote.fiveFingers\",\n    },\n});\n\nconst red = \"#FF0000\";\nconst orange = \"#FFA500\";\nconst yellow = \"#FFFF00\";\nconst lightgreen = \"#9ACD32\";\nconst green = \"#008000\";\n\nfunction main() {\n    // @ts-ignore\n    const confidenceVote = Iterables.getFirst(pages, null);\n\n    if (!confidenceVote) {\n        return;\n    }\n\n    const oneFinger = confidenceVote.get(CONFIDENCE_VOTE.ATTR.ONE_FINGER);\n    const twoFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.TWO_FINGERS);\n    const threeFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.THREE_FINGERS);\n    const fourFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.FOUR_FINGERS);\n    const fiveFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.FIVE_FINGERS);\n    const totalFingers = oneFinger + 2 * twoFingers + 3 * threeFingers + 4 * fourFingers + 5 * fiveFingers;\n    const numberOfConvidenceVotes = oneFinger + twoFingers + threeFingers + fourFingers + fiveFingers;\n\n    const averageConfidenceVote = totalFingers / numberOfConvidenceVotes;\n\n    // Create the chart\n    const config = {\n        chart: {\n            type: \"pie\",\n        },\n        title: {\n            text: averageConfidenceVote.toFixed(1),\n            align: \"center\",\n            verticalAlign: \"middle\",\n            margin: 0,\n            useHtml: true,\n            style: {\n                fontSize: \"3vw\",\n                margin: 0,\n                padding: 0,\n                fontWeight: \"bold\",\n                lineHeight: 1,\n            },\n        },\n        subtitle: {\n            text: \"Average\",\n            align: \"center\",\n            verticalAlign: \"middle\",\n            y: -30,\n            style: {\n                fontWeight: \"normal\",\n                fontSize: \"1vw\",\n            },\n        },\n        legend: {\n            enabled: false,\n            layout: \"horizontal\",\n            align: \"center\",\n            verticalAlign: \"bottom\",\n            itemStyle: {\n                fontWeight: \"normal\",\n            },\n        },\n        plotOptions: {\n            pie: {\n                borderWidth: 10,\n                cursor: \"pointer\",\n                dataLabels: {\n                    enabled: false,\n                },\n                colors: [red, orange, yellow, lightgreen, green],\n            },\n        },\n        series: [\n            {\n                name: \"Count\",\n                cursor: \"pointer\",\n                innerSize: \"70%\",\n                data: [\n                    { name: \"One Finger\", y: oneFinger },\n                    { name: \"Two Fingers\", y: twoFingers },\n                    { name: \"Three Fingers\", y: threeFingers },\n                    { name: \"Four Fingers\", y: fourFingers },\n                    { name: \"Five Fingers\", y: fiveFingers },\n                ],\n            },\n        ],\n    };\n    return config;\n}\n\n// @ts-ignore\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Displays all items grouped by Solution and PI.\n * Dependencies between items are displayed as a line.\n *\n * Milestones that lie within the period of the PIs are displayed in a separate row.\n *\n * @author Christopher W\u00f6lfle\n * @version 15.03.2023\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName(\"highcharts-solution-dependency-map\");\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY_HEIGHT = 0.3;\n\nconst TYPE_CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        TYPE: \"cf.cplace.solution.safe.capabilityType\",\n        FEATURES: \"cf.cplace.solution.safe.feature\",\n        PROGRAM: \"cf.cplace.solution.safe.program\",\n        SOLUTION: \"cf.cplace.solution.safe.solution.reference\",\n        PROGRAM_INCREMENT: \"cf.cplace.solution.safe.programIncrement\",\n        EPIC: \"cf.cplace.solution.safe.portfolioEpic\",\n        ITERATIONS: \"cf.cplace.solution.safe.iteration\",\n    },\n    ENUM: {\n        TYPE: {\n            CAPABILITY: \"capability\",\n            ENABLER: \"enabler\",\n        },\n    },\n});\n\nconst TYPE_MILESTONE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.safeMilestone\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        DATE: \"cf.cplace.solution.safe.date\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        RELEVANT_FOR: \"cf.cplace.solution.safe.relevantFor\", // refers to Program\n    },\n    ENUM: {\n        TYPE: {\n            PI_MILESTONE: \"#15 - PI Meilenstein\",\n            FIXED_DATE: \"#25 - Fixiertes Datum\",\n            LEARNING_MILESTONE: \"#35 - Learning Meilenstein\",\n        },\n    },\n});\n\nconst TYPE_DEPENDENCY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.dependency\",\n    ATTR: {\n        A: \"cf.cplace.solution.safe.successor\",\n        B: \"cf.cplace.solution.safe.predecessor\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        STATUS: \"cf.cplace.solution.safe.status\",\n        DESCRIPTION: \"cf.cplace.solution.safe.description\",\n    },\n    ENUM: {\n        TYPE: {\n            RELATED_TO: \"related to\",\n            BLOCKED_BY: \"blocked by\",\n        },\n        STATUS: {\n            IDENTIFIED: \"15 - identified\",\n            CONFLICT: \"25 - conflict\",\n            RESOLVED: \"35 - resolved\",\n        },\n    },\n});\n\n\nconst TYPE_ITERATION = /** @type {const} */ ({\n    TYPE: 'cf.cplace.solution.safe.iteration',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n        START: 'cf.cplace.solution.safe.startDate',\n        END: 'cf.cplace.solution.safe.endDate',\n        PREDECESSOR: 'cf.cplace.solution.safe.predecessor' // Iteration\n    }\n});\n\nconst COLORS = {\n    INACTIVE: \"#88bbee\",\n    ACTIVE: \"#4488aa\",\n    DEPEND: \"#888888\",\n    DEPEND_HIGHLIGHT: \"#A21622\",\n    DEPEND_RESOLVED: \"#19ad48\",\n    SAFE_MILESTONE: \"#3D8F8C\",\n    RELEASE: \"#366C81\",\n    MILESTONE_PLOTBAND: \"#E2F3F2\",\n    RELEASE_PLOTBAND: \"#E2EEF3\",\n    CAPABILITY: \"#0aa5ff\",\n    ENABLER: \"#ffc80c\",\n    TODAY_PLOTLINE: \"lightgrey\",\n};\n\nconst CATEGORY = {\n    SAFE_MILESTONE: \"SAFe Milestones\",\n};\n\nconst ROW_SIZE = {\n    PERIOD: 2,\n    ITEM: 1,\n};\n\nconst HEIGHTS = {\n    HEADER: 40,\n    ITEM: 25,\n};\n\nconst MAX_DATA_LABEL_LENGTH = 25;\nconst DATA_LABEL_PADDING = 0.05;\n\nconst SEPARATOR = {\n    V: \" //VSEP// \",\n    H: \" --HSEP-- \",\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n/*\n*****************\nThis highchart is based on a heatmap, i.e. the chart is divided into a set of X * Y equally sized cells.\n* The first column(s) of the cells are used to show the vertical categories (categoriesVertical), which are provided as separate \"category\" series\n* The first row(s) of the cells are used to show the horizontal categories (categoriesHorizontal), which are provided as separate \"category\" series\n* The rest of the cells represent the data itself\n    * each cell can be identified by its set of vertical and horizontal categories saved as 'key' in the 'keys'-array in the form of a string like \"X Cat Level 1 - X Cat Level 2 / Y Cat Level 1 - Y Cat Level 2 - Y Cat Level 3\" (in theory the levels can be \"dynamic\", which is not used in this specific example. In this example only 1 level is used)\n    * for each cell the number of entities to be shown is counted as 'value' in the 'values'-array.\n    * the entities for each cell are represented as boxes/cards within the cell and are pushed as separate serie to the main data series\n    * dependencies between entities are represented as separate spline series, whereas start and end point of the splines are the left or right edge of the corresponding entity boxes/cards on the map\n\n/***** config options *****/\n\nfunction main() {\n    const ctx = fetchData(Array.from(pages));\n\n    if (ctx.capabilities.length === 0 || ctx.periods.length === 0) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n\n    generateMatrix(ctx);\n\n    const chart = generateChartConfig(ctx);\n\n    return chart;\n}\n// @ts-ignore\nreturn main();\n//--------------------------------------------------------------------------------------//\n//                                    Data Fetching                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Fetches all required data\n * @param {Page<any>[]} searchResults\n * @returns {Context<\"cf.cplace.solution.safe.iteration\">}\n */\nfunction fetchData(searchResults) {\n    /** @type {Page<'cf.cplace.solution.safe.capability'>[]} */\n    const capabilities = searchResults.filter((page) => page.getBuiltinFeatureValue(\"customType\") === TYPE_CAPABILITY.TYPE);\n    const missinCapabilities = getMissingCapabilities(capabilities);\n    capabilities.push(...missinCapabilities);\n    log(`Added ${missinCapabilities.length} missing items that the input items depend on.`);\n    log(capabilities.length)\n    const periods = getAllPeriods(capabilities);\n    log(\"Periods: \" + periods.length);\n\n    const programs = getPrograms(capabilities);\n    const milestones = getSafeMilestones(periods);\n    const dependencies = getDependencies(capabilities);\n\n    const capabilitiesById = capabilities.reduce((acc, capability) => {\n        acc[capability.getId()] = { x: 0, y: 0, capability };\n        return acc;\n    }, {});\n\n    const ctx = {\n        matrixData: undefined,\n        capabilities,\n        capabilitiesById,\n        periods,\n        programs,\n        milestones,\n        dependencies,\n        maxHeight: 1,\n    };\n    return ctx;\n}\n\n/**\n * Searches dependencies of the capabilities and returns those capabilities that are not yet included\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @return {Page<'cf.cplace.solution.safe.capability'>[]}\n */\nfunction getMissingCapabilities(capabilities) {\n    // @ts-ignore\n    const newCapabilities = new HashSet();\n    capabilities.forEach((item) => {\n        // @ts-ignore\n        const dependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n        dependencies.forEach((itemDependency) => {\n            const capability = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n            if (isPageOfType(capability, TYPE_CAPABILITY.TYPE)) {\n                newCapabilities.add(capability);\n            }\n        });\n    });\n    return Array.from(newCapabilities).filter((a) => !capabilities.some((b) => b.getId() === a.getId()));\n}\n\n/**\n * Determines the periods used as columns of the board\n * @param {Page<\"cf.cplace.solution.safe.capability\">[]} items Capabilities\n * @returns {Page<\"cf.cplace.solution.safe.iteration\">[]} Iterations in chronological order\n */\nfunction getAllPeriods(items) {\n    // @ts-ignore\n    const periodsSet = new HashSet();\n    items.forEach(item => {\n        const pi = item.get(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT);\n        if (!pi) {\n            return;\n        }\n        const iterations = pi.getIncomingPagesFromAllSpaces(TYPE_ITERATION.TYPE, TYPE_ITERATION.ATTR.PROGRAM_INCREMENT);\n        cplace.each(iterations, iteration => {\n            periodsSet.add(iteration);\n        });\n    });\n    /** @type {Page<'cf.cplace.solution.safe.iteration'>[]} */\n    const periods = Array.from(periodsSet);\n    return periods.sort((a, b) => a.get(TYPE_ITERATION.ATTR.START).isBefore(b.get(TYPE_ITERATION.ATTR.START)) ? -1 : 1);\n}\n/**\n * Gets all dependencies of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities Capabilities\n * @returns {Page<'cf.cplace.solution.safe.dependency'>[]} PIs in chronological order\n */\nfunction getDependencies(capabilities) {\n    const dependencies = [];\n    capabilities.forEach((capabilitiy) => {\n        const itemDependencies = Array.from(\n            // @ts-ignore\n            capabilitiy.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []\n        );\n        dependencies.push(...itemDependencies);\n    });\n    return dependencies;\n}\n/**\n * @param {Page<\"cf.cplace.solution.safe.iteration\">[]} iterations\n * @returns\n */\nfunction getSafeMilestones(iterations) {\n    const periodStartDate = iterations.length > 0 ? iterations[0].get(TYPE_ITERATION.ATTR.START) : new DateTime();\n    const periodEndDate = iterations.length > 0 ? iterations[iterations.length - 1].get(TYPE_ITERATION.ATTR.END) : new DateTime();\n    const safeMilestoneSearch = new Search();\n    safeMilestoneSearch.add(Filters.embeddingSpace());\n    safeMilestoneSearch.add(Filters.type(TYPE_MILESTONE.TYPE));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).gte(periodStartDate));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).lte(periodEndDate));\n    safeMilestoneSearch.addBuiltinAttributeSort(TYPE_MILESTONE.ATTR.DATE, true);\n    const safeMilestones = safeMilestoneSearch.findAllPages();\n    // @ts-ignore\n    return Array.from(safeMilestones);\n}\n/**\n * Get all the programs of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @returns {Page<'cf.cplace.solution.safe.program'>[]}\n */\nfunction getPrograms(capabilities) {\n    // @ts-ignore\n    const programSet = new HashSet();\n    capabilities.forEach(item => {\n        const programs = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n        if (!programs) {\n            return;\n        }\n        cplace.each(programs, program => programSet.add(program));\n    });\n    /** @type {Page<'cf.cplace.solution.safe.program'>[]} */\n    const programms = Array.from(programSet)\n    return programms.sort((a,b) => a.getName().localeCompare(b.getName()));\n}\n\n/**\n * Generate the matrix\n * @param {Context<\"cf.cplace.solution.safe.iteration\">} ctx\n */\nfunction generateMatrix(ctx) {\n    /** @type {MatrixData<\"cf.cplace.solution.safe.iteration\">} */\n    const matrixData = {\n        headerRow: ctx.periods.map((pi, index) => ({ programIncrement: pi, x: index + 2, y: 1 })),\n        milestoneRow: ctx.milestones,\n        programms: {},\n        capabilities: {},\n    };\n    let yOffset = 3;\n    ctx.programs.forEach((program) => {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n\n        const capabilitiesByPi = ctx.periods.map((period, indexPI) => {\n            const filteredCapabilities = ctx.capabilities.filter((capability) => {\n                const programIds = capability.get(TYPE_CAPABILITY.ATTR.PROGRAM)?.map((p) => p.getId()) || [];\n                // Get all capabilities that are associated to the current programm & the current program increment\n                return programIds.includes(program.getId()) && getLastIteration(capability)?.getId() === period.getId();\n            });\n            // Check if the number of capabilities for this PI is the largest\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        // Iterate over the programm Increments to put the capabilities in the right place\n        matrixData.programms[program.getName()] = {\n            program,\n            data: capabilitiesByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: program.getId(),\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: program.getId(),\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight; //+ (rowHeight - 1) / 2;\n    });\n\n    const capabilitiesWithoutProgram = ctx.capabilities.filter(\n        (capability) =>\n            // @ts-ignore\n            !capability.get(TYPE_CAPABILITY.ATTR.PROGRAM) || capability.get(TYPE_CAPABILITY.ATTR.PROGRAM).length === 0\n    );\n\n    // Check if there are any capabilities without a programm and add them to the matrix\n    if (capabilitiesWithoutProgram.length > 0) {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n        // Ad capabilities without a program\n        const capabilitiesWithoutProgrammByPi = ctx.periods.map((programIncrement) => {\n            const filteredCapabilities = capabilitiesWithoutProgram.filter(\n                (capability) => getLastIteration(capability)?.getId() === programIncrement.getId()\n            );\n\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        matrixData.programms[\"w/o Program\"] = {\n            program: null,\n            data: capabilitiesWithoutProgrammByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesWithoutProgrammByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: \"w/o Program\",\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: \"w/o Program\",\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight;\n    }\n    ctx.maxHeight = yOffset;\n    ctx.matrixData = matrixData;\n}\n/**\n *\n * @param {Context<\"cf.cplace.solution.safe.iteration\">} ctx\n */\nfunction transformMatrixDataIntoSeries(ctx) {\n    const matrixData = ctx.matrixData;\n\n    const series = [];\n\n    if (!matrixData) {\n        return series;\n    }\n\n    // 1. Add PIs\n    series.push(\n        ...matrixData.headerRow.map((headerEntry, index) => {\n            return {\n                name: headerEntry.programIncrement.getName(),\n                colsize: 1,\n                rowsize: 1,\n                dataLabels: { rotation: 0, color: \"#000000\" },\n                enableMouseTracking: false,\n                data: [\n                    {\n                        x: headerEntry.x,\n                        y: headerEntry.y,\n                        value: 1,\n                        name: `<a href=\"${headerEntry.programIncrement.getUrl()}\">${headerEntry.programIncrement.getName()}</a>`,\n                        color: \"#dddddd\",\n                    },\n                ],\n            };\n        })\n    );\n\n    // 2. Add Milestones\n    series.push({\n        name: \"SAFe Milestones\",\n        colsize: 1,\n        rowsize: 1,\n        dataLabels: { rotation: 0, color: \"#000000\" },\n        enableMouseTracking: false,\n        data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n    });\n\n    let top = true;\n    const safeMilestoneData = [];\n\n    matrixData.milestoneRow.forEach((safeMilestone) => {\n        const safeMilestoneName = safeMilestone.getName();\n        const safeMilestoneDate = safeMilestone.get(TYPE_MILESTONE.ATTR.DATE);\n        // @ts-ignore\n        const safeMilestoneDateString = safeMilestoneDate?.toString(\"dd.MM.yyyy\");\n        // get milestone Position\n        // @ts-ignore\n        const safeMilestonePosition = getDatePosition(safeMilestoneDate.getMillis(), ctx);\n        // add milestone only if position is not null\n        if (safeMilestonePosition > 0) {\n            safeMilestoneData.push({\n                x: safeMilestonePosition,\n                y: 2,\n                name: '<a href=\"' + safeMilestone.getUrl() + '\">' + safeMilestoneName + \"</a>\",\n                value: safeMilestoneDateString,\n                dataLabels: {\n                    verticalAlign: top ? \"top\" : \"bottom\",\n                },\n            });\n            top = !top;\n        }\n    });\n\n    series.push({\n        type: \"scatter\",\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        data: safeMilestoneData,\n        marker: {\n            fillColor: COLORS.SAFE_MILESTONE,\n        },\n    });\n\n    // 3. Add Programms\n    let rowHeight = 2.5;\n    Object.keys(matrixData.programms).forEach((programName) => {\n        const data = matrixData.programms[programName];\n        // Add the Programms\n        series.push({\n            name: programName,\n            rowsize: data.rowHeight,\n            dataLabels: { rotation: 0, color: \"#000000\" },\n            enableMouseTracking: false,\n            data: [\n                {\n                    x: data.x,\n                    y: data.y,\n                    value: 1,\n                    name: `<a href=\\\"${data.program?.getUrl() || \"wip\"}\\\">${programName}</a>`,\n                    color: \"#dddddd\",\n                },\n            ],\n        });\n        // Add the capabilities of the programm\n        data.data.map((capabilitiesByPI, indexPI) => {\n            series.push({\n                name: programName + indexPI,\n                rowsize: CAPABILITY_HEIGHT,\n                colsize: 0.8,\n                dataLabels: { rotation: 0, color: \"#000000\", overflow: 'justify' },\n                enableMouseTracking: false,\n                data: capabilitiesByPI.map((capabilityId, indexCapability) => {\n                    const capabilityData = matrixData.capabilities[capabilityId].filter((c) => c.programId === (data.program ? data.program.getId() : \"w/o Program\"))[0];\n                    const capability = capabilityData.capability;\n                    const isEnabler = capability.get(TYPE_CAPABILITY.ATTR.TYPE) === \"enabler\";\n                    return {\n                        x: capabilityData.x,\n                        y: capabilityData.y,\n                        value: 1,\n                        name: `<a href=\\\"${capability.getUrl() || \"wip\"}\\\">${limitStringSize(capability.getName(), 40)}</a>`,\n                        color: isEnabler ? \"#ffc80c\" : \"#0aa5ff\",\n                    };\n                }),\n            });\n        });\n        rowHeight += data.rowHeight;\n    });\n\n    // 4. Add Dependencies\n    ctx.dependencies.forEach((dependency) => {\n        const from = dependency.get(TYPE_DEPENDENCY.ATTR.B);\n        const to = dependency.get(TYPE_DEPENDENCY.ATTR.A);\n        if (!from || !to) {\n            return;\n        }\n        const fromId = from.getId();\n        const toId = to.getId();\n\n        const fromCapabilities = ctx.matrixData?.capabilities[fromId];\n        const toCapabilities = ctx.matrixData?.capabilities[toId];\n\n        if (!fromCapabilities) {\n            return;\n        }\n        const maxValue = ctx.maxHeight;\n        fromCapabilities.forEach((fromCapabilityData) => {\n            let x1 = fromCapabilityData.x;\n            let y1 = fromCapabilityData.y;\n            // y1 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n            if (!toCapabilities) {\n                return;\n            }\n            toCapabilities.forEach((toCapabilityData) => {\n                let x2 = toCapabilityData.x;\n                let y2 = toCapabilityData.y;\n                // y2 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n                const description = dependency.get(TYPE_DEPENDENCY.ATTR.DESCRIPTION) || \" \";\n                const dependencyType = dependency.get(TYPE_DEPENDENCY.ATTR.TYPE);\n                const status = dependency.get(TYPE_DEPENDENCY.ATTR.STATUS);\n                const dependencySeries = {\n                    type: \"spline\",\n                    name: \"<b>\" + to.getName() + \"</b><br/>relates to:<br/>\" + from.getName() + \"<br>\" + description,\n                    lineWidth: 1.5,\n                    color: COLORS.DEPEND,\n                    dashStyle: \"shortdot\",\n                    findNearestPointBy: \"xy\",\n                    data: [\n                        { x: x1 + 0.4, y: y1 },\n                        { x: x1 + 0.45, y: y1 === y2 ? y1 + 0.02 : y1 },\n                        { x: x2 - 0.45, y: y1 === y2 ? y2 - 0.02 : y2 },\n                        { x: x2 - 0.4, y: y2, marker: { enabled: true, symbol: \"diamond\" } },\n                    ],\n                };\n                if (dependencyType === TYPE_DEPENDENCY.ENUM.TYPE.BLOCKED_BY) {\n                    dependencySeries.name = \"<b>\" + to.getName() + \"</b><br/>blocked by:<br/>\" + from.getName() + \"<br>\" + description;\n                    // @ts-ignore\n                    dependencySeries.dashStyle = null;\n                }\n                if (status === TYPE_DEPENDENCY.ENUM.STATUS.CONFLICT) {\n                    dependencySeries.color = COLORS.DEPEND_HIGHLIGHT;\n                } else if (status === TYPE_DEPENDENCY.ENUM.STATUS.RESOLVED) {\n                    dependencySeries.color = COLORS.DEPEND_RESOLVED;\n                }\n                series.push(dependencySeries);\n            });\n        });\n    });\n\n    return series;\n}\n\n//--------------------------------------------------------------------------------------//\n//                                     Chart Config                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n *\n * @param {Context<\"cf.cplace.solution.safe.iteration\">} ctx\n */\nfunction generateChartConfig(ctx) {\n    if (!ctx.matrixData) {\n        return;\n    }\n    const series = transformMatrixDataIntoSeries(ctx);\n    // @ts-ignore\n    const today = new DateTime();\n    let todayPosition = getDatePosition(today.getMillis(), ctx);\n\n    return {\n        chart: {\n            type: \"heatmap\",\n            marginTop: 0,\n            marginBottom: 0,\n            plotBorderWidth: 0,\n            scrollablePlotArea: {\n                minHeight: 400,\n                minWidth: 1000,\n            },\n        },\n        title: {\n            text: null,\n        },\n        xAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 0,\n            lineWidth: 0,\n            labels: {\n                enabled: false,\n            },\n            plotLines: [\n                {\n                    dashStyle: \"dash\",\n                    color: COLORS.TODAY_PLOTLINE,\n                    width: 2,\n                    value: todayPosition,\n                    zIndex: 1,\n                },\n            ],\n        },\n        yAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 1,\n            tickInterval: 1,\n            lineWidth: 0,\n            min: 1,\n            max: ctx.maxHeight,\n            labels: {\n                enabled: false,\n            },\n            reversed: true,\n            scrollbar: {\n                enabled: true,\n            },\n            plotBands: [\n                {\n                    color: COLORS.MILESTONE_PLOTBAND,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    from: 1.5,\n                    to: 2.5,\n                    zIndex: 0,\n                },\n                // {\n                //     color: COLORS.RELEASE_PLOTBAND,\n                //     borderColor: 'white',\n                //     borderWidth: 2,\n                //     from: 1.5,\n                //     to: 2.5,\n                //     zIndex: 0\n                // }\n            ],\n        },\n        colors: [\"#D5001C\", \"#92D050\"],\n        colorAxis: {\n            dataClassColor: \"category\",\n            dataClasses: [\n                {\n                    to: 0.5,\n                },\n                {\n                    from: 0.5,\n                },\n            ],\n        },\n        legend: {\n            enabled: false,\n        },\n        tooltip: {\n            useHTML: true,\n            followPointer: false,\n        },\n        plotOptions: {\n            series: {\n                borderColor: \"#ffffff\",\n                borderWidth: 2,\n                dataLabels: {\n                    allowOverlap: false,\n                    inside: true,\n                    crop: true,\n                    overflow: \"justify\",\n                    position: \"left\",\n                    shape: \"circle\",\n                    enabled: true,\n                    color: \"#000000\",\n                    format: \"{point.name}\",\n                    style: {\n                        textOutline: \"none\",\n                        textOverflow: \"clip\",\n                    },\n                },\n                stickyTracking: false,\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b>\",\n                    findNearestPointBy: \"xy\",\n                },\n                states: {\n                    inactive: {\n                        opacity: 1,\n                    },\n                },\n            },\n            spline: {\n                tooltip: {\n                    headerFormat: \"{series.name}\",\n                    pointFormat: \"\",\n                    findNearestPointBy: \"xy\",\n                },\n                marker: {\n                    enabled: false,\n                    fillColor: COLORS.DEPEND,\n                    radius: 6,\n                    states: {\n                        hover: {\n                            enabled: false,\n                        },\n                    },\n                },\n            },\n            scatter: {\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b><br>{point.value}\",\n                    findNearestPointBy: \"xy\",\n                },\n                dataLabels: {\n                    enabled: true,\n                },\n                marker: {\n                    enabled: true,\n                    symbol: \"diamond\",\n                    radius: 10,\n                    states: {\n                        hover: {\n                            enabled: true,\n                        },\n                    },\n                },\n            },\n        },\n        series: series,\n        // series: [\n        //     {\n        //         name: \"PI 22.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 2,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/1bk9kpxn7s36vz3w80ji7t5oo/PI-22.4\">PI 22.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 3,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4l6jbaa8qgzinif5qetj499g5/PI-23.1\">PI 23.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.2\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 4,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/tksr708c2119mek2pzzopu9qb/PI-23.2\">PI 23.2</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.3\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 5,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/i4o8azmi8m0oqvqqu3hejgu80/PI-23.3\">PI 23.3</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 6,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/nrymz33xo7ew3x6qcgdk3fl7l/PI-23.4\">PI 23.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 24.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 7,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/0wtzrg3m4bdpfhut5xbgiza73/PI-24.1\">PI 24.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"SAFe Milestones\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n        //     },\n        //     {\n        //         name: \"Smart Infotainment\",\n        //         rowsize: 2,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 3.5,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/qg000odouviwwtx4rz2bvaoi8/Smart-Infotainment\">Smart Infotainment</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"Powertrain and Safety\",\n        //         rowsize: 4,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 5 + (4-1)/2,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4flf7a0349c5ximei6olrhife/Powertrain-and-Safety\">Powertrain and Safety</a>',\n        //                 color: \"red\",\n        //             },\n        //         ],\n        //     },\n        // ],\n    };\n}\n\n//--------------------------------------------------------------------------------------//\n//                                        Utils                                         //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Limit string to specified size\n * @param {string} str\n * @param {number} maxSize\n * @returns\n */\nfunction limitStringSize(str, maxSize) {\n    if (str.length > maxSize) {\n        return str.substring(0, maxSize - 3) + \"...\";\n    }\n    return str;\n}\n\n/**\n *\n * @param {number} date\n * @param {Context<\"cf.cplace.solution.safe.iteration\">} ctx\n * @returns\n */\nfunction getDatePosition(date, ctx) {\n    let xPosition = 0;\n    ctx.periods.every((pi, idx) => {\n        // @ts-ignore\n        let categoryStartDate = pi.get(TYPE_ITERATION.ATTR.START)?.getMillis();\n        // @ts-ignore\n        let categoryEndDate = pi.get(TYPE_ITERATION.ATTR.END)?.getMillis();\n\n        // Check whether release date lies in between start and end date of category\n        if (categoryStartDate && categoryEndDate && date >= categoryStartDate && date <= categoryEndDate) {\n            // find x-Value of category and subtract 0.5 for starting point as offset\n            let x = idx + 2 - 0.5;\n            // calculate the relative position of date between Category StartDate and EndDate and add it to the offset value\n            xPosition = x + (date - categoryStartDate) / (categoryEndDate - categoryStartDate);\n            // exit the every loop\n            return false;\n        }\n        // continue the every loop\n        return true;\n    });\n    // if there was no match, just return null\n    return xPosition;\n}\n\n/**\n * Checks if a cplace page is of the specified type\n * @param {Page} page\n * @param {string} type\n * @returns {boolean}\n */\nfunction isPageOfType(page, type) {\n    return page.getBuiltinFeatureValue(\"customType\") === type;\n}\n\nfunction getLastIteration(item) {\n    const iterations = Array.from(item.get(TYPE_CAPABILITY.ATTR.ITERATIONS));\n    let lastIteration = iterations.length > 0 ? iterations[0] : null;\n    iterations.forEach(iteration => {\n        if (lastIteration.get(TYPE_ITERATION.ATTR.END).isBefore(iteration.get(TYPE_ITERATION.ATTR.END))) {\n            lastIteration = iteration;\n        }\n    });\n    log(`Found ${iterations.length} iterations for item \"${item.getName()}\"`);\n    if (lastIteration) {\n        log(`Last iteration \"${lastIteration.getName()}\" ending ${lastIteration.get(TYPE_ITERATION.ATTR.END).toString()}`);\n    }\n    return lastIteration;\n}\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    const logOutput = typeof text !== \"string\" ? JSON.stringify(text) : text;\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType ccf.cplace.solution.safe.currentPiDashboard\n * @layout default layout\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Displays the PI statistics\n */\n\n/**\n * Identifier: highchart-programIncrement-progress\n * Type of chart: multi pie chart\n * Type of search pages: cf.cplace.solution.safe.team, cf.cplace.solution.safe.story\n * Functionality: visualizes different kinds of kpis\n *\n * INSTRUCTIONS TO ADD CHARTS\n * 1. Increase TOTAL_NUMBER_OF_KPIS +1\n * 2. Define Following Values\n *      - CX_TITLE\n *      - CX_ACTUAL\n *      - CX_ACTUAL_PERCENTAGE\n *      - CX_DISPLAY_NUMBER\n *      - CX_DISPLAY_TEXT\n *      - CX_COLOR\n * 3. Create chart\n *      - createChart(CX_TITLE, CX_ACTUAL_PERCENTAGE, CX_DISPLAY_NUMBER, CX_DISPLAY_TEXT, CX_COLOR) {\n *\n *\n * @author Lukas Scheiring (cF)\n * Last edited: 18.08.2022\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName(\"highchart-programStartPage-statistics\");\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CURRENT_PI_DASHBOARD = {\n    TYPE: \"cf.cplace.solution.safe.currentPiDashboard\",\n    ATTR: {\n        CURRENT_PI: \"cf.cplace.solution.safe.currentPi\"\n    }\n}\n\n//CHART COLOURS\nconst COLOURS = {\n    TEXT_COLOR: \"#003653\",\n    BACKGROUND_COLOR: \"#ffffff\",\n    GREY: \"gray\",\n    RED: \"#f30000\",\n    DARK_RED: \"#9e0000\",\n    YELLOW: \"#ffc700\",\n    GREEN: \"#5ab500\",\n    BLUE: \"#A6CAD8\",\n};\n\n//CHART SETTINGS\nconst TOTAL_NUMBER_OF_KPIS = 5;\nconst Y_POSITION = \"40%\";\n\n//LANGUAGE SETTINGS\nconst NAMINGS = {\n    de: {\n        CHART_TITLE: \"\",\n    },\n    en: {\n        CHART_TITLE: \"\",\n    },\n};\n\n//PLACEHOLDER\nconst PROGRAM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        PREDECESSOR: \"cf.cplace.solution.safe.predecessor\",\n        PERIOD_STATUS: \"cf.cplace.solution.safe.periodStatus\",\n        CAPACITY: \"cf.cplace.solution.safe.capacity\",\n    },\n});\n\nconst CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        ACTUAL_START_DATE: \"cf.cplace.solution.safe.actualStartDate\",\n        ACTUAL_END_DATE: \"cf.cplace.solution.safe.actualEndDate\",\n        PROGRAM_INCREMENT: \"cf.cplace.solution.safe.programIncrement\",\n        STATE: \"cf.cplace.solution.safe.state\",\n    },\n    ENUM: {\n        STATE: {\n            DONE: \"#85 - Done\",\n        },\n    },\n});\n\nconst CONFIDENCE_VOTE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.confidenceVote\",\n    ATTR: {\n        PROGRAMM_INCREMENT: \"cf.cplace.solution.safe.confidenceVote.PI\",\n        RESULT: \"cf.cplace.solution.safe.confidenceVote.result\",\n        ONE_FINGER: \"cf.cplace.solution.safe.confidenceVote.oneFinger\",\n        TWO_FINGERS: \"cf.cplace.solution.safe.confidenceVote.twoFingers\",\n        THREE_FINGERS: \"cf.cplace.solution.safe.confidenceVote.threeFingers\",\n        FOUR_FINGERS: \"cf.cplace.solution.safe.confidenceVote.fourFingers\",\n        FIVE_FINGERS: \"cf.cplace.solution.safe.confidenceVote.fiveFingers\",\n    },\n});\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\nlog(\"Start...\");\nlet currentUser = cplace.utils().getCurrentUser();\nconst userLanguage = currentUser.getUserLanguage();\n\n\nlet programIncrement = embeddingPage.get(CURRENT_PI_DASHBOARD.ATTR.CURRENT_PI)\n\nlet chartIndex = 0;\n\n//Container\nlet capabilities = [];\n/** @type {Page<'cf.cplace.solution.safe.confidenceVote'> | undefined} */\nlet confidenceVote;\n\nlet series = [];\nlet yAxis = [];\nlet pane = [];\n\n//Dates\nlet piStartDate = programIncrement.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay();\nlet piEndDate = programIncrement.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay();\nlet today = new DateTime().withTimeAtStartOfDay();\n\n//KPIs\nlet totalDaysOfPI = Days.daysBetween(piStartDate, piEndDate).getDays();\nlet passedDaysOfPI = getPassedDays(piStartDate, piEndDate, today, totalDaysOfPI);\n\nlet totalCapacity = programIncrement.get(PROGRAM_INCREMENT.ATTR.CAPACITY);\nlet velocityOfLastPI = 0;\nlet totalCapabilities = 0;\nlet capabilitiesDone = 0;\nlet confidenceVoteAverage = 0;\n\n//--------------------------------------------------------------------------------------//\n//                                       PROCESSING STAGE                               //\n//--------------------------------------------------------------------------------------//\n\n// Group pages\ncplace.each(pages, (page) => {\n    switch (page.getBuiltinFeatureValue(\"customType\")) {\n        case CAPABILITY.TYPE:\n            capabilities.push(page);\n            break;\n        case CONFIDENCE_VOTE.TYPE:\n            confidenceVote = page;\n            break;\n        default:\n            break;\n    }\n});\n\ntotalCapabilities = capabilities.length;\nvelocityOfLastPI = calculateVelocityOfLastPi(programIncrement);\nconfidenceVoteAverage = calculateConfidenceVoteAverage(confidenceVote);\n\ncapabilitiesDone = capabilities.filter(\n    (/** @type {Page<'cf.cplace.solution.safe.capability'>} */ c) =>\n        c.get(CAPABILITY.ATTR.STATE) === CAPABILITY.ENUM.STATE.DONE\n).length;\n\n//--------------------------------------------------------------------------------------//\n//                                       KPIs & CHART                                   //\n//--------------------------------------------------------------------------------------//\n\n//KPI 1 - Story Points done\nconst C1_TITLE = \"Done Capabilities Last PI\";\nconst C1_ACTUAL_VALUE = velocityOfLastPI || 0;\nconst C1_DISPLAY_NUMBER = C1_ACTUAL_VALUE;\nconst C1_DISPLAY_TEXT = \"<b>VELOCITY LAST PI</b><br>\";\nconst C1_COLOR = COLOURS.GREEN;\n\ncreateChart(C1_TITLE, C1_ACTUAL_VALUE, C1_DISPLAY_NUMBER, C1_DISPLAY_TEXT, C1_COLOR);\n\n// KPI 2 - Done Capabilities\nconst C2_TITLE = \"Done Capabilities\";\nconst C2_ACTUAL_PERCENTAGE = Math.round((capabilitiesDone / totalCapabilities) * 100) || 0;\nconst C2_DISPLAY_NUMBER = C2_ACTUAL_PERCENTAGE + \"%\";\nconst C2_DISPLAY_TEXT = \"<b>DONE CAPABILITIES</b><br>\" + capabilitiesDone + \"/\" + totalCapabilities;\nconst C2_COLOR = COLOURS.GREEN;\n\ncreateChart(C2_TITLE, C2_ACTUAL_PERCENTAGE, C2_DISPLAY_NUMBER, C2_DISPLAY_TEXT, C2_COLOR);\n\n// KPI 3 - Load vs Capacity\nconst C3_TITLE = \"Load vs. Capacity\";\nconst C3_ACTUAL_PERCENTAGE = (totalCapacity && Math.round((totalCapabilities / totalCapacity) * 100)) || 0;\nconst C3_DISPLAY_NUMBER = C3_ACTUAL_PERCENTAGE + \"%\";\nconst C3_DISPLAY_TEXT = \"<b>LOAD VS. CAPACITY</b><br>\" + totalCapabilities + \"/\" + totalCapacity;\n\nlet c3_color = COLOURS.GREEN;\nif (Math.round((totalCapabilities / totalCapacity) * 100) >= 90) {\n    c3_color = COLOURS.YELLOW;\n    if (Math.round((totalCapabilities / totalCapacity) * 100) > 100) {\n        c3_color = COLOURS.RED;\n    }\n}\n\ncreateChart(C3_TITLE, C3_ACTUAL_PERCENTAGE, C3_DISPLAY_NUMBER, C3_DISPLAY_TEXT, c3_color);\n\n// KPI 4 - passed days\nconst C4_TITLE = \"Days passed\";\nconst C4_ACTUAL_PERCENTAGE = Math.round((passedDaysOfPI / totalDaysOfPI) * 100) || 0;\nconst C4_DISPLAY_NUMBER = C4_ACTUAL_PERCENTAGE + \"%\";\nconst C4_DISPLAY_TEXT = \"<b>DAYS PASSED</b><br>\" + passedDaysOfPI + \"/\" + totalDaysOfPI;\nconst C4_COLOR = COLOURS.GREEN;\n\ncreateChart(C4_TITLE, C4_ACTUAL_PERCENTAGE, C4_DISPLAY_NUMBER, C4_DISPLAY_TEXT, C4_COLOR);\n\n// KPI 5 - Confidence Vote\nconst C5_TITLE = \"Average Confidence Vote\";\nconst C5_ACTUAL_PERCENTAGE = Math.round((confidenceVoteAverage / 5) * 100) || 0;\nconst C5_DISPLAY_NUMBER = confidenceVoteAverage.toFixed(1);\nconst C5_DISPLAY_TEXT = \"<b>AVG. CONFIDENCE VOTE</b><br>\";\nconst C5_COLOR = getConvidenceVoteColors(confidenceVoteAverage);\n\ncreateChart(C5_TITLE, C5_ACTUAL_PERCENTAGE, C5_DISPLAY_NUMBER, C5_DISPLAY_TEXT, C5_COLOR);\n\nlog(\"End...\");\n\n// @ts-ignore\nreturn {\n    chart: {\n        type: \"solidgauge\",\n    },\n\n    title: {\n        text: NAMINGS[userLanguage].CHART_TITLE,\n    },\n    series: series,\n    yAxis: yAxis,\n    pane: pane,\n    tooltip: {\n        enabled: false,\n    },\n    plotOptions: {\n        solidgauge: {\n            enableMouseTracking: false,\n        },\n    },\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n\nfunction createChart(title, actualRel, displayNumber, displayText, color) {\n    series.push(getSeriesObject(title, actualRel, displayNumber, chartIndex, color));\n    yAxis.push(getYAxisObject(displayText, chartIndex, 0, 100));\n    pane.push(getPaneObject(getXAxisPosition(chartIndex), Y_POSITION));\n    chartIndex++;\n}\n\nfunction getXAxisPosition(kpiIndex) {\n    return (120 * (kpiIndex + 1)) / (TOTAL_NUMBER_OF_KPIS + 1) - 10 + \"%\";\n}\n\nfunction getPassedDays(piStartDate, piEndDate, today, totalDaysOfPI) {\n    if (today.isBefore(piStartDate)) {\n        return 0;\n    }\n    if (piEndDate.isBefore(today)) {\n        return totalDaysOfPI;\n    }\n    // @ts-ignore\n    return Days.daysBetween(piStartDate, today).getDays();\n}\n\nfunction getSeriesObject(title, actual, label, index, color) {\n    return {\n        name: title,\n        data: [\n            {\n                name: title,\n                color: color,\n                y: actual,\n                innerRadius: \"80%\",\n                radius: \"100%\",\n                dataLabels: {\n                    format: '<span style=\"font-size:24px;font-wight: bold\">' + label + \"</span>\",\n                    borderWidth: 0,\n                    color: COLOURS.GREY,\n                    verticalAlign: \"middle\",\n                    useHTML: true,\n                },\n            },\n        ],\n        yAxis: index,\n    };\n}\n\nfunction getYAxisObject(axisTitle, index, min, max) {\n    return {\n        min: min,\n        max: max,\n        pane: index,\n        title: {\n            text: axisTitle,\n            useHTML: true,\n            y: 110,\n        },\n        labels: {\n            enabled: false,\n        },\n        /*stops: [\n            [0.1, COLOURS.GREEN], // green\n            [0.9, COLOURS.YELLOW], // yellow\n            [0.99, COLOURS.RED] // red\n        ],*/\n        lineWidth: 0,\n        tickWidth: 0,\n        tickAmount: 0,\n        minorTickWidth: 0,\n    };\n}\n\nfunction getPaneObject(xPosition, yPosition) {\n    return {\n        center: [xPosition, yPosition],\n        size: \"50%\",\n        startAngle: 0,\n        endAngle: 360,\n        background: {\n            backgroundColor: \"#EEE\",\n            borderColor: null,\n            innerRadius: \"80%\",\n            outerRadius: \"100%\",\n            shape: \"arc\",\n        },\n    };\n}\n\nfunction getConvidenceVoteColors(value) {\n    if (value <= 2) {\n        return COLOURS.RED;\n    } else if (value <= 3) {\n        return COLOURS.YELLOW;\n    } else {\n        return COLOURS.GREEN;\n    }\n}\n\n/**\n * Calculates the average confidence vote\n * @param {Page<'cf.cplace.solution.safe.confidenceVote'> | undefined | null} confidenceVote\n */\nfunction calculateConfidenceVoteAverage(confidenceVote) {\n    if (!confidenceVote) {\n        return 0;\n    }\n    const oneFinger = confidenceVote.get(CONFIDENCE_VOTE.ATTR.ONE_FINGER);\n    const twoFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.TWO_FINGERS);\n    const threeFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.THREE_FINGERS);\n    const fourFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.FOUR_FINGERS);\n    const fiveFingers = confidenceVote.get(CONFIDENCE_VOTE.ATTR.FIVE_FINGERS);\n    const totalFingers = oneFinger + 2 * twoFingers + 3 * threeFingers + 4 * fourFingers + 5 * fiveFingers;\n    const numberOfConvidenceVotes = oneFinger + twoFingers + threeFingers + fourFingers + fiveFingers;\n\n    return totalFingers / numberOfConvidenceVotes;\n}\n\n/**\n * Calculate the velocity of last PI as number of capabilities that were done in the last PI\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>} currentPi\n */\nfunction calculateVelocityOfLastPi(currentPi) {\n    let lastPI = currentPi.get(PROGRAM_INCREMENT.ATTR.PREDECESSOR);\n    if (!lastPI) {\n        return 0;\n    }\n    const velocity = Array.from(lastPI.getIncomingPages(CAPABILITY.TYPE, CAPABILITY.ATTR.PROGRAM_INCREMENT)).filter(\n        (/** @type {Page<'cf.cplace.solution.safe.capability'>} */ c) =>\n            c.get(CAPABILITY.ATTR.STATE) === CAPABILITY.ENUM.STATE.DONE\n    ).length;\n    return velocity;\n}\n// //--------------------------------------------------------------------------------------//\n// //                                       HELPER FUNCTIONS                               //\n// //--------------------------------------------------------------------------------------//\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    let logOutput = typeof text !== \"string\" ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * LOWCODE BUTTON\n * @customType cf.cplace.solution.safe.solution\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Set previous current and next pi\n */\n\ncplace.setLogName(\"lowcodebutton_setAsCurrentPi\");\n\nconst DEBUG = true;\n\nconst PROGRAMM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        PERIOD_STATUS: \"cf.cplace.solution.safe.periodStatus\",\n        PREDECESSOR: \"cf.cplace.solution.safe.predecessor\",\n    },\n    ENUM: {\n        PERIOD_STATUS: {\n            DONE: \"#15 - done\",\n            ACTIVE: \"#25 - active\",\n        },\n    },\n});\n\nconst SOLUTION = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.solution\",\n});\n\nfunction checkAccess() {\n    return true;\n}\n\nfunction call() {\n    const newState = {\n        \"cf.cplace.solution.safe.previousPi\": {},\n        \"cf.cplace.solution.safe.currentPi\": {},\n        \"cf.cplace.solution.safe.nextPi\": {},\n    };\n    /** @type {Page<'cf.cplace.solution.safe.solution'> | null} */\n    const solution = Iterables.getFirst(pages, null);\n    if (!solution) {\n        DEBUG && cplace.log(\"No solution provided\");\n        return {\n            message: {\n                de: \"Keine Solution in der Suche gefunden\",\n                en: \"No solution provided via Search\",\n            },\n        };\n    }\n\n    const currentPi = solution.get(\"cf.cplace.solution.safe.currentPi\");\n    if (!currentPi) {\n        DEBUG && cplace.log(\"No current PI\");\n        log.logText({\n            de: \"Kein aktuelles PI gesetzt\",\n            en: \"No current PI\",\n        });\n        return;\n    }\n\n    const newPreviousPi = currentPi;\n    let newCurrentPi = solution.get(\"cf.cplace.solution.safe.nextPi\");\n\n    if (!newCurrentPi) {\n        // If we don't have a next PI specified yet on the solution, we try to get the next PI where the predecessor is set to the current PI (newPreviousPi)\n        newCurrentPi = getNextPi(newPreviousPi);\n        if (!newCurrentPi) {\n            DEBUG && cplace.log(\"No next PI defined\");\n            log.logText({\n                de: \"Kein n\u00e4chstes PI definiert\",\n                en: \"No next PI defined\",\n            });\n            return;\n        }\n    }\n    const newNextPi = getNextPi(newCurrentPi);\n\n    if (!newNextPi) {\n        DEBUG && cplace.log(\"No next PI defined\");\n        log.logText({\n            de: \"Kein \u00fcbern\u00e4chstes PI definiert\",\n            en: \"No PI defined after next PI\",\n        });\n        return;\n    }\n    cplace.log(`New next PI: ${newNextPi.getName()}`);\n\n    newState[\"cf.cplace.solution.safe.previousPi\"] = newPreviousPi;\n    newState[\"cf.cplace.solution.safe.currentPi\"] = newCurrentPi;\n    newState[\"cf.cplace.solution.safe.nextPi\"] = newNextPi;\n\n    cplace.actions().updatePage(solution, {\n        customAttributes: newState,\n    });\n\n    // Set new previous PI to done\n    cplace.actions().updatePage(currentPi, {\n        customAttributes: {\n            [PROGRAMM_INCREMENT.ATTR.PERIOD_STATUS]: PROGRAMM_INCREMENT.ENUM.PERIOD_STATUS.DONE,\n        },\n    });\n\n    // Set new current PI to active\n    cplace.actions().updatePage(newCurrentPi, {\n        customAttributes: {\n            [PROGRAMM_INCREMENT.ATTR.PERIOD_STATUS]: PROGRAMM_INCREMENT.ENUM.PERIOD_STATUS.ACTIVE,\n        },\n    });\n    cplace.actions().refresh();\n\n    return {\n        message: {\n            de: `Das n\u00e4chste PI wurde erfolgreich auf ${newCurrentPi.getName()} gesetzt`,\n            en: `Successfully set the current PI to ${newCurrentPi.getName()}`,\n        },\n    };\n}\n\n/**\n *\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>} programIncrement\n */\nfunction getNextPi(programIncrement) {\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>[]} */\n    const results = Array.from(\n        programIncrement.getIncomingPages(PROGRAMM_INCREMENT.TYPE, PROGRAMM_INCREMENT.ATTR.PREDECESSOR)\n    );\n\n    if (results.length > 1) {\n        log.logText({\n            de: `Es gibt mehr als ein PI (${results\n                .map((pi) => pi.getName())\n                .join(\", \")}) bei dem der Vorg\u00e4nger ${programIncrement.getName()} ist`,\n            en: `There is more than one PI (${results\n                .map((pi) => pi.getName())\n                .join(\", \")}) where the predecessor is: ${programIncrement.getName()}`,\n        });\n        return null;\n    }\n    if (results.length === 0) {\n        return null;\n    }\n    return results[0];\n}\n\n\nreturn { checkAccess, call };",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * Displays all items grouped by Solution and PI.\n * Dependencies between items are displayed as a line.\n *\n * Milestones that lie within the period of the PIs are displayed in a separate row.\n *\n * @author Christopher W\u00f6lfle\n * @version 15.03.2023\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName(\"highcharts-solution-dependency-map\");\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY_HEIGHT = 0.3;\n\nconst TYPE_CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        TYPE: \"cf.cplace.solution.safe.capabilityType\",\n        FEATURES: \"cf.cplace.solution.safe.feature\",\n        PROGRAM: \"cf.cplace.solution.safe.program\",\n        SOLUTION: \"cf.cplace.solution.safe.solution.reference\",\n        PROGRAM_INCREMENT: \"cf.cplace.solution.safe.programIncrement\",\n        EPIC: \"cf.cplace.solution.safe.portfolioEpic\",\n        TEMP_ITERATIONS: \"cf.cplace.solution.safe.iteration\",\n    },\n    ENUM: {\n        TYPE: {\n            CAPABILITY: \"capability\",\n            ENABLER: \"enabler\",\n        },\n    },\n});\n\nconst TYPE_MILESTONE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.safeMilestone\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        DATE: \"cf.cplace.solution.safe.date\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        RELEVANT_FOR: \"cf.cplace.solution.safe.relevantFor\", // refers to Program\n    },\n    ENUM: {\n        TYPE: {\n            PI_MILESTONE: \"#15 - PI Meilenstein\",\n            FIXED_DATE: \"#25 - Fixiertes Datum\",\n            LEARNING_MILESTONE: \"#35 - Learning Meilenstein\",\n        },\n    },\n});\n\nconst TYPE_DEPENDENCY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.dependency\",\n    ATTR: {\n        A: \"cf.cplace.solution.safe.successor\",\n        B: \"cf.cplace.solution.safe.predecessor\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        STATUS: \"cf.cplace.solution.safe.status\",\n        DESCRIPTION: \"cf.cplace.solution.safe.description\",\n    },\n    ENUM: {\n        TYPE: {\n            RELATED_TO: \"related to\",\n            BLOCKED_BY: \"blocked by\",\n        },\n        STATUS: {\n            IDENTIFIED: \"15 - identified\",\n            CONFLICT: \"25 - conflict\",\n            RESOLVED: \"35 - resolved\",\n        },\n    },\n});\n\nconst TYPE_PROGRAM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        START: \"cf.cplace.solution.safe.startDate\",\n        END: \"cf.cplace.solution.safe.endDate\",\n        PREDECESSOR: \"cf.cplace.solution.safe.predecessor\", // Program Increment\n    },\n});\n\nconst COLORS = {\n    INACTIVE: \"#88bbee\",\n    ACTIVE: \"#4488aa\",\n    DEPEND: \"#888888\",\n    DEPEND_HIGHLIGHT: \"#A21622\",\n    DEPEND_RESOLVED: \"#19ad48\",\n    SAFE_MILESTONE: \"#3D8F8C\",\n    RELEASE: \"#366C81\",\n    MILESTONE_PLOTBAND: \"#E2F3F2\",\n    RELEASE_PLOTBAND: \"#E2EEF3\",\n    CAPABILITY: \"#0aa5ff\",\n    ENABLER: \"#ffc80c\",\n    TODAY_PLOTLINE: \"lightgrey\",\n};\n\nconst CATEGORY = {\n    SAFE_MILESTONE: \"SAFe Milestones\",\n};\n\nconst ROW_SIZE = {\n    PERIOD: 2,\n    ITEM: 1,\n};\n\nconst HEIGHTS = {\n    HEADER: 40,\n    ITEM: 25,\n};\n\nconst MAX_DATA_LABEL_LENGTH = 25;\nconst DATA_LABEL_PADDING = 0.05;\n\nconst SEPARATOR = {\n    V: \" //VSEP// \",\n    H: \" --HSEP-- \",\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n/*\n*****************\nThis highchart is based on a heatmap, i.e. the chart is divided into a set of X * Y equally sized cells.\n* The first column(s) of the cells are used to show the vertical categories (categoriesVertical), which are provided as separate \"category\" series\n* The first row(s) of the cells are used to show the horizontal categories (categoriesHorizontal), which are provided as separate \"category\" series\n* The rest of the cells represent the data itself\n    * each cell can be identified by its set of vertical and horizontal categories saved as 'key' in the 'keys'-array in the form of a string like \"X Cat Level 1 - X Cat Level 2 / Y Cat Level 1 - Y Cat Level 2 - Y Cat Level 3\" (in theory the levels can be \"dynamic\", which is not used in this specific example. In this example only 1 level is used)\n    * for each cell the number of entities to be shown is counted as 'value' in the 'values'-array.\n    * the entities for each cell are represented as boxes/cards within the cell and are pushed as separate serie to the main data series\n    * dependencies between entities are represented as separate spline series, whereas start and end point of the splines are the left or right edge of the corresponding entity boxes/cards on the map\n\n/***** config options *****/\n\nfunction main() {\n    const ctx = fetchData(Array.from(pages));\n\n    if (ctx.capabilities.length === 0 || ctx.periods.length === 0) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n\n    generateMatrix(ctx);\n\n    const chart = generateChartConfig(ctx);\n\n    return chart;\n}\n// @ts-ignore\nreturn main();\n//--------------------------------------------------------------------------------------//\n//                                    Data Fetching                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Fetches all required data\n * @param {Page[]} searchResults\n * @returns {Context}\n */\nfunction fetchData(searchResults) {\n    const capabilities = searchResults.filter((page) => page.getBuiltinFeatureValue(\"customType\") === TYPE_CAPABILITY.TYPE);\n    const missinCapabilities = getMissingCapabilities(capabilities);\n    capabilities.push(...missinCapabilities);\n    log(`Added ${missinCapabilities.length} missing items that the input items depend on.`);\n\n    const periods = getAllPeriods(capabilities);\n    log(\"Periods: \" + periods.length);\n\n    const programs = getPrograms(capabilities);\n    const milestones = getSafeMilestones(periods);\n    const dependencies = getDependencies(capabilities);\n\n    const capabilitiesById = capabilities.reduce((acc, capability) => {\n        acc[capability.getId()] = { x: 0, y: 0, capability };\n        return acc;\n    }, {});\n\n    const ctx = {\n        matrixData: undefined,\n        capabilities,\n        capabilitiesById,\n        periods,\n        programs,\n        milestones,\n        dependencies,\n        maxHeight: 1,\n    };\n    return ctx;\n}\n\n/**\n * Searches dependencies of the capabilities and returns those capabilities that are not yet included\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @return {Page<'cf.cplace.solution.safe.capability'>[]}\n */\nfunction getMissingCapabilities(capabilities) {\n    // @ts-ignore\n    const newCapabilities = new HashSet();\n    capabilities.forEach((item) => {\n        // @ts-ignore\n        const dependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n        dependencies.forEach((itemDependency) => {\n            const capability = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n            if (isPageOfType(capability, TYPE_CAPABILITY.TYPE)) {\n                newCapabilities.add(capability);\n            }\n        });\n    });\n    return Array.from(newCapabilities).filter((a) => !capabilities.some((b) => b.getId() === a.getId()));\n}\n\n/**\n * Determines the periods used as columns of the board\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities Capabilities\n * @returns {Page<'cf.cplace.solution.safe.programIncrement'>[]} PIs in chronological order\n */\nfunction getAllPeriods(capabilities) {\n    // @ts-ignore\n    const periodsSet = new HashSet();\n    capabilities.forEach((item) => {\n        const pi = item.get(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT);\n        if (!pi) {\n            return;\n        }\n        periodsSet.add(pi);\n    });\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>[]} */\n    const periods = Array.from(periodsSet);\n    return periods.sort((a, b) =>\n        // @ts-ignore\n        a.get(TYPE_PROGRAM_INCREMENT.ATTR.START).isBefore(b.get(TYPE_PROGRAM_INCREMENT.ATTR.START)) ? -1 : 1\n    );\n}\n/**\n * Gets all dependencies of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities Capabilities\n * @returns {Page<'cf.cplace.solution.safe.dependency'>[]} PIs in chronological order\n */\nfunction getDependencies(capabilities) {\n    const dependencies = [];\n    capabilities.forEach((capabilitiy) => {\n        const itemDependencies = Array.from(\n            // @ts-ignore\n            capabilitiy.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []\n        );\n        dependencies.push(...itemDependencies);\n    });\n    return dependencies;\n}\n/**\n *\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>[]} programmIncrements\n * @returns\n */\nfunction getSafeMilestones(programmIncrements) {\n    const periodStartDate =\n        // @ts-ignore\n        programmIncrements.length > 0 ? programmIncrements[0].get(TYPE_PROGRAM_INCREMENT.ATTR.START) : new DateTime();\n    const periodEndDate =\n        programmIncrements.length > 0\n            ? programmIncrements[programmIncrements.length - 1].get(TYPE_PROGRAM_INCREMENT.ATTR.END)\n            : // @ts-ignore\n              new DateTime();\n    const safeMilestoneSearch = new Search();\n    safeMilestoneSearch.add(Filters.embeddingSpace());\n    safeMilestoneSearch.add(Filters.type(TYPE_MILESTONE.TYPE));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).gte(periodStartDate));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).lte(periodEndDate));\n    safeMilestoneSearch.addBuiltinAttributeSort(TYPE_MILESTONE.ATTR.DATE, true);\n    const safeMilestones = safeMilestoneSearch.findAllPages();\n    // @ts-ignore\n    return Array.from(safeMilestones);\n}\n/**\n * Get all the programs of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @returns {Page<'cf.cplace.solution.safe.program'>[]}\n */\nfunction getPrograms(capabilities) {\n    // @ts-ignore\n    const programSet = new HashSet();\n    capabilities.forEach((item) => {\n        const programs = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n        if (!programs) {\n            return;\n        }\n        cplace.each(programs, (program) => programSet.add(program));\n    });\n    /** @type {Page<'cf.cplace.solution.safe.program'>[]} */\n    const programms = Array.from(programSet)\n    return programms.sort((a,b) => a.getName().localeCompare(b.getName()));\n}\n\n/**\n * Generate the matrix\n * @param {Context} ctx\n */\nfunction generateMatrix(ctx) {\n    /** @type {MatrixData} */\n    const matrixData = {\n        headerRow: ctx.periods.map((pi, index) => ({ programIncrement: pi, x: index + 2, y: 1 })),\n        milestoneRow: ctx.milestones,\n        programms: {},\n        capabilities: {},\n    };\n    let yOffset = 3;\n    ctx.programs.forEach((program) => {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n\n        const capabilitiesByPi = ctx.periods.map((programIncrement, indexPI) => {\n            const filteredCapabilities = ctx.capabilities.filter((capability) => {\n                const programIds = capability.get(TYPE_CAPABILITY.ATTR.PROGRAM)?.map((p) => p.getId()) || [];\n                // Get all capabilities that are associated to the current programm & the current program increment\n                return programIds.includes(program.getId()) && capability.getOptional(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT).getId() === programIncrement.getId();\n            });\n            // Check if the number of capabilities for this PI is the largest\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        // Iterate over the programm Increments to put the capabilities in the right place\n        matrixData.programms[program.getName()] = {\n            program,\n            data: capabilitiesByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: program.getId(),\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: program.getId(),\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight; //+ (rowHeight - 1) / 2;\n    });\n\n    const capabilitiesWithoutProgram = ctx.capabilities.filter(\n        (capability) =>\n            // @ts-ignore\n            !capability.get(TYPE_CAPABILITY.ATTR.PROGRAM) || capability.get(TYPE_CAPABILITY.ATTR.PROGRAM).length === 0\n    );\n\n    // Check if there are any capabilities without a programm and add them to the matrix\n    if (capabilitiesWithoutProgram.length > 0) {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n        // Ad capabilities without a program\n        const capabilitiesWithoutProgrammByPi = ctx.periods.map((programIncrement) => {\n            const filteredCapabilities = capabilitiesWithoutProgram.filter(\n                (capability) => capability.getOptional(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT).getId() === programIncrement.getId()\n            );\n\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        matrixData.programms[\"w/o Program\"] = {\n            program: null,\n            data: capabilitiesWithoutProgrammByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesWithoutProgrammByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: \"w/o Program\",\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: \"w/o Program\",\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight;\n    }\n    ctx.maxHeight = yOffset;\n    ctx.matrixData = matrixData;\n}\n/**\n *\n * @param {Context} ctx\n */\nfunction transformMatrixDataIntoSeries(ctx) {\n    const matrixData = ctx.matrixData;\n\n    const series = [];\n\n    if (!matrixData) {\n        return series;\n    }\n\n    // 1. Add PIs\n    series.push(\n        ...matrixData.headerRow.map((headerEntry, index) => {\n            return {\n                name: headerEntry.programIncrement.getName(),\n                colsize: 1,\n                rowsize: 1,\n                dataLabels: { rotation: 0, color: \"#000000\" },\n                enableMouseTracking: false,\n                data: [\n                    {\n                        x: headerEntry.x,\n                        y: headerEntry.y,\n                        value: 1,\n                        name: `<a href=\"${headerEntry.programIncrement.getUrl()}\">${headerEntry.programIncrement.getName()}</a>`,\n                        color: \"#dddddd\",\n                    },\n                ],\n            };\n        })\n    );\n\n    // 2. Add Milestones\n    series.push({\n        name: \"SAFe Milestones\",\n        colsize: 1,\n        rowsize: 1,\n        dataLabels: { rotation: 0, color: \"#000000\" },\n        enableMouseTracking: false,\n        data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n    });\n\n    let top = true;\n    const safeMilestoneData = [];\n\n    matrixData.milestoneRow.forEach((safeMilestone) => {\n        const safeMilestoneName = safeMilestone.getName();\n        const safeMilestoneDate = safeMilestone.get(TYPE_MILESTONE.ATTR.DATE);\n        // @ts-ignore\n        const safeMilestoneDateString = safeMilestoneDate?.toString(\"dd.MM.yyyy\");\n        // get milestone Position\n        // @ts-ignore\n        const safeMilestonePosition = getDatePosition(safeMilestoneDate.getMillis(), ctx);\n        // add milestone only if position is not null\n        if (safeMilestonePosition > 0) {\n            safeMilestoneData.push({\n                x: safeMilestonePosition,\n                y: 2,\n                name: '<a href=\"' + safeMilestone.getUrl() + '\">' + safeMilestoneName + \"</a>\",\n                value: safeMilestoneDateString,\n                dataLabels: {\n                    verticalAlign: top ? \"top\" : \"bottom\",\n                },\n            });\n            top = !top;\n        }\n    });\n\n    series.push({\n        type: \"scatter\",\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        data: safeMilestoneData,\n        marker: {\n            fillColor: COLORS.SAFE_MILESTONE,\n        },\n    });\n\n    // 3. Add Programms\n    let rowHeight = 2.5;\n    Object.keys(matrixData.programms).forEach((programName) => {\n        const data = matrixData.programms[programName];\n        // Add the Programms\n        series.push({\n            name: programName,\n            rowsize: data.rowHeight,\n            dataLabels: { rotation: 0, color: \"#000000\" },\n            enableMouseTracking: false,\n            data: [\n                {\n                    x: data.x,\n                    y: data.y,\n                    value: 1,\n                    name: `<a href=\\\"${data.program?.getUrl() || \"wip\"}\\\">${programName}</a>`,\n                    color: \"#dddddd\",\n                },\n            ],\n        });\n        // Add the capabilities of the programm\n        data.data.map((capabilitiesByPI, indexPI) => {\n            series.push({\n                name: programName + indexPI,\n                rowsize: CAPABILITY_HEIGHT,\n                colsize: 0.8,\n                dataLabels: { rotation: 0, color: \"#000000\", overflow: \"justify\" },\n                enableMouseTracking: false,\n                data: capabilitiesByPI.map((capabilityId, indexCapability) => {\n                    const capabilityData = matrixData.capabilities[capabilityId].filter((c) => c.programId === (data.program ? data.program.getId() : \"w/o Program\"))[0];\n                    const capability = capabilityData.capability;\n                    const isEnabler = capability.get(TYPE_CAPABILITY.ATTR.TYPE) === \"enabler\";\n                    return {\n                        x: capabilityData.x,\n                        y: capabilityData.y,\n                        value: 1,\n                        name: `<a href=\\\"${capability.getUrl() || \"wip\"}\\\">${limitStringSize(capability.getName(), 40)}</a>`,\n                        color: isEnabler ? \"#ffc80c\" : \"#0aa5ff\",\n                    };\n                }),\n            });\n        });\n        rowHeight += data.rowHeight;\n    });\n\n    // 4. Add Dependencies\n    ctx.dependencies.forEach((dependency) => {\n        const from = dependency.get(TYPE_DEPENDENCY.ATTR.B);\n        const to = dependency.get(TYPE_DEPENDENCY.ATTR.A);\n        if (!from || !to) {\n            return;\n        }\n        const fromId = from.getId();\n        const toId = to.getId();\n\n        const fromCapabilities = ctx.matrixData?.capabilities[fromId];\n        const toCapabilities = ctx.matrixData?.capabilities[toId];\n\n        if (!fromCapabilities) {\n            return;\n        }\n        const maxValue = ctx.maxHeight;\n        fromCapabilities.forEach((fromCapabilityData) => {\n            let x1 = fromCapabilityData.x;\n            let y1 = fromCapabilityData.y;\n            // y1 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n            if (!toCapabilities) {\n                return;\n            }\n            toCapabilities.forEach((toCapabilityData) => {\n                let x2 = toCapabilityData.x;\n                let y2 = toCapabilityData.y;\n                // y2 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n                const description = dependency.get(TYPE_DEPENDENCY.ATTR.DESCRIPTION) || \" \";\n                const dependencyType = dependency.get(TYPE_DEPENDENCY.ATTR.TYPE);\n                const status = dependency.get(TYPE_DEPENDENCY.ATTR.STATUS);\n                const dependencySeries = {\n                    type: \"spline\",\n                    name: \"<b>\" + to.getName() + \"</b><br/>relates to:<br/>\" + from.getName() + \"<br>\" + description,\n                    lineWidth: 1.5,\n                    color: COLORS.DEPEND,\n                    dashStyle: \"shortdot\",\n                    findNearestPointBy: \"xy\",\n                    data: [\n                        { x: x1 + 0.4, y: y1 },\n                        { x: x1 + 0.45, y: y1 === y2 ? y1 + 0.02 : y1 },\n                        { x: x2 - 0.45, y: y1 === y2 ? y2 - 0.02 : y2 },\n                        { x: x2 - 0.4, y: y2, marker: { enabled: true, symbol: \"diamond\" } },\n                    ],\n                };\n                if (dependencyType === TYPE_DEPENDENCY.ENUM.TYPE.BLOCKED_BY) {\n                    dependencySeries.name = \"<b>\" + to.getName() + \"</b><br/>blocked by:<br/>\" + from.getName() + \"<br>\" + description;\n                    // @ts-ignore\n                    dependencySeries.dashStyle = null;\n                }\n                if (status === TYPE_DEPENDENCY.ENUM.STATUS.CONFLICT) {\n                    dependencySeries.color = COLORS.DEPEND_HIGHLIGHT;\n                } else if (status === TYPE_DEPENDENCY.ENUM.STATUS.RESOLVED) {\n                    dependencySeries.color = COLORS.DEPEND_RESOLVED;\n                }\n                series.push(dependencySeries);\n            });\n        });\n    });\n\n    return series;\n}\n\n//--------------------------------------------------------------------------------------//\n//                                     Chart Config                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n *\n * @param {Context} ctx\n */\nfunction generateChartConfig(ctx) {\n    if (!ctx.matrixData) {\n        return;\n    }\n    const series = transformMatrixDataIntoSeries(ctx);\n    // @ts-ignore\n    const today = new DateTime();\n    let todayPosition = getDatePosition(today.getMillis(), ctx);\n\n    return {\n        chart: {\n            type: \"heatmap\",\n            marginTop: 0,\n            marginBottom: 0,\n            plotBorderWidth: 0,\n            scrollablePlotArea: {\n                minHeight: 1200,\n                minWidth: 1000,\n            },\n        },\n        title: {\n            text: null,\n        },\n        xAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 0,\n            lineWidth: 0,\n            labels: {\n                enabled: false,\n            },\n            plotLines: [\n                {\n                    dashStyle: \"dash\",\n                    color: COLORS.TODAY_PLOTLINE,\n                    width: 2,\n                    value: todayPosition,\n                    zIndex: 1,\n                },\n            ],\n        },\n        yAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 1,\n            tickInterval: 1,\n            lineWidth: 0,\n            min: 1,\n            max: ctx.maxHeight,\n            labels: {\n                enabled: false,\n            },\n            reversed: true,\n            scrollbar: {\n                enabled: true,\n            },\n            plotBands: [\n                {\n                    color: COLORS.MILESTONE_PLOTBAND,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    from: 1.5,\n                    to: 2.5,\n                    zIndex: 0,\n                },\n                // {\n                //     color: COLORS.RELEASE_PLOTBAND,\n                //     borderColor: 'white',\n                //     borderWidth: 2,\n                //     from: 1.5,\n                //     to: 2.5,\n                //     zIndex: 0\n                // }\n            ],\n        },\n        colors: [\"#D5001C\", \"#92D050\"],\n        colorAxis: {\n            dataClassColor: \"category\",\n            dataClasses: [\n                {\n                    to: 0.5,\n                },\n                {\n                    from: 0.5,\n                },\n            ],\n        },\n        legend: {\n            enabled: false,\n        },\n        tooltip: {\n            useHTML: true,\n            followPointer: false,\n        },\n        plotOptions: {\n            series: {\n                borderColor: \"#ffffff\",\n                borderWidth: 2,\n                dataLabels: {\n                    allowOverlap: false,\n                    inside: true,\n                    crop: true,\n                    overflow: \"justify\",\n                    position: \"left\",\n                    shape: \"circle\",\n                    enabled: true,\n                    color: \"#000000\",\n                    format: \"{point.name}\",\n                    style: {\n                        textOutline: \"none\",\n                        textOverflow: \"clip\",\n                    },\n                },\n                stickyTracking: false,\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b>\",\n                    findNearestPointBy: \"xy\",\n                },\n                states: {\n                    inactive: {\n                        opacity: 1,\n                    },\n                },\n            },\n            spline: {\n                tooltip: {\n                    headerFormat: \"{series.name}\",\n                    pointFormat: \"\",\n                    findNearestPointBy: \"xy\",\n                },\n                marker: {\n                    enabled: false,\n                    fillColor: COLORS.DEPEND,\n                    radius: 6,\n                    states: {\n                        hover: {\n                            enabled: false,\n                        },\n                    },\n                },\n            },\n            scatter: {\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b><br>{point.value}\",\n                    findNearestPointBy: \"xy\",\n                },\n                dataLabels: {\n                    enabled: true,\n                },\n                marker: {\n                    enabled: true,\n                    symbol: \"diamond\",\n                    radius: 10,\n                    states: {\n                        hover: {\n                            enabled: true,\n                        },\n                    },\n                },\n            },\n        },\n        series: series,\n        // series: [\n        //     {\n        //         name: \"PI 22.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 2,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/1bk9kpxn7s36vz3w80ji7t5oo/PI-22.4\">PI 22.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 3,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4l6jbaa8qgzinif5qetj499g5/PI-23.1\">PI 23.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.2\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 4,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/tksr708c2119mek2pzzopu9qb/PI-23.2\">PI 23.2</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.3\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 5,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/i4o8azmi8m0oqvqqu3hejgu80/PI-23.3\">PI 23.3</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 6,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/nrymz33xo7ew3x6qcgdk3fl7l/PI-23.4\">PI 23.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 24.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 7,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/0wtzrg3m4bdpfhut5xbgiza73/PI-24.1\">PI 24.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"SAFe Milestones\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n        //     },\n        //     {\n        //         name: \"Smart Infotainment\",\n        //         rowsize: 2,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 3.5,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/qg000odouviwwtx4rz2bvaoi8/Smart-Infotainment\">Smart Infotainment</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"Powertrain and Safety\",\n        //         rowsize: 4,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 5 + (4-1)/2,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4flf7a0349c5ximei6olrhife/Powertrain-and-Safety\">Powertrain and Safety</a>',\n        //                 color: \"red\",\n        //             },\n        //         ],\n        //     },\n        // ],\n    };\n}\n\n//--------------------------------------------------------------------------------------//\n//                                        Utils                                         //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Limit string to specified size\n * @param {string} str\n * @param {number} maxSize\n * @returns\n */\nfunction limitStringSize(str, maxSize) {\n    if (str.length > maxSize) {\n        return str.substring(0, maxSize - 3) + \"...\";\n    }\n    return str;\n}\n\n/**\n *\n * @param {number} date\n * @param {Context} ctx\n * @returns\n */\nfunction getDatePosition(date, ctx) {\n    let xPosition = 0;\n    ctx.periods.every((pi, idx) => {\n        // @ts-ignore\n        let categoryStartDate = pi.get(TYPE_PROGRAM_INCREMENT.ATTR.START)?.getMillis();\n        // @ts-ignore\n        let categoryEndDate = pi.get(TYPE_PROGRAM_INCREMENT.ATTR.END)?.getMillis();\n\n        // Check whether release date lies in between start and end date of category\n        if (categoryStartDate && categoryEndDate && date >= categoryStartDate && date <= categoryEndDate) {\n            // find x-Value of category and subtract 0.5 for starting point as offset\n            let x = idx + 2 - 0.5;\n            // calculate the relative position of date between Category StartDate and EndDate and add it to the offset value\n            xPosition = x + (date - categoryStartDate) / (categoryEndDate - categoryStartDate);\n            // exit the every loop\n            return false;\n        }\n        // continue the every loop\n        return true;\n    });\n    // if there was no match, just return null\n    return xPosition;\n}\n\n/**\n * Checks if a cplace page is of the specified type\n * @param {Page} page\n * @param {string} type\n * @returns {boolean}\n */\nfunction isPageOfType(page, type) {\n    return page.getBuiltinFeatureValue(\"customType\") === type;\n}\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    const logOutput = typeof text !== \"string\" ? JSON.stringify(text) : text;\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType cf.cplace.solution.safe.solution\n * @layout default layout\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Displays the timeline with Programm Increments, Safe Events and Safe Milestones. Chart is zoomable and draggable\n */\n\n// set the distinguishing log name\ncplace.setLogName(\"Highcharts - Timeline Overview\");\n\n/***** Start configuration *****/\nconst chartBackgroundColor = \"#FFFFFF\";\nconst lineColor = \"#303038\";\n\nconst piColor = \"#dddddd\";\nconst safeMilestoneColor = \"#3D8F8C\";\nconst eventColor = \"#366C81\";\n\nconst milestonePlotBandColor = \"#E2F3F2\";\nconst eventPlotBandColor = \"#E2EEF3\";\nconst todayPlotline = \"lightgrey\";\n\nconst showMonthsBeforeToday = 3;\nconst showMonthsAfterToday = 9;\n/***** End configuration *****/\n\nconst MILESTONE = {\n    TYPE: \"cf.milestone\",\n    ATTR: {\n        SCHEDULE: \"containingSchedule\",\n        DATE: \"date\",\n        FEATURE_DEPENDENCY: \"cf.cplace.solution.safe.dependency\",\n        TASKCLASS: \"activityClass\",\n    },\n};\nconst FEATURE = {\n    TYPE: \"cf.cplace.solution.safe.feature\",\n    ATTR: {\n        PROGRAM: \"cf.cplace.solution.safe.program\",\n    },\n};\nconst SCHEDULE = {\n    TYPE: \"cf.schedule\",\n    ATTR: {},\n};\nconst TASK_CLASS = {\n    TYPE: \"cf.activityClass\",\n    ATTR: {\n        COLOR: \"barColor\",\n        BORDERCOLOR: \"borderColor\",\n        SHAPE: \"milestoneShape\",\n    },\n};\nconst SAFE_MILESTONE = {\n    TYPE: \"cf.cplace.solution.safe.safeMilestone\",\n    ATTR: {\n        DATE: \"cf.cplace.solution.safe.date\",\n    },\n};\nconst PI = {\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START: \"cf.cplace.solution.safe.startDate\",\n        END: \"cf.cplace.solution.safe.endDate\",\n    },\n};\nconst EVENT = {\n    TYPE: \"cf.cplace.solution.safe.event\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        SOLUTION: \"cf.cplace.solution.safe.solution\",\n    },\n};\n\nfunction main() {\n    /** @type {ChartContext} */\n    const context = {\n        today: new Date(),\n        start: getStartDate(showMonthsBeforeToday),\n        end: getEndDate(showMonthsAfterToday),\n        solution: embeddingPage.get('cf.cplace.solution.safe.parent'),\n        schedules: [],\n        programIncrements: [],\n        events: [],\n        safeMilestones: [],\n        series: [],\n        plotlines: [],\n        categories: [\"<b>Program Increments</b>\", \"<b>Events</b>\", \"<b>SAFe Milestones</b>\"],\n        yIndex: 0,\n    };\n\n    categorizeData(pages, context);\n    createPiSeries(context);\n    createEventSeries(context);\n    createMilestoneSeries(context);\n    //create plotline between SAFe parts and schedules\n    //ctx.plotLines.push(createPlotline(yIndex - 0.5, 1.25));\n    createScheduleSeries(context);\n\n    return createChartConfig(context);\n}\n\n/**\n * Sort pages by their type and them to the context\n * @param {Page[]} pages\n * @param {ChartContext} ctx\n */\nfunction categorizeData(pages, ctx) {\n    cplace.each(pages, (page) => {\n        let type = page.getBuiltinFeatureValue(\"customType\");\n        if (type === SCHEDULE.TYPE) {\n            ctx.schedules.push(page);\n        } else if (type === PI.TYPE) {\n            ctx.programIncrements.push(page);\n        } else if (type === SAFE_MILESTONE.TYPE) {\n            ctx.safeMilestones.push(page);\n        } else if (type === EVENT.TYPE) {\n            ctx.events.push(page);\n        }\n    });\n}\n\n/**\n * Create pi series\n * @param {ChartContext} ctx\n */\nfunction createPiSeries(ctx) {\n    const piData = [];\n    cplace.each(ctx.programIncrements, (pi) => {\n        piData.push(createDataItem(pi.getName(), pi.get(PI.ATTR.START), pi.get(PI.ATTR.END), ctx.yIndex, piColor));\n    });\n    ctx.yIndex++;\n    ctx.series.push({\n        name: \"Program Increments\",\n        showInLegend: false,\n          tooltip: {\n            headerFormat: \"\",\n            pointFormat: \"<b>{point.name}</b><br/>Start: {point.x: %Y-%m-%d}<br/> End: {point.x2: %Y-%m-%d}\",\n            useHTML: true,\n        },\n        data: piData,\n        dataLabels: {\n            enabled: true,\n            format: \"<b>{point.name}</b>\",\n        },\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    });\n    return piData;\n}\n\n/**\n * Create event series\n * @param {ChartContext} ctx\n */\nfunction createEventSeries(ctx) {\n    let eventData = [];\n    cplace.each(ctx.events, (event) => {\n        eventData.push(\n            createDataItem(\n                event.getName(),\n                event.get(EVENT.ATTR.START_DATE),\n                event.get(EVENT.ATTR.END_DATE),\n                ctx.yIndex,\n                eventColor\n            )\n        );\n    });\n    ctx.yIndex++;\n    ctx.series.push({\n        name: \"Events\",\n        showInLegend: false,\n          tooltip: {\n            headerFormat: \"\",\n            pointFormat: \"<b>{point.name}</b><br/>Start: {point.x: %Y-%m-%d}<br/> End: {point.x2: %Y-%m-%d}\",\n            useHTML: true,\n        },\n        data: eventData,\n        dataLabels: {\n            enabled: true,\n            format: \"<b>{point.name}</b>\",\n        },\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    });\n}\n\n/**\n * Create safe milestone series\n * @param {ChartContext} ctx\n */\nfunction createMilestoneSeries(ctx) {\n    let safeMilestoneData = [];\n    cplace.each(ctx.safeMilestones, (safeMilestone) => {\n        safeMilestoneData.push(\n            createMilestoneDataItem(\n                safeMilestone.getName(),\n                safeMilestone.get(SAFE_MILESTONE.ATTR.DATE),\n                ctx.yIndex,\n                safeMilestoneColor,\n                safeMilestoneColor\n            )\n        );\n    });\n    ctx.yIndex++;\n    ctx.series.push(createMilestoneSerie(\"SAFe Milestones\", safeMilestoneData));\n}\n/**\n * Create Chart configuration\n * @param {ChartContext} ctx\n * @returns\n */\nfunction createChartConfig(ctx) {\n    return {\n        chart: {\n            type: \"xrange\",\n            backgroundColor: chartBackgroundColor,\n            panning: true,\n            panKey: \"shift\",\n            zoomType: \"x\",\n        },\n        title: {\n            text: \"\",\n        },\n        yAxis: {\n            title: {\n                text: \"\",\n            },\n            categories: ctx.categories,\n            reversed: true,\n            type: \"category\",\n            plotBands: [\n                {\n                    color: eventPlotBandColor,\n                    from: 0.5,\n                    to: 1.5,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    zIndex: 0,\n                },\n                {\n                    color: milestonePlotBandColor,\n                    from: 1.5,\n                    to: 2.5,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    zIndex: 0,\n                },\n            ],\n        },\n        xAxis: {\n            type: \"datetime\",\n            min: Date.UTC(ctx.start.getFullYear(), ctx.start.getMonth(), ctx.start.getDate(), 0, 0, 0, 0),\n            max: Date.UTC(ctx.end.getFullYear(), ctx.end.getMonth(), ctx.end.getDate(), 23, 59, 59, 59),\n            plotLines: [\n                {\n                    dashStyle: \"dash\",\n                    color: todayPlotline,\n                    width: 2,\n                    value: Date.UTC(ctx.today.getFullYear(), ctx.today.getMonth(), ctx.today.getDate(), 0, 0, 0, 0),\n                    zIndex: 1,\n                },\n                ...ctx.plotlines,\n            ],\n        },\n        tooltip: {\n            enabled: true,\n        },\n        series: ctx.series,\n    };\n}\n\n/**\n * Create schedule series\n * @param {ChartContext} ctx\n */\nfunction createScheduleSeries(ctx) {\n    cplace.each(ctx.schedules, (schedule) => {\n        let relevantSchedule = false;\n        let scheduleData = [];\n        let milestones = schedule.getIncomingPages(MILESTONE.TYPE, MILESTONE.ATTR.SCHEDULE);\n        cplace.each(milestones, (milestone) => {\n            let featureDependency = milestone.get(MILESTONE.ATTR.FEATURE_DEPENDENCY);\n            let isProgramRelevant = false;\n            cplace.each(featureDependency, (feature) => {\n                let featureProgram = feature.get(FEATURE.ATTR.PROGRAM);\n                if (featureProgram && featureProgram.getId() === ctx.solution.getId()) {\n                    isProgramRelevant = true;\n                }\n            });\n            if (isProgramRelevant) {\n                relevantSchedule = true;\n                scheduleData.push(createScheduleMilestoneDataItem(milestone, ctx.yIndex));\n            }\n        });\n        if (relevantSchedule) {\n            ctx.categories.push(createCategory(schedule));\n            ctx.series.push(createMilestoneSerieSchedule(schedule.getName(), scheduleData));\n            ctx.yIndex++;\n        }\n    });\n}\n\n//FUNCTIONS\nfunction createDataItem(name, start, end, y, color) {\n    let startDate = new Date(start);\n    let endDate = new Date(end);\n    return {\n        name: name,\n        x: Date.UTC(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0, 0, 0),\n        x2: Date.UTC(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23, 59, 59, 99),\n        y: y,\n        color: color,\n    };\n}\n\nfunction getMilestoneShape(milestoneShape) {\n    if (milestoneShape === \"Diamond\") return \"diamond\";\n    if (milestoneShape === \"Arrow Up\") return \"diamond\";\n    if (milestoneShape === \"Arrow Down\") return \"diamond\";\n    if (milestoneShape === \"Triangle Up\") return \"triangle\";\n    if (milestoneShape === \"Triangle Down\") return \"triangle-down\";\n    if (milestoneShape === \"Triangle Left\") return \"triangle\";\n    if (milestoneShape === \"Triangle Right\") return \"triangle\";\n    if (milestoneShape === \"Circle\") return \"circle\";\n    if (milestoneShape === \"Square\") return \"square\";\n    if (milestoneShape === \"Star\") return \"diamond\";\n    if (milestoneShape === \"Ramp Down\") return \"diamond\";\n    if (milestoneShape === \"Ramp Up\") return \"diamond\";\n}\n\nfunction createMilestoneDataItem(name, date, y, color, borderColor) {\n    let milestoneDate = new Date(date);\n    return {\n        name: name,\n        x: Date.UTC(milestoneDate.getFullYear(), milestoneDate.getMonth(), milestoneDate.getDate(), 0, 0, 0, 0),\n        y: y,\n        marker: {\n            fillColor: color,\n            lineColor: borderColor,\n            lineWidth: 1,\n        },\n    };\n}\n\nfunction createScheduleMilestoneDataItem(milestone, y) {\n    let name = milestone.getName();\n    let milestoneDate = new Date(milestone.get(MILESTONE.ATTR.DATE));\n    let color = milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.COLOR);\n    let borderColor = milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.BORDERCOLOR);\n    let milestoneShape = getMilestoneShape(milestone.getOptional(MILESTONE.ATTR.TASKCLASS).get(TASK_CLASS.ATTR.SHAPE));\n    let features = milestone.get(MILESTONE.ATTR.FEATURE_DEPENDENCY);\n    let featureList = \"<b>Requested Features:</b>\";\n    cplace.each(features, (feature) => {\n        featureList = featureList + \"<br>\" + feature.getName();\n    });\n\n    return {\n        name: name,\n        x: Date.UTC(milestoneDate.getFullYear(), milestoneDate.getMonth(), milestoneDate.getDate(), 0, 0, 0, 0),\n        y: y,\n        features: featureList,\n        marker: {\n            fillColor: color,\n            lineColor: borderColor,\n            lineWidth: 1,\n            symbol: milestoneShape,\n        },\n    };\n}\n\nfunction createMilestoneSerie(name, dataSeries) {\n    return {\n        name: name,\n        type: \"scatter\",\n        //stickyTracking: false,\n        showInLegend: false,\n        marker: {\n            enabled: true,\n            symbol: \"diamond\",\n            lineWidth: 5,\n            radius: 12,\n        },\n        tooltip: {\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"{point.x: %Y-%m-%d}\",\n        },\n        data: dataSeries,\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    };\n}\n\nfunction createMilestoneSerieSchedule(name, dataSeries) {\n    return {\n        name: name,\n        type: \"scatter\",\n        //stickyTracking: false,\n        showInLegend: false,\n        marker: {\n            enabled: true,\n            symbol: \"diamond\",\n            lineWidth: 5,\n            radius: 12,\n        },\n        tooltip: {\n            useHTML: true,\n            headerFormat: \"<b>{point.key}</b><br>\",\n            pointFormat: \"{point.x: %Y-%m-%d}<br>{point.features}\",\n        },\n        data: dataSeries,\n        states: {\n            inactive: {\n                opacity: 1,\n            },\n        },\n    };\n}\n\nfunction createPlotline(value, width) {\n    return {\n        color: lineColor,\n        width: width,\n        value: value,\n        dashStyle: \"solid\",\n    };\n}\n\nfunction getStartDate(months) {\n    let today = new Date();\n    let startDate = today;\n    startDate.setMonth(today.getMonth() - months);\n    return startDate;\n}\n\nfunction getEndDate(months) {\n    let today = new Date();\n    let endDate = today;\n    endDate.setMonth(today.getMonth() + months);\n    return endDate;\n}\n\nfunction createCategory(object) {\n    let name = object.getName();\n    let url = object.getUrl();\n    return '<a href=\"' + url + '\">' + name + \"</a>\";\n}\n\n/**\n * Object containing context information for the chart.\n * @typedef {Object} ChartContext\n * @property {Date} today - The current date.\n * @property {Date} start - The start date for the chart.\n * @property {Date} end - The end date for the chart.\n * @property {Page} solution - The embeddingPage object representing the current solution.\n * @property {Page[]} schedules - An array of pages representing schedules.\n * @property {Page[]} programIncrements - An array of pages representing program increments.\n * @property {Page[]} events - An array of pages representing events.\n * @property {Page[]} safeMilestones - An array of pages representing SAFe milestones.\n * @property {any[]} series - An array of series\n * @property {any[]} plotlines - An array of plotlines\n * @property {string[]} categories - An array of categories\n * @property {number} yIndex - y-index\n */\n\n// @ts-ignore\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * @author Rakshit Midha\n * @description Creates Flow Distribution highchart\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\ncplace.setLogName('highchart-flow-distribution');\n\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY = {\n  TYPE: 'cf.cplace.solution.safe.capability',\n  ATTR: {\n    PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n    CAPABILITY_TYPE: {\n      INTERNAL_NAME: 'cf.cplace.solution.safe.capabilityType',\n      ENUM_VALUES: {\n        CAPABILITY: 'capability',\n        ENABLER: 'enabler'\n      }\n    }\n  }\n};\n\nconst COLUMN_COLOR1 = '#26285d';\nconst COLUMN_COLOR2 = '#b8d4fa';\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\nconst flowDistributionSeries = getFlowDistributionSeries(pages);\nconst categories = getCategories(flowDistributionSeries);\nconst transformedSeries = transformSeries(flowDistributionSeries)\n\nconst config = {\n  title: {\n    text: 'Flow Distribution'\n  },\n  chart: {\n    type: 'column',\n    spacingBottom: 25,\n    spacingTop: 20\n  },\n  legend: {\n    backgroundColor: 'white',\n    borderColor: '#CCC',\n    borderWidth: 1,\n    shadow: false\n  },\n  tooltip: {\n    headerFormat: '<b>{point.x}</b><br/>',\n    pointFormat: '{series.name}: {point.y}'\n  },\n  xAxis: {\n    categories: categories\n  },\n  yAxis: {\n    title: '',\n    labels: {\n      format: '{value}%',\n    },\n    allowDecimals: false,\n    max: 100\n  },\n  plotOptions: {\n    series: {\n      pointWidth: 40,\n    },\n    column: {\n      stacking: 'normal',\n    }\n  },\n  colors: [COLUMN_COLOR1, COLUMN_COLOR2],\n  series: transformedSeries\n}\n\nreturn config;\n\n/**\n * Creates a map of Capability and Enabler count for each Program Iteration\n */\nfunction getFlowDistributionSeries(pages) {\n  let series = [];\n  cplace.each(pages, programIncrement => {\n    const capabilities = programIncrement.getIncomingPages(CAPABILITY.TYPE, CAPABILITY.ATTR.PROGRAM_INCREMENT);\n    let enablerCount = 0;\n    let capabilitiesCount = 0;\n    cplace.each(capabilities, capability => {\n      const capabilityType = capability.get(CAPABILITY.ATTR.CAPABILITY_TYPE.INTERNAL_NAME);\n\n      if (capabilityType === CAPABILITY.ATTR.CAPABILITY_TYPE.ENUM_VALUES.ENABLER) {\n        enablerCount++\n      }\n      if (capabilityType === CAPABILITY.ATTR.CAPABILITY_TYPE.ENUM_VALUES.CAPABILITY) {\n        capabilitiesCount++\n      }\n    });\n\n    let seriesObject = {};\n    seriesObject['name'] = programIncrement.getName();\n    let totalCount = capabilitiesCount + enablerCount;\n    seriesObject['data'] = totalCount ? [(capabilitiesCount / totalCount) * 100, (enablerCount / totalCount) * 100] :\n      [0, 0]\n    series.push(seriesObject);\n  });\n\n  return series.sort(function (a, b) {\n    let x = a['name'];\n    let y = b['name'];\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\n/**\n * Computes the name of all Program Iterations\n */\nfunction getCategories(flowDistributionSeries) {\n  let categories = [];\n  flowDistributionSeries.forEach(seriesObject => {\n    categories.push(seriesObject['name']);\n  })\n  return categories;\n}\n\n/**\n * Transforms the Flow Distribution series to count of Capabilities and Enablers\n */\nfunction transformSeries(sortedFlowDistributionSeries) {\n  let series = [{'name': 'Capabilities', data: []}, {'name': 'Enablers', data: []}];\n  sortedFlowDistributionSeries.forEach(seriesObject => {\n    series[0]['data'].push(seriesObject['data'][0]);\n    series[1]['data'].push(seriesObject['data'][1]);\n  });\n  return series;\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * HIGHCHART\n * @customType cf.cplace.solution.safe.metricsDashboard\n * @layout cf.cplace.solution.safe.layout.flowEfficiency\n * @author Christopher W\u00f6lfle <christopher.woelfle@cplace.com>\n * @version 1.0\n * @description Displays a dummy flow efficiency chart\n */\n\nconst SEED = 1234;\n\nfunction generateDummyData() {\n    const efficiencies = [];\n    // Generate numbers in 0.05 intervals from 0 to 1\n    for (let i = 0; i <= 20; i++) {\n        efficiencies.push(i * 0.05);\n    }\n    const data = efficiencies.map((e) => ({\n        x: e*100,\n        y: getRandomNumber(0, Math.round(20 * (e + 0.01))),\n    }));\n\n    return data;\n}\n\nfunction main() {\n    const data = generateDummyData();\n    return generateConfig(data);\n}\n\nfunction generateConfig(data) {\n    return {\n        chart: {\n            type: \"column\",\n        },\n        title: {\n            text: \"Flow Efficiency\",\n        },\n        xAxis: {\n            title: {\n                text: \"Flow Efficiency\",\n            },\n            labels: {format: \"{value:.1f}%\"}\n        },\n        yAxis: {\n            title: {\n                text: \"Number of Capabilities\",\n            },\n            \n        },\n        tooltip: {\n            headerFormat: \"\",\n            pointFormat: \"<b>{point.y}</b><br/>capabilities with a flow efficiency of {point.x:.1f}%\",\n        },\n        plotOptions: {\n            series: {\n                borderWidth: 0,\n                dataLabels: {\n                    enabled: true,\n                    format: \"{point.y}\",\n                },\n            },\n        },\n        series: [{ name: \"Flow Efficiency\", data }],\n    };\n}\n\nclass PseudoRandomNumberGenerator {\n    constructor(seed) {\n        this.a = 1664525;\n        this.c = 1013904223;\n        this.m = Math.pow(2, 32);\n        this.seed = seed;\n    }\n\n    random() {\n        this.seed = (this.a * this.seed + this.c) % this.m;\n        return this.seed / this.m;\n    }\n}\n\nconst prng = new PseudoRandomNumberGenerator(SEED);\n\nfunction getRandomNumber(min, max) {\n    // Calculate the range of the random number\n    const range = max - min;\n\n    // Generate a random number within the range\n    const randomNumber = prng.random() * range + min;\n\n    // Round the random number to the nearest integer\n    const roundedNumber = Math.round(randomNumber);\n\n    return roundedNumber;\n}\n\n// @ts-ignore\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * @author Nepomuk Heimberger\n * @description Creates Flow Predictability highchart\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\ncplace.setLogName('highchart-flow-predictability');\n\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst OBJECTIVE = {\n  TYPE: 'cf.cplace.solution.safe.objective',\n  ATTR: {\n    PROGRAM_INCREMENT: 'cf.cplace.solution.safe.timebox',\n    BUSINESS_VALUE: 'cf.cplace.solution.safe.businessValue',\n    ACTUAL_VALUE: 'cf.cplace.solution.safe.actualValue',\n    COMMITMENT: {\n      INTERNAL_NAME: 'cf.cplace.solution.safe.commitment',\n      ENUM_VALUES: {\n        COMMITTED: '#15 - Committed',\n        UNCOMMITTED: '#25 - Uncommitted'\n      }\n    },\n     SAFE_LEVEL: {\n      INTERNAL_NAME: 'cf.cplace.solution.safe.SAFeLevel',\n      ENUM_VALUES: {\n        SOLUTION: '#15 - Solution',\n        PROGRAM: '#25 - Program',\n        TEAM: '#35 - Team'\n      }\n    }\n  }\n};\n\n\nconst COLUMN_COLOR1 = '#26285d';\nconst COLUMN_COLOR2 = '#b8d4fa';\nconst LINE_COLOR = '#368F8B';\nconst LINE_COLOR_2 = '#155451';\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n\nconst flowPredictabilitySeries = getFlowPredictabilitySeries(pages);\nconst sortedSeries = sortSeriesByName(flowPredictabilitySeries);\nconst categories = getCategories(sortedSeries);\nconst transformedSeries = transformSeries(sortedSeries);\n\nconst config = {\n  title: {\n    text: 'Flow Predictability Measure'\n  },\n  xAxis: {\n    categories: categories,\n    title: {\n      text: ''\n    }\n  },\n  yAxis: [{\n    title: {\n      text: 'Objectives Achieved'\n    },\n    allowDecimals: false,\n  },\n  {\n    title: {\n      text: 'Predictability',\n      style: {\n        color: LINE_COLOR\n      },\n    },\n    labels: {\n      style: {\n        color: LINE_COLOR\n      },\n    },    \n    plotLines: [{\n      color: LINE_COLOR_2,\n      value: 80,\n      width: '1',\n      dashStyle: 'LongDash',\n      zIndex: 4\n    },\n    {\n      color: LINE_COLOR_2,\n      value: 100,\n      width: '1',\n      dashStyle: 'LongDash',\n      zIndex: 4\n    }],\n    opposite: true\n  }],\n  plotOptions: {\n    series: {\n      pointWidth: 50\n    }\n  },\n  colors: [COLUMN_COLOR1, COLUMN_COLOR2],\n  series: Object.values(transformedSeries)\n}\n\nreturn config;\n\n\n\n/**\n * Creates an array of a map of Program Iteration names and program predictability measure\n */\nfunction getFlowPredictabilitySeries(pages) {\n  let piSeries = []; //[{'name': '', 'values': []}]\n\n  cplace.each(pages, programIncrement => {\n    const objectives = programIncrement.getIncomingPages(OBJECTIVE.TYPE, OBJECTIVE.ATTR.PROGRAM_INCREMENT);\n    let totalBusinessValue = 0\n    let totalActualValue = 0\n    cplace.each(objectives, objective => {\n      const safeLevel = objective.get(OBJECTIVE.ATTR.SAFE_LEVEL.INTERNAL_NAME);\n      if (safeLevel === OBJECTIVE.ATTR.SAFE_LEVEL.ENUM_VALUES.SOLUTION) {\n        const commitment = objective.get(OBJECTIVE.ATTR.COMMITMENT.INTERNAL_NAME);\n        if (commitment === OBJECTIVE.ATTR.COMMITMENT.ENUM_VALUES.COMMITTED) {\n          totalBusinessValue += objective.get(OBJECTIVE.ATTR.BUSINESS_VALUE);\n        }\n        totalActualValue += objective.get(OBJECTIVE.ATTR.ACTUAL_VALUE);\n      }\n    });\n\n    let seriesObject = {};\n    seriesObject['name'] = programIncrement.getName();\n    const flowPredictabilityMeasure = totalBusinessValue ? Math.round((totalActualValue / totalBusinessValue) * 100) * 100 / 100 : 0;\n    seriesObject['values'] = [flowPredictabilityMeasure, totalBusinessValue, totalActualValue]\n    piSeries.push(seriesObject);\n  });\n\n  return piSeries;\n}\n/**\n * Computes the name of all Program Iterations\n */\nfunction getCategories(flowDistributionSeries) {\n  let categories = [];\n  flowDistributionSeries.forEach(seriesObject => {\n    categories.push(seriesObject['name']);\n  })\n  return categories;\n}\n\n/**\n * Transforms the array of series objects to the actual highchart configuration series\n */\nfunction transformSeries(series) {\n  let flowPredictabilitySeries = {\n    flowPredictabilityMeasure: {type: 'spline', 'name': 'Flow Predictability Measure', yAxis:1, data: [],tooltip: {valueSuffix: ' %'}, color: LINE_COLOR},\n    totalBusinessValue: {type: 'column', name: 'Planned Business Value', yAxis:0, data: []},\n    actualBusinessValue: {type: 'column', name: 'Actual Business Value', yAxis:0, data: []},\n    // percentageDottedLine80: {type: 'spline', dashStyle: 'shortdot', data: []},\n    // percentageDottedLine100: {type: 'spline', dashStyle: 'shortdot', data: []}\n  };\n\n  series.forEach(seriesObject => {\n    flowPredictabilitySeries['flowPredictabilityMeasure']['data'].push(seriesObject['values'][0]);\n    flowPredictabilitySeries['totalBusinessValue']['data'].push(seriesObject['values'][1]);\n    flowPredictabilitySeries['actualBusinessValue']['data'].push(seriesObject['values'][2]);\n    // flowPredictabilitySeries['percentageDottedLine80']['data'].push(80);\n    // flowPredictabilitySeries['percentageDottedLine100']['data'].push(100);\n  });\n\n  return flowPredictabilitySeries;\n}\n\n/**\n * Sorts the series by name\n */\nfunction sortSeriesByName(series) {\n  return series.sort(function (a, b) {\n    let x = a['name'];\n    let y = b['name'];\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n/**\n * Returns an array of all IDs of the pages\n */\nfunction getPagesUids(pages) {\n    let pagesUids = [];\n    cplace.each(pages, page => {\n        pagesUids.push(page.getId())\n    })\n    return pagesUids;\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * @author Rakshit Midha\n * @description Creates Flow Time highchart\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\ncplace.setLogName('highchart-flow-time');\n\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY = {\n  TYPE: 'cf.cplace.solution.safe.capability',\n  ATTR: {\n    'FLOW_TIME': 'cf.cplace.solution.safe.flowTime'\n  }\n};\n\nconst COLUMN_COLOR = '#26285d';\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\nconst flowTimeData = getFlowTimeData(pages);\nconst sortedFlowTimeData = sortFlowTimeData(flowTimeData);\nconst seriesData = createSeriesData(sortedFlowTimeData);\nconst averageCapabilities = calculateAverageCapabilities(seriesData)\n\nconst config = {\n  title: {\n    text: 'Flow Time'\n  },\n  legend: {enabled: false},\n  chart: {\n    type: 'column',\n    spacingBottom: 25,\n    spacingTop: 20\n  },\n  tooltip: {\n    headerFormat: null,\n    pointFormat: 'Capability Count: {point.y}'\n  },\n  xAxis: {\n    plotLines: [{\n      color: 'red',\n      value: averageCapabilities,\n      width: '1',\n      dashStyle: 'LongDash',\n      zIndex: 4,\n      label: {\n        x: -15,\n        text: '<span style=\"font-size:12px;\">Average: ' + averageCapabilities + '</span>'\n      },\n    }],\n    title: {\n      text: 'Flow Time (days)'\n    },\n    gridLineColor: '#68686CFF',\n    gridLineWidth: 0.3,\n    tickLength: 0,\n    tickInterval: 5,\n  },\n  yAxis: {\n    title: {\n      text: 'Capability Count'\n    },\n    allowDecimals: false\n  },\n  plotOptions: {\n    series: {\n      pointWidth: 30,\n      color: COLUMN_COLOR\n    }\n  },\n  series: [{\n    data: Object.values(seriesData)\n  }]\n}\n\nreturn config;\n\n/**\n * Creates a map of Flow Time values along with the number of occurrences\n * @returns An object with Flow Time values as keys and number of occurrences as values\n */\nfunction getFlowTimeData(pages) {\n  let data = {};\n  cplace.each(pages, page => {\n    const flowTime = round5(page.get(CAPABILITY.ATTR.FLOW_TIME));\n    if (flowTime) {\n      let value = data[flowTime];\n\n      if (value) {\n        data[flowTime] = ++value;\n      } else {\n        data[flowTime] = 1;\n      }\n    }\n  });\n  return data;\n}\n\n/**\n * Round the number to the previous multiple of 5\n */\nfunction round5(x) {\n  return Math.ceil(x / 5) * 5;\n}\n\n/**\n * Sorts the Flow Time data in ascending order\n */\nfunction sortFlowTimeData(flowTimeData) {\n  return Object.keys(flowTimeData).sort().reduce(\n    (obj, key) => {\n      obj[key] = flowTimeData[key];\n      return obj;\n    },\n    {}\n  );\n}\n\n/**\n * Creates the series data for the highchart\n */\nfunction createSeriesData(data) {\n  const formattedData = [];\n  let keys = Object.keys(data), len = keys[keys.length - 1];\n\n  for (let i = 0; i <= len; i++) {\n    if (data[i]) {\n      formattedData.push(data[i])\n    } else {\n      formattedData.push(0)\n    }\n  }\n\n  return formattedData;\n}\n\nfunction calculateAverageCapabilities(transformedSeries) {\n  let totalDays = 0;\n  let capabilities = 0;\n  Object.values(transformedSeries).forEach(seriesData => {\n    if(seriesData) {\n      totalDays++;\n      capabilities+=seriesData;\n    }\n  });\n\n  return (Math.round(capabilities/totalDays * 100) / 100).toFixed(2);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/**\n * @author Rakshit Midha\n * @description Creates Flow Velocity highchart\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\ncplace.setLogName('highchart-flow-velocity');\n\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY = {\n  TYPE: 'cf.cplace.solution.safe.capability',\n  ATTR: {\n    PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n  }\n};\n\nconst COLUMN_COLOR = '#26285d';\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\nconst flowDistributionSeries = getFlowVelocitySeries(pages);\nconst categories = getCategories(flowDistributionSeries);\nconst transformedSeries = transformSeries(flowDistributionSeries);\nconst averageCapabilities = calculateAverageCapabilities(transformedSeries);\n\nconst config = {\n  title: {\n    text: 'Flow Velocity'\n  },\n  chart: {\n    type: 'column',\n    spacingBottom: 25,\n    spacingTop: 20\n  },\n  legend: {enabled: false},\n  tooltip: {\n    headerFormat: '<b>{point.x}</b><br/>',\n    pointFormat: 'Capabilities: {point.y}'\n  },\n  xAxis: {\n    categories: categories,\n    title: {\n      text: 'Program Iteration'\n    }\n  },\n  yAxis: {\n    plotLines: [{\n      color: 'red',\n      value: averageCapabilities,\n      width: '1',\n      dashStyle: 'LongDash',\n      zIndex: 4,\n      label: {\n        text: '<span style=\"font-size:12px;\">Average Velocity: ' + averageCapabilities + '</span>'\n      },\n    }],\n    title: {\n      text: 'Capabilities'\n    },\n    allowDecimals: false,\n  },\n  plotOptions: {\n    series: {\n      pointWidth: 40,\n      color: COLUMN_COLOR\n    },\n    column: {\n      dataLabels: {\n        enabled: true,\n        crop: false,\n        overflow: 'none'\n      }\n    }\n  },\n  series: [{\n    data: transformedSeries\n  }]\n}\n\nreturn config;\n\n/**\n * Creates an array of a map of Program Iteration names and Capability count\n */\nfunction getFlowVelocitySeries(pages) {\n  let series = [];\n  cplace.each(pages, programIncrement => {\n    const capabilities = programIncrement.getIncomingPages(CAPABILITY.TYPE, CAPABILITY.ATTR.PROGRAM_INCREMENT);\n    let capabilitiesCount = 0;\n    cplace.each(capabilities, () => capabilitiesCount++);\n\n    let seriesObject = {};\n    seriesObject['name'] = programIncrement.getName();\n    seriesObject['count'] = capabilitiesCount;\n    series.push(seriesObject);\n  });\n\n  return series.sort(function (a, b) {\n    let x = a['name'];\n    let y = b['name'];\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\n/**\n * Computes the name of all Program Iterations\n */\nfunction getCategories(flowDistributionSeries) {\n  let categories = [];\n  flowDistributionSeries.forEach(seriesObject => {\n    categories.push(seriesObject['name']);\n  })\n  return categories;\n}\n\n/**\n * Transforms the Flow Velocity series to count of Capabilities\n */\nfunction transformSeries(sortedFlowDistributionSeries) {\n  let transformedSeries = [];\n  sortedFlowDistributionSeries.forEach(seriesObject => {\n    transformedSeries.push(seriesObject['count']);\n  });\n  return transformedSeries;\n}\n\nfunction calculateAverageCapabilities(transformedSeries) {\n  return (Math.round(transformedSeries.reduce( ( p, c ) => p + c, 0 ) / transformedSeries.length * 100) / 100).toFixed(2);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "cplace.setLogName('Current PI');\n//Configurations\nconst TIMELINE_DASHBOARD = {\n    TYPE:'cf.cplace.solution.safe.timelineDashboard',\n    ATTR:{\n      PARENT:'cf.cplace.solution.safe.parent'\n    }\n  }\n  \n  let finallink='';\n  let link, name;\n  let piDashboardSearch = new Search()\n    .add(Filters.space(embeddingPage.getSpaceId()))\n    .add(Filters.type(TIMELINE_DASHBOARD.TYPE))\n    .add(Filters.customAttributeNonempty(TIMELINE_DASHBOARD.ATTR.PARENT))\n    .findAllPages();\n\nlet result = Iterables.getFirst(piDashboardSearch, null);\n\nif (result) {\n    link = result.getUrl();\n    name = result.getName();\n}\n  \nreturn '<a href=\"'+link+'\"class=\"current-color\">Open Timeline Dashboard</a>';",
        "attributes": null,
        "type_name": null
    }
]