{
    "type": "custom_attribute",
    "code": "/**\n *\n */\n\nconst DEBUG = false;\n\nconst PROGRAM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        STATISTICS: \"cf.cplace.solution.safe.statsJson\",\n    },\n});\n\nfunction main() {\n    const teamIteration = Array.from(pages)[0];\n\n    if (teamIteration?.getBuiltinFeatureValue(\"customType\") !== PROGRAM_INCREMENT.TYPE) {\n        throw new Error(\"Please provide a single team iteration in the chart search.\");\n    }\n\n    let statistics = null;\n    try {\n        statistics = JSON.parse(teamIteration.get(PROGRAM_INCREMENT.ATTR.STATISTICS));\n        DEBUG && cplace.log(statistics);\n    } catch (e) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n\n    if (!statistics || !statistics.archive || !statistics.current) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n    const data = createData(teamIteration, statistics);\n\n    // Create the chart\n    return {\n        chart: {\n            type: \"line\",\n        },\n        title: {\n            text: \"Team Iteration Burn-Up Chart\",\n        },\n        xAxis: {\n            title: {\n                text: \"Day\",\n            },\n            categories: data.map((data) => data.day),\n        },\n        yAxis: {\n            title: {\n                text: \"Story Points\",\n            },\n        },\n        plotLines: [\n            {\n                color: \"#33ff33\",\n                width: 1,\n                zIndex: 9999,\n                value: 12,\n            },\n        ],\n        series: [\n            {\n                name: \"Ideal Burn-Up\",\n                data: data.map((data) => data.planned),\n                color: \"lightblue\",\n            },\n            {\n                name: \"Forecast\",\n                data: data.map((data) => data.forecast || data.actual),\n                color: {\n                    pattern: {\n                        color: \"#ccccff\",\n                        opacity: 0.5,\n                    },\n                },\n            },\n            {\n                name: \"Done Storypoints\",\n                data: data.map((data) => data.actual),\n                color: \"#6666ff\",\n            },\n        ],\n    };\n}\n/**\n * Create the data for the chart\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>} pi\n * @param {Statistics} statistics\n * @returns\n */\nfunction createData(pi, statistics) {\n    const today = DateTime.parse(statistics.current.date).withTimeAtStartOfDay();\n\n    const startDate = pi.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay();\n    const endDate = pi.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay();\n\n    // Define the data for Release Burn-Up\n\n    const sortedStatistics = statistics.archive.sort((a, b) => Days.daysBetween(new DateTime(Date.parse(b.date)), new DateTime(Date.parse(a.date))).getDays());\n\n    let data = sortedStatistics.map((element) => {\n        const currentDate = DateTime.parse(element.date);\n        return {\n            day: currentDayNumber(startDate, currentDate),\n            planned: linearPercentageDegression(element.burndown.planned, currentDate, startDate, endDate),\n            actual: element.burndown.done,\n            forecast: null,\n        };\n    });\n\n    const lastDataPoint = sortedStatistics[sortedStatistics.length - 1];\n\n    let currentDate = new DateTime(Date.parse(lastDataPoint.date));\n\n    while (!currentDate.isAfter(endDate.plusSeconds(5))) {\n        const currentDateKey = currentDayNumber(startDate, currentDate);\n\n        DEBUG && cplace.log(currentDateKey);\n\n        if (!data.some((el) => currentDateKey === el.day)) {\n            const entry = {\n                day: currentDateKey,\n                planned: linearPercentageDegression(statistics.current.burndown.planned, currentDate, startDate, endDate),\n                actual: null,\n                forecast:\n                    linearPercentageDegressionForecast(statistics.current.burndown.planned, statistics.current.burndown.done, currentDate, today, endDate) +\n                    statistics.current.burndown.done,\n            };\n            data.push(entry);\n        }\n\n        currentDate = currentDate.plusDays(1);\n    }\n\n    DEBUG && cplace.log(data);\n\n    data = sortByKey(data, \"day\");\n\n    return data;\n}\n\n/**\n * Calculates linear percentage degression based on the given parameters.\n * The function calculates the percentage degression from the initial value (`planned`) to 0\n * over a specific period between `startDate` and `endDate`, based on the `currentDate`.\n *\n * @param {number} planned - The initial value or planned value at the `startDate`.\n * @param {DateTime} currentDate - The current date for which the degression needs to be calculated.\n * @param {DateTime} startDate - The start date of the degression period.\n * @param {DateTime} endDate - The end date of the degression period.\n * @returns {number} The calculated value after linear percentage degression.\n *\n */\nfunction linearPercentageDegression(planned, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    return planned * (1 - daysLeft / daysFullIteration);\n}\n/**\n * Calculates linear percentage degression based on the given parameters.\n * The function calculates the percentage degression from the initial value (`planned`) to 0\n * over a specific period between `startDate` and `endDate`, based on the `currentDate`.\n *\n * @param {number} planned - The initial value or planned value at the `startDate`.\n * @param {number} done - The done value at the `startDate`.\n * @param {DateTime} currentDate - The current date for which the degression needs to be calculated.\n * @param {DateTime} startDate - The start date of the degression period.\n * @param {DateTime} endDate - The end date of the degression period.\n * @returns {number} The calculated value after linear percentage degression.\n *\n */\nfunction linearPercentageDegressionForecast(planned, done, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    if (daysFullIteration === 0) {\n        return done;\n    }\n\n    return (planned - done) * (1 - daysLeft / daysFullIteration);\n}\n\n/**\n * Sorts an array of objects based on the values of a specified key in each object.\n * The function sorts the array in ascending order based on the values of the specified `key`.\n *\n * @template T\n * @param {T[]} array - The array of objects to be sorted.\n * @param {keyof T} key - The key based on which the objects should be sorted.\n * @returns {T[]} The sorted array of objects.\n */\nfunction sortByKey(array, key) {\n    return array.sort(function (a, b) {\n        var x = a[key];\n        var y = b[key];\n        return x < y ? -1 : x > y ? 1 : 0;\n    });\n}\n\n/**\n * Calulcates the amount of days after the start date for the currentDate provided\n * @param {DateTime} startDate\n * @param {DateTime} currentDate\n * @returns\n */\nfunction currentDayNumber(startDate, currentDate) {\n    return Days.daysBetween(startDate.withTimeAtStartOfDay(), currentDate.withTimeAtStartOfDay()).getDays();\n}\n\n// @ts-ignore\nreturn main();",
    "attributes": null,
    "type_name": null,
    "counter": 31
}