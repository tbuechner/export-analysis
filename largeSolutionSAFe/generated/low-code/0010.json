{
    "type": "cf.cplace.platform.PageAction",
    "code": "/**\n * PAGE ACTION\n * @customType cf.cplace.solution.safe.programIncrement\n * @author unknown\n * @version 1.1\n * @description Updating period status of a program increment\n */\n\ncplace.setLogName(\"pageAction on PI-ProgramIncrement start\");\n\n//Configurations\nconst PI = /** @type {const} */ ({\n  TYPE: \"cf.cplace.solution.safe.programIncrement\",\n  ATTR: {\n    periodStatus: \"cf.cplace.solution.safe.periodStatus\",\n    predecessor: \"cf.cplace.solution.safe.predecessor\",\n  },\n  refAttr: {\n    order: \"cf.cplace.solution.safe.order\",\n  },\n});\nconst PERIOD_STATUS = /** @type {const} */ ({\n  TYPE: \"cf.cplace.solution.safe.periodStatus\",\n  ATTR: {\n    order: \"cf.cplace.solution.safe.order\",\n  },\n});\n\nfunction checkAccess() {\n  /** @type {Page<'cf.cplace.solution.safe.programIncrement'>} */\n  const programIncrement = embeddingPage;\n  let orderarr = [];\n\n  // action should be available only when the periodStatus is not running, not finished and no other PI should have running periodStatus\n  //check all PIs for the periodStatus whether periodStatus 'Running' is present or not\n  let piSearch = new Search();\n  piSearch.add(Filters.space(programIncrement.getSpaceId()));\n  piSearch.add(Filters.type(PI.TYPE));\n  piSearch.add(Filters.customAttributeNonempty(PI.ATTR.periodStatus));\n  /** @type {JIterable<Page<'cf.cplace.solution.safe.programIncrement'>>} */\n  let result = piSearch.findAllPages();\n\n  cplace.each(result, function (pi) {\n    let pStatus = pi.get(PI.ATTR.periodStatus);\n    let porder = pStatus.get(PERIOD_STATUS.ATTR.order);\n    orderarr.push(porder);\n  });\n  cplace.log(orderarr);\n  if (orderarr.indexOf(0) == -1) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction call() {\n  /** @type {Page<'cf.cplace.solution.safe.programIncrement'>} */\n  const programIncrement = embeddingPage;\n  let order = programIncrement.get(PI.ATTR.periodStatus)\n    ? programIncrement.get(PI.ATTR.periodStatus).get(PI.refAttr.order)\n    : null;\n  let update = true;\n  let orderarr1 = [];\n\n  //orderMap is required to get the corresponding periodStatus of the order\n  let orderSearch = new Search();\n  orderSearch.add(Filters.space(programIncrement.getSpaceId()));\n  orderSearch.add(Filters.type(PERIOD_STATUS.TYPE));\n  orderSearch.add(Filters.customAttributeNonempty(PERIOD_STATUS.ATTR.order));\n  /** @type {JIterable<Page<'cf.cplace.solution.safe.periodStatus'>>} */\n  let result = orderSearch.findAllPages();\n\n  let orderMap = new Map();\n  if (result) {\n    cplace.each(result, function (value) {\n      orderMap.set(value.get(PERIOD_STATUS.ATTR.order), value);\n      orderarr1.push(value.get(PERIOD_STATUS.ATTR.order)); // get the order array\n    });\n  }\n  //find the highest order\n  let highorder = Math.max(...orderarr1);\n  cplace.log(highorder);\n  let sarr = [];\n\n  let arr = checkforPredecessorChain(sarr, programIncrement);\n\n  for (let i = 0; i <= highorder; i++) {\n    if (arr[i] == null) {\n      update = false;\n      return {\n        success: false,\n        message: {\n          en: \"Set the predeccessor chain properly\",\n        },\n      };\n    }\n  }\n\n  // update the periodStatus\n  if (update) {\n    updateperiodStatus(programIncrement, 1, orderMap);\n  }\n}\n\nfunction updateperiodStatus(page, orderIncr, orderMap) {\n  let newPeriodStatus = orderMap.get(orderIncr - 1);\n  // update the periodStatus\n  if (newPeriodStatus) {\n    cplace.actions().updatePage(page, {\n      customAttributes: {\n        [PI.ATTR.periodStatus]: newPeriodStatus,\n      },\n    });\n\n    orderIncr += 1;\n\n    // check for the successor PI if successor is present then update its periodStatus\n    // @ts-ignore\n    let successor = Iterables.getFirst(\n      page.getIncomingPages(PI.TYPE, PI.ATTR.predecessor),\n      null\n    );\n    if (successor) {\n      updateperiodStatus(successor, orderIncr, orderMap);\n    }\n  }\n}\n\nfunction checkforPredecessorChain(sarr, page) {\n  // @ts-ignore\n  let successor = Iterables.getFirst(\n    page.getIncomingPages(PI.TYPE, PI.ATTR.predecessor),\n    null\n  );\n  sarr.push(successor);\n  if (successor != null) {\n    cplace.log(successor.getName());\n    checkforPredecessorChain(sarr, successor);\n  } else {\n    cplace.log(\"check the chain\");\n  }\n\n  return sarr;\n}\n\n// @ts-ignore\nreturn {\n  checkAccess,\n  call,\n};",
    "attributes": null,
    "type_name": "cf.cplace.solution.safe.programIncrement",
    "counter": 10
}