{
    "type": "custom_attribute",
    "code": "/**\n * Displays all items grouped by Solution and PI.\n * Dependencies between items are displayed as a line.\n *\n * Milestones that lie within the period of the PIs are displayed in a separate row.\n *\n * @author Christopher W\u00f6lfle\n * @version 15.03.2023\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName(\"highcharts-solution-dependency-map\");\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst CAPABILITY_HEIGHT = 0.3;\n\nconst TYPE_CAPABILITY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.capability\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        TYPE: \"cf.cplace.solution.safe.capabilityType\",\n        FEATURES: \"cf.cplace.solution.safe.feature\",\n        PROGRAM: \"cf.cplace.solution.safe.program\",\n        SOLUTION: \"cf.cplace.solution.safe.solution.reference\",\n        PROGRAM_INCREMENT: \"cf.cplace.solution.safe.programIncrement\",\n        EPIC: \"cf.cplace.solution.safe.portfolioEpic\",\n        TEMP_ITERATIONS: \"cf.cplace.solution.safe.iteration\",\n    },\n    ENUM: {\n        TYPE: {\n            CAPABILITY: \"capability\",\n            ENABLER: \"enabler\",\n        },\n    },\n});\n\nconst TYPE_MILESTONE = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.safeMilestone\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        DATE: \"cf.cplace.solution.safe.date\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        RELEVANT_FOR: \"cf.cplace.solution.safe.relevantFor\", // refers to Program\n    },\n    ENUM: {\n        TYPE: {\n            PI_MILESTONE: \"#15 - PI Meilenstein\",\n            FIXED_DATE: \"#25 - Fixiertes Datum\",\n            LEARNING_MILESTONE: \"#35 - Learning Meilenstein\",\n        },\n    },\n});\n\nconst TYPE_DEPENDENCY = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.dependency\",\n    ATTR: {\n        A: \"cf.cplace.solution.safe.successor\",\n        B: \"cf.cplace.solution.safe.predecessor\",\n        TYPE: \"cf.cplace.solution.safe.type\",\n        STATUS: \"cf.cplace.solution.safe.status\",\n        DESCRIPTION: \"cf.cplace.solution.safe.description\",\n    },\n    ENUM: {\n        TYPE: {\n            RELATED_TO: \"related to\",\n            BLOCKED_BY: \"blocked by\",\n        },\n        STATUS: {\n            IDENTIFIED: \"15 - identified\",\n            CONFLICT: \"25 - conflict\",\n            RESOLVED: \"35 - resolved\",\n        },\n    },\n});\n\nconst TYPE_PROGRAM_INCREMENT = /** @type {const} */ ({\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        TITLE: \"cf.cplace.solution.safe.title\",\n        START: \"cf.cplace.solution.safe.startDate\",\n        END: \"cf.cplace.solution.safe.endDate\",\n        PREDECESSOR: \"cf.cplace.solution.safe.predecessor\", // Program Increment\n    },\n});\n\nconst COLORS = {\n    INACTIVE: \"#88bbee\",\n    ACTIVE: \"#4488aa\",\n    DEPEND: \"#888888\",\n    DEPEND_HIGHLIGHT: \"#A21622\",\n    DEPEND_RESOLVED: \"#19ad48\",\n    SAFE_MILESTONE: \"#3D8F8C\",\n    RELEASE: \"#366C81\",\n    MILESTONE_PLOTBAND: \"#E2F3F2\",\n    RELEASE_PLOTBAND: \"#E2EEF3\",\n    CAPABILITY: \"#0aa5ff\",\n    ENABLER: \"#ffc80c\",\n    TODAY_PLOTLINE: \"lightgrey\",\n};\n\nconst CATEGORY = {\n    SAFE_MILESTONE: \"SAFe Milestones\",\n};\n\nconst ROW_SIZE = {\n    PERIOD: 2,\n    ITEM: 1,\n};\n\nconst HEIGHTS = {\n    HEADER: 40,\n    ITEM: 25,\n};\n\nconst MAX_DATA_LABEL_LENGTH = 25;\nconst DATA_LABEL_PADDING = 0.05;\n\nconst SEPARATOR = {\n    V: \" //VSEP// \",\n    H: \" --HSEP-- \",\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n/*\n*****************\nThis highchart is based on a heatmap, i.e. the chart is divided into a set of X * Y equally sized cells.\n* The first column(s) of the cells are used to show the vertical categories (categoriesVertical), which are provided as separate \"category\" series\n* The first row(s) of the cells are used to show the horizontal categories (categoriesHorizontal), which are provided as separate \"category\" series\n* The rest of the cells represent the data itself\n    * each cell can be identified by its set of vertical and horizontal categories saved as 'key' in the 'keys'-array in the form of a string like \"X Cat Level 1 - X Cat Level 2 / Y Cat Level 1 - Y Cat Level 2 - Y Cat Level 3\" (in theory the levels can be \"dynamic\", which is not used in this specific example. In this example only 1 level is used)\n    * for each cell the number of entities to be shown is counted as 'value' in the 'values'-array.\n    * the entities for each cell are represented as boxes/cards within the cell and are pushed as separate serie to the main data series\n    * dependencies between entities are represented as separate spline series, whereas start and end point of the splines are the left or right edge of the corresponding entity boxes/cards on the map\n\n/***** config options *****/\n\nfunction main() {\n    const ctx = fetchData(Array.from(pages));\n\n    if (ctx.capabilities.length === 0 || ctx.periods.length === 0) {\n        return {\n            title: {\n                text: null,\n            },\n        };\n    }\n\n    generateMatrix(ctx);\n\n    const chart = generateChartConfig(ctx);\n\n    return chart;\n}\n// @ts-ignore\nreturn main();\n//--------------------------------------------------------------------------------------//\n//                                    Data Fetching                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Fetches all required data\n * @param {Page[]} searchResults\n * @returns {Context}\n */\nfunction fetchData(searchResults) {\n    const capabilities = searchResults.filter((page) => page.getBuiltinFeatureValue(\"customType\") === TYPE_CAPABILITY.TYPE);\n    const missinCapabilities = getMissingCapabilities(capabilities);\n    capabilities.push(...missinCapabilities);\n    log(`Added ${missinCapabilities.length} missing items that the input items depend on.`);\n\n    const periods = getAllPeriods(capabilities);\n    log(\"Periods: \" + periods.length);\n\n    const programs = getPrograms(capabilities);\n    const milestones = getSafeMilestones(periods);\n    const dependencies = getDependencies(capabilities);\n\n    const capabilitiesById = capabilities.reduce((acc, capability) => {\n        acc[capability.getId()] = { x: 0, y: 0, capability };\n        return acc;\n    }, {});\n\n    const ctx = {\n        matrixData: undefined,\n        capabilities,\n        capabilitiesById,\n        periods,\n        programs,\n        milestones,\n        dependencies,\n        maxHeight: 1,\n    };\n    return ctx;\n}\n\n/**\n * Searches dependencies of the capabilities and returns those capabilities that are not yet included\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @return {Page<'cf.cplace.solution.safe.capability'>[]}\n */\nfunction getMissingCapabilities(capabilities) {\n    // @ts-ignore\n    const newCapabilities = new HashSet();\n    capabilities.forEach((item) => {\n        // @ts-ignore\n        const dependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n        dependencies.forEach((itemDependency) => {\n            const capability = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n            if (isPageOfType(capability, TYPE_CAPABILITY.TYPE)) {\n                newCapabilities.add(capability);\n            }\n        });\n    });\n    return Array.from(newCapabilities).filter((a) => !capabilities.some((b) => b.getId() === a.getId()));\n}\n\n/**\n * Determines the periods used as columns of the board\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities Capabilities\n * @returns {Page<'cf.cplace.solution.safe.programIncrement'>[]} PIs in chronological order\n */\nfunction getAllPeriods(capabilities) {\n    // @ts-ignore\n    const periodsSet = new HashSet();\n    capabilities.forEach((item) => {\n        const pi = item.get(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT);\n        if (!pi) {\n            return;\n        }\n        periodsSet.add(pi);\n    });\n    /** @type {Page<'cf.cplace.solution.safe.programIncrement'>[]} */\n    const periods = Array.from(periodsSet);\n    return periods.sort((a, b) =>\n        // @ts-ignore\n        a.get(TYPE_PROGRAM_INCREMENT.ATTR.START).isBefore(b.get(TYPE_PROGRAM_INCREMENT.ATTR.START)) ? -1 : 1\n    );\n}\n/**\n * Gets all dependencies of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities Capabilities\n * @returns {Page<'cf.cplace.solution.safe.dependency'>[]} PIs in chronological order\n */\nfunction getDependencies(capabilities) {\n    const dependencies = [];\n    capabilities.forEach((capabilitiy) => {\n        const itemDependencies = Array.from(\n            // @ts-ignore\n            capabilitiy.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []\n        );\n        dependencies.push(...itemDependencies);\n    });\n    return dependencies;\n}\n/**\n *\n * @param {Page<'cf.cplace.solution.safe.programIncrement'>[]} programmIncrements\n * @returns\n */\nfunction getSafeMilestones(programmIncrements) {\n    const periodStartDate =\n        // @ts-ignore\n        programmIncrements.length > 0 ? programmIncrements[0].get(TYPE_PROGRAM_INCREMENT.ATTR.START) : new DateTime();\n    const periodEndDate =\n        programmIncrements.length > 0\n            ? programmIncrements[programmIncrements.length - 1].get(TYPE_PROGRAM_INCREMENT.ATTR.END)\n            : // @ts-ignore\n              new DateTime();\n    const safeMilestoneSearch = new Search();\n    safeMilestoneSearch.add(Filters.embeddingSpace());\n    safeMilestoneSearch.add(Filters.type(TYPE_MILESTONE.TYPE));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).gte(periodStartDate));\n    safeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).lte(periodEndDate));\n    safeMilestoneSearch.addBuiltinAttributeSort(TYPE_MILESTONE.ATTR.DATE, true);\n    const safeMilestones = safeMilestoneSearch.findAllPages();\n    // @ts-ignore\n    return Array.from(safeMilestones);\n}\n/**\n * Get all the programs of the capabilities\n * @param {Page<'cf.cplace.solution.safe.capability'>[]} capabilities\n * @returns {Page<'cf.cplace.solution.safe.program'>[]}\n */\nfunction getPrograms(capabilities) {\n    // @ts-ignore\n    const programSet = new HashSet();\n    capabilities.forEach((item) => {\n        const programs = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n        if (!programs) {\n            return;\n        }\n        cplace.each(programs, (program) => programSet.add(program));\n    });\n    /** @type {Page<'cf.cplace.solution.safe.program'>[]} */\n    const programms = Array.from(programSet)\n    return programms.sort((a,b) => a.getName().localeCompare(b.getName()));\n}\n\n/**\n * Generate the matrix\n * @param {Context} ctx\n */\nfunction generateMatrix(ctx) {\n    /** @type {MatrixData} */\n    const matrixData = {\n        headerRow: ctx.periods.map((pi, index) => ({ programIncrement: pi, x: index + 2, y: 1 })),\n        milestoneRow: ctx.milestones,\n        programms: {},\n        capabilities: {},\n    };\n    let yOffset = 3;\n    ctx.programs.forEach((program) => {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n\n        const capabilitiesByPi = ctx.periods.map((programIncrement, indexPI) => {\n            const filteredCapabilities = ctx.capabilities.filter((capability) => {\n                const programIds = capability.get(TYPE_CAPABILITY.ATTR.PROGRAM)?.map((p) => p.getId()) || [];\n                // Get all capabilities that are associated to the current programm & the current program increment\n                return programIds.includes(program.getId()) && capability.getOptional(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT).getId() === programIncrement.getId();\n            });\n            // Check if the number of capabilities for this PI is the largest\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        // Iterate over the programm Increments to put the capabilities in the right place\n        matrixData.programms[program.getName()] = {\n            program,\n            data: capabilitiesByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: program.getId(),\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: program.getId(),\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight; //+ (rowHeight - 1) / 2;\n    });\n\n    const capabilitiesWithoutProgram = ctx.capabilities.filter(\n        (capability) =>\n            // @ts-ignore\n            !capability.get(TYPE_CAPABILITY.ATTR.PROGRAM) || capability.get(TYPE_CAPABILITY.ATTR.PROGRAM).length === 0\n    );\n\n    // Check if there are any capabilities without a programm and add them to the matrix\n    if (capabilitiesWithoutProgram.length > 0) {\n        let maxNumberOfCapabilitiesPerProgram = 0;\n        // Ad capabilities without a program\n        const capabilitiesWithoutProgrammByPi = ctx.periods.map((programIncrement) => {\n            const filteredCapabilities = capabilitiesWithoutProgram.filter(\n                (capability) => capability.getOptional(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT).getId() === programIncrement.getId()\n            );\n\n            if (filteredCapabilities.length > maxNumberOfCapabilitiesPerProgram) {\n                maxNumberOfCapabilitiesPerProgram = filteredCapabilities.length;\n            }\n            return filteredCapabilities;\n        });\n\n        const rowHeight = Math.ceil(maxNumberOfCapabilitiesPerProgram * CAPABILITY_HEIGHT);\n        const x = 1;\n        const y = yOffset + (rowHeight - 1) / 2;\n\n        matrixData.programms[\"w/o Program\"] = {\n            program: null,\n            data: capabilitiesWithoutProgrammByPi.map((c) => c.map((c) => c.getId())),\n            x,\n            y,\n            rowHeight,\n        };\n        capabilitiesWithoutProgrammByPi.map((capabilities, indexPI) => {\n            capabilities.map((capability, indexCapability) => {\n                if (matrixData.capabilities[capability.getId()]) {\n                    matrixData.capabilities[capability.getId()].push({\n                        x: x + 1 + indexPI,\n                        y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                        capability,\n                        programId: \"w/o Program\",\n                    });\n                } else {\n                    matrixData.capabilities[capability.getId()] = [\n                        {\n                            x: x + 1 + indexPI,\n                            y: y - (rowHeight - 1) / 2 + CAPABILITY_HEIGHT * (indexCapability - 1),\n                            capability,\n                            programId: \"w/o Program\",\n                        },\n                    ];\n                }\n            });\n        });\n        yOffset += rowHeight;\n    }\n    ctx.maxHeight = yOffset;\n    ctx.matrixData = matrixData;\n}\n/**\n *\n * @param {Context} ctx\n */\nfunction transformMatrixDataIntoSeries(ctx) {\n    const matrixData = ctx.matrixData;\n\n    const series = [];\n\n    if (!matrixData) {\n        return series;\n    }\n\n    // 1. Add PIs\n    series.push(\n        ...matrixData.headerRow.map((headerEntry, index) => {\n            return {\n                name: headerEntry.programIncrement.getName(),\n                colsize: 1,\n                rowsize: 1,\n                dataLabels: { rotation: 0, color: \"#000000\" },\n                enableMouseTracking: false,\n                data: [\n                    {\n                        x: headerEntry.x,\n                        y: headerEntry.y,\n                        value: 1,\n                        name: `<a href=\"${headerEntry.programIncrement.getUrl()}\">${headerEntry.programIncrement.getName()}</a>`,\n                        color: \"#dddddd\",\n                    },\n                ],\n            };\n        })\n    );\n\n    // 2. Add Milestones\n    series.push({\n        name: \"SAFe Milestones\",\n        colsize: 1,\n        rowsize: 1,\n        dataLabels: { rotation: 0, color: \"#000000\" },\n        enableMouseTracking: false,\n        data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n    });\n\n    let top = true;\n    const safeMilestoneData = [];\n\n    matrixData.milestoneRow.forEach((safeMilestone) => {\n        const safeMilestoneName = safeMilestone.getName();\n        const safeMilestoneDate = safeMilestone.get(TYPE_MILESTONE.ATTR.DATE);\n        // @ts-ignore\n        const safeMilestoneDateString = safeMilestoneDate?.toString(\"dd.MM.yyyy\");\n        // get milestone Position\n        // @ts-ignore\n        const safeMilestonePosition = getDatePosition(safeMilestoneDate.getMillis(), ctx);\n        // add milestone only if position is not null\n        if (safeMilestonePosition > 0) {\n            safeMilestoneData.push({\n                x: safeMilestonePosition,\n                y: 2,\n                name: '<a href=\"' + safeMilestone.getUrl() + '\">' + safeMilestoneName + \"</a>\",\n                value: safeMilestoneDateString,\n                dataLabels: {\n                    verticalAlign: top ? \"top\" : \"bottom\",\n                },\n            });\n            top = !top;\n        }\n    });\n\n    series.push({\n        type: \"scatter\",\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        data: safeMilestoneData,\n        marker: {\n            fillColor: COLORS.SAFE_MILESTONE,\n        },\n    });\n\n    // 3. Add Programms\n    let rowHeight = 2.5;\n    Object.keys(matrixData.programms).forEach((programName) => {\n        const data = matrixData.programms[programName];\n        // Add the Programms\n        series.push({\n            name: programName,\n            rowsize: data.rowHeight,\n            dataLabels: { rotation: 0, color: \"#000000\" },\n            enableMouseTracking: false,\n            data: [\n                {\n                    x: data.x,\n                    y: data.y,\n                    value: 1,\n                    name: `<a href=\\\"${data.program?.getUrl() || \"wip\"}\\\">${programName}</a>`,\n                    color: \"#dddddd\",\n                },\n            ],\n        });\n        // Add the capabilities of the programm\n        data.data.map((capabilitiesByPI, indexPI) => {\n            series.push({\n                name: programName + indexPI,\n                rowsize: CAPABILITY_HEIGHT,\n                colsize: 0.8,\n                dataLabels: { rotation: 0, color: \"#000000\", overflow: \"justify\" },\n                enableMouseTracking: false,\n                data: capabilitiesByPI.map((capabilityId, indexCapability) => {\n                    const capabilityData = matrixData.capabilities[capabilityId].filter((c) => c.programId === (data.program ? data.program.getId() : \"w/o Program\"))[0];\n                    const capability = capabilityData.capability;\n                    const isEnabler = capability.get(TYPE_CAPABILITY.ATTR.TYPE) === \"enabler\";\n                    return {\n                        x: capabilityData.x,\n                        y: capabilityData.y,\n                        value: 1,\n                        name: `<a href=\\\"${capability.getUrl() || \"wip\"}\\\">${limitStringSize(capability.getName(), 40)}</a>`,\n                        color: isEnabler ? \"#ffc80c\" : \"#0aa5ff\",\n                    };\n                }),\n            });\n        });\n        rowHeight += data.rowHeight;\n    });\n\n    // 4. Add Dependencies\n    ctx.dependencies.forEach((dependency) => {\n        const from = dependency.get(TYPE_DEPENDENCY.ATTR.B);\n        const to = dependency.get(TYPE_DEPENDENCY.ATTR.A);\n        if (!from || !to) {\n            return;\n        }\n        const fromId = from.getId();\n        const toId = to.getId();\n\n        const fromCapabilities = ctx.matrixData?.capabilities[fromId];\n        const toCapabilities = ctx.matrixData?.capabilities[toId];\n\n        if (!fromCapabilities) {\n            return;\n        }\n        const maxValue = ctx.maxHeight;\n        fromCapabilities.forEach((fromCapabilityData) => {\n            let x1 = fromCapabilityData.x;\n            let y1 = fromCapabilityData.y;\n            // y1 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n            if (!toCapabilities) {\n                return;\n            }\n            toCapabilities.forEach((toCapabilityData) => {\n                let x2 = toCapabilityData.x;\n                let y2 = toCapabilityData.y;\n                // y2 += -0.4 + 0.4 / maxValue + ((x1-1) * 0.8) / maxValue;\n\n                const description = dependency.get(TYPE_DEPENDENCY.ATTR.DESCRIPTION) || \" \";\n                const dependencyType = dependency.get(TYPE_DEPENDENCY.ATTR.TYPE);\n                const status = dependency.get(TYPE_DEPENDENCY.ATTR.STATUS);\n                const dependencySeries = {\n                    type: \"spline\",\n                    name: \"<b>\" + to.getName() + \"</b><br/>relates to:<br/>\" + from.getName() + \"<br>\" + description,\n                    lineWidth: 1.5,\n                    color: COLORS.DEPEND,\n                    dashStyle: \"shortdot\",\n                    findNearestPointBy: \"xy\",\n                    data: [\n                        { x: x1 + 0.4, y: y1 },\n                        { x: x1 + 0.45, y: y1 === y2 ? y1 + 0.02 : y1 },\n                        { x: x2 - 0.45, y: y1 === y2 ? y2 - 0.02 : y2 },\n                        { x: x2 - 0.4, y: y2, marker: { enabled: true, symbol: \"diamond\" } },\n                    ],\n                };\n                if (dependencyType === TYPE_DEPENDENCY.ENUM.TYPE.BLOCKED_BY) {\n                    dependencySeries.name = \"<b>\" + to.getName() + \"</b><br/>blocked by:<br/>\" + from.getName() + \"<br>\" + description;\n                    // @ts-ignore\n                    dependencySeries.dashStyle = null;\n                }\n                if (status === TYPE_DEPENDENCY.ENUM.STATUS.CONFLICT) {\n                    dependencySeries.color = COLORS.DEPEND_HIGHLIGHT;\n                } else if (status === TYPE_DEPENDENCY.ENUM.STATUS.RESOLVED) {\n                    dependencySeries.color = COLORS.DEPEND_RESOLVED;\n                }\n                series.push(dependencySeries);\n            });\n        });\n    });\n\n    return series;\n}\n\n//--------------------------------------------------------------------------------------//\n//                                     Chart Config                                     //\n//--------------------------------------------------------------------------------------//\n\n/**\n *\n * @param {Context} ctx\n */\nfunction generateChartConfig(ctx) {\n    if (!ctx.matrixData) {\n        return;\n    }\n    const series = transformMatrixDataIntoSeries(ctx);\n    // @ts-ignore\n    const today = new DateTime();\n    let todayPosition = getDatePosition(today.getMillis(), ctx);\n\n    return {\n        chart: {\n            type: \"heatmap\",\n            marginTop: 0,\n            marginBottom: 0,\n            plotBorderWidth: 0,\n            scrollablePlotArea: {\n                minHeight: 1200,\n                minWidth: 2200,\n            },\n        },\n        title: {\n            text: null,\n        },\n        xAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 0,\n            lineWidth: 0,\n            labels: {\n                enabled: false,\n            },\n            plotLines: [\n                {\n                    dashStyle: \"dash\",\n                    color: COLORS.TODAY_PLOTLINE,\n                    width: 2,\n                    value: todayPosition,\n                    zIndex: 1,\n                },\n            ],\n        },\n        yAxis: {\n            categories: [],\n            title: null,\n            gridLineWidth: 1,\n            tickInterval: 1,\n            lineWidth: 0,\n            min: 1,\n            max: ctx.maxHeight,\n            labels: {\n                enabled: false,\n            },\n            reversed: true,\n            scrollbar: {\n                enabled: true,\n            },\n            plotBands: [\n                {\n                    color: COLORS.MILESTONE_PLOTBAND,\n                    borderColor: \"white\",\n                    borderWidth: 2,\n                    from: 1.5,\n                    to: 2.5,\n                    zIndex: 0,\n                },\n                // {\n                //     color: COLORS.RELEASE_PLOTBAND,\n                //     borderColor: 'white',\n                //     borderWidth: 2,\n                //     from: 1.5,\n                //     to: 2.5,\n                //     zIndex: 0\n                // }\n            ],\n        },\n        colors: [\"#D5001C\", \"#92D050\"],\n        colorAxis: {\n            dataClassColor: \"category\",\n            dataClasses: [\n                {\n                    to: 0.5,\n                },\n                {\n                    from: 0.5,\n                },\n            ],\n        },\n        legend: {\n            enabled: false,\n        },\n        tooltip: {\n            useHTML: true,\n            followPointer: false,\n        },\n        plotOptions: {\n            series: {\n                borderColor: \"#ffffff\",\n                borderWidth: 2,\n                dataLabels: {\n                    allowOverlap: false,\n                    inside: true,\n                    crop: true,\n                    overflow: \"justify\",\n                    position: \"left\",\n                    shape: \"circle\",\n                    enabled: true,\n                    color: \"#000000\",\n                    format: \"{point.name}\",\n                    style: {\n                        textOutline: \"none\",\n                        textOverflow: \"clip\",\n                    },\n                },\n                stickyTracking: false,\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b>\",\n                    findNearestPointBy: \"xy\",\n                },\n                states: {\n                    inactive: {\n                        opacity: 1,\n                    },\n                },\n            },\n            spline: {\n                tooltip: {\n                    headerFormat: \"{series.name}\",\n                    pointFormat: \"\",\n                    findNearestPointBy: \"xy\",\n                },\n                marker: {\n                    enabled: false,\n                    fillColor: COLORS.DEPEND,\n                    radius: 6,\n                    states: {\n                        hover: {\n                            enabled: false,\n                        },\n                    },\n                },\n            },\n            scatter: {\n                tooltip: {\n                    headerFormat: \"\",\n                    pointFormat: \"<b>{point.name}</b><br>{point.value}\",\n                    findNearestPointBy: \"xy\",\n                },\n                dataLabels: {\n                    enabled: true,\n                },\n                marker: {\n                    enabled: true,\n                    symbol: \"diamond\",\n                    radius: 10,\n                    states: {\n                        hover: {\n                            enabled: true,\n                        },\n                    },\n                },\n            },\n        },\n        series: series,\n        // series: [\n        //     {\n        //         name: \"PI 22.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 2,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/1bk9kpxn7s36vz3w80ji7t5oo/PI-22.4\">PI 22.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 3,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4l6jbaa8qgzinif5qetj499g5/PI-23.1\">PI 23.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.2\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 4,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/tksr708c2119mek2pzzopu9qb/PI-23.2\">PI 23.2</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.3\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 5,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/i4o8azmi8m0oqvqqu3hejgu80/PI-23.3\">PI 23.3</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 23.4\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 6,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/nrymz33xo7ew3x6qcgdk3fl7l/PI-23.4\">PI 23.4</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"PI 24.1\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 7,\n        //                 y: 1,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/0wtzrg3m4bdpfhut5xbgiza73/PI-24.1\">PI 24.1</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"SAFe Milestones\",\n        //         colsize: 1,\n        //         rowsize: 1,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [{ x: 1, y: 2, value: 1, name: '<a href=\"wip\">SAFe Milestones</a>', color: \"#E2F3F2\" }],\n        //     },\n        //     {\n        //         name: \"Smart Infotainment\",\n        //         rowsize: 2,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 3.5,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/qg000odouviwwtx4rz2bvaoi8/Smart-Infotainment\">Smart Infotainment</a>',\n        //                 color: \"#dddddd\",\n        //             },\n        //         ],\n        //     },\n        //     {\n        //         name: \"Powertrain and Safety\",\n        //         rowsize: 4,\n        //         dataLabels: { rotation: 0, color: \"#000000\" },\n        //         enableMouseTracking: false,\n        //         data: [\n        //             {\n        //                 x: 1,\n        //                 y: 5 + (4-1)/2,\n        //                 value: 1,\n        //                 name: '<a href=\"https://solution-templates.cplace.de/large-solution-safe/pages/4flf7a0349c5ximei6olrhife/Powertrain-and-Safety\">Powertrain and Safety</a>',\n        //                 color: \"red\",\n        //             },\n        //         ],\n        //     },\n        // ],\n    };\n}\n\n//--------------------------------------------------------------------------------------//\n//                                        Utils                                         //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Limit string to specified size\n * @param {string} str\n * @param {number} maxSize\n * @returns\n */\nfunction limitStringSize(str, maxSize) {\n    if (str.length > maxSize) {\n        return str.substring(0, maxSize - 3) + \"...\";\n    }\n    return str;\n}\n\n/**\n *\n * @param {number} date\n * @param {Context} ctx\n * @returns\n */\nfunction getDatePosition(date, ctx) {\n    let xPosition = 0;\n    ctx.periods.every((pi, idx) => {\n        // @ts-ignore\n        let categoryStartDate = pi.get(TYPE_PROGRAM_INCREMENT.ATTR.START)?.getMillis();\n        // @ts-ignore\n        let categoryEndDate = pi.get(TYPE_PROGRAM_INCREMENT.ATTR.END)?.getMillis();\n\n        // Check whether release date lies in between start and end date of category\n        if (categoryStartDate && categoryEndDate && date >= categoryStartDate && date <= categoryEndDate) {\n            // find x-Value of category and subtract 0.5 for starting point as offset\n            let x = idx + 2 - 0.5;\n            // calculate the relative position of date between Category StartDate and EndDate and add it to the offset value\n            xPosition = x + (date - categoryStartDate) / (categoryEndDate - categoryStartDate);\n            // exit the every loop\n            return false;\n        }\n        // continue the every loop\n        return true;\n    });\n    // if there was no match, just return null\n    return xPosition;\n}\n\n/**\n * Checks if a cplace page is of the specified type\n * @param {Page} page\n * @param {string} type\n * @returns {boolean}\n */\nfunction isPageOfType(page, type) {\n    return page.getBuiltinFeatureValue(\"customType\") === type;\n}\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    const logOutput = typeof text !== \"string\" ? JSON.stringify(text) : text;\n    cplace.log(logOutput);\n}",
    "attributes": null,
    "type_name": null,
    "counter": 43
}