{
    "type": "custom_attribute",
    "code": "/// <reference path=\"./typeDefinitions/cplaceJS_type.js\" />\n/**\n * Template for Highchart\n * \n * Instructions:\n * - configure a highchart widget with a search or connected table\n * - look in this script for the following line: !!!! CHANGE FROM HERE !!!! and change your options there\n * - the main options are: BASE_ATTRIBUTE and CHART_TYPE_SELECTED\n * \n * TODO:\n * - Color Attribute\n * - builtin Attributes\n * - more charts\n * - date format for series / data points\n * - multi language\n * - Alias label for internal names\n * - sort of series\n *   \n * \n * \n * @author Bastian Rang <bastian.rang@collaboration-factory.de>\n * @version 2021-08-05\n */\n\n/**\n * ======================\n * LOG AND DEBUG SETTINGS\n * ======================\n */\n const DEBUG = true;\n\n /**\n  * Hint: set a declarative name for all of your logs\n  */\n cplace.setLogName(\"highchart-template\");\n \n /**\n  * ===================\n  * CONFIGURATION STAGE\n  * ===================\n  */\n \n /**\n  * DO NOT CHANGE THESE CONFIGURATIONS WITHOUT STRONG REASON !!!!!\n  */\n const CHART_DEFINITION = {\n     PIE: {\n         chart: {\n             type: 'pie'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     SEMICIRCLE: {\n         chart: {\n             type: 'pie'\n         },\n         plotOptions: {\n             startAngle: -90,\n             endAngle: 90,\n             center: ['50%', '75%'],\n             size: '110%',\n             innerSize: '70%'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     BAR: {\n         chart: {\n             type: 'bar'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n     COLUMN: {\n         chart: {\n             type: 'column'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n }\n \n \n \n /**\n  * ==================================================================================\n  * !!!! CHANGE FROM HERE !!!!\n  */\n \n /**\n  * Optional: Show a title inside of the chart area\n  */\n const CHART_TITLE = ''\n \n /**\n  * Set to null or leave blank to use the Pagename\n  * \n  * TODO builtinFeatureValue starts with underscore: '_creator'\n  */\n const BASE_ATTRIBUTE = 'cf.cplace.solution.okr.progressIndicator';\n \n /**\n  * Optional: Stacking is only possible for bar and column charts\n  * \n  */\n const STACK_ATTRIBUTE = null;\n \n /**\n  * Optional: Define an attribute of the page that acts as weight. If null, each entry has a weight of 1.\n  * The weight is used as sum of each datapoint.\n  */\n const WEIGHT_ATTRIBUTE = null;\n \n /**\n  * Define the base type of the chart: \n  * - CHART_DEFINITION.PIE\n  * - CHART_DEFINITION.SEMICIRCLE\n  * - CHART_DEFINITION.BAR\n  * - CHART_DEFINITION.COLUMN\n  */\n const CHART_TYPE_SELECTED = CHART_DEFINITION.PIE;\n \n /**\n  * Define colors for the chart\n  */\n const CHART_COLORS = {\n     BACKGROUND: '#F2F4FA',\n     TEXT: 'var(--text-color)',\n     SERIES: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a'],\n     CATEGORY: {\n         '#15 green': '#AEDB3C',\n         '#25 yellow': '#FFBA00',\n         '#35 red': '#DB0F35',\n         '#45 outdated': '#bcbcbc'\n     }\n }\n \n /**\n  * @type {Boolean} sort axes ascending (true) or descending (false)\n  */\n const CHART_SORT_ASCENDING = true;\n \n /**\n  * @type {Boolean} show legend under chart\n  */\n const CHART_SHOW_LEGEND = false;\n \n /**\n  * @type {Boolean} show labels on all datapoints\n  */\n const CHART_SHOW_LABELS = false;\n \n /**\n  * @type {Boolean} show values as percentage\n  */\n const CHART_SHOW_PERCENTAGE = false;\n \n /**\n  * @type {null|String} override tooltip text\n  * - use {point.y} as placeholder for absolute values\n  * - use {point.percentage:.1f}% as placeholder for percantage\n  * - use {point.stackTotal} for sum of stack\n  * - use {point.name} for name of data point\n  * - use {series.name} for name of data series\n  */\n const CHART_TOOLTIP_OVERRIDE = null;\n \n \n /**\n  * DO NOT CHANGE AFTER THIS LINE\n  * ==================================================================================\n  */\n \n const CHART_IS_STACKED = !!STACK_ATTRIBUTE && CHART_TYPE_SELECTED.isStackable;\n \n const CHART_POINT_FORMAT = (CHART_TYPE_SELECTED.isPercentageAvailable && CHART_SHOW_PERCENTAGE) ? '{point.percentage:.1f}%' : '{point.y}'\n \n /**\n  * ====================\n  * INITIALIZATION STAGE\n  * ====================\n  */\n \n let config = {\n     title: {\n         text: CHART_TITLE,\n         align: 'center',\n         verticalAlign: 'middle',\n         margin: 0,\n         useHtml: true,\n         style: {\n             color: CHART_COLORS.TEXT,\n             fontSize: \"2em\",\n             fontWeight: \"bold\"\n         }\n     },\n     chart: CHART_TYPE_SELECTED.chart,\n     legend: {\n         enabled: CHART_SHOW_LEGEND,\n         layout: 'horizontal',\n         align: 'center',\n         verticalAlign: 'bottom',\n         itemStyle: {\n             color: CHART_COLORS.TEXT,\n             fontWeight: \"normal\"\n         }\n     },\n     pane: {\n         size: '100%'\n     },\n     tooltip: {\n         pointFormat: '<b>' + CHART_POINT_FORMAT + '</b>'\n     },\n     plotOptions: {\n         pie: {\n            borderWidth: 10,\n            borderColor: 'var(--body-bg)',\n         },\n         series: {\n             showInLegend: CHART_SHOW_LEGEND,\n             dataLabels: {\n                 enabled: CHART_SHOW_LABELS,\n                 format: '<b>{point.name}</b>: ' + CHART_POINT_FORMAT\n             },\n             cursor: 'pointer',\n             stacking: (CHART_IS_STACKED && CHART_SHOW_PERCENTAGE) ? 'percent' : CHART_IS_STACKED\n         }\n     },\n     colors: CHART_COLORS.SERIES,\n     series: [],\n     xAxis: {\n         type: 'category'\n     },\n     yAxis: {\n         allowDecimals: false,\n         title: ''\n     }\n }\n \n config.chart.backgroundColor = CHART_COLORS.BACKGROUND\n config.chart.spacingBottom = 0\n config.chart.spacingTop = 0\n \n if (CHART_TITLE && CHART_SHOW_LEGEND && CHART_TYPE_SELECTED.hasFloatingTitle) {\n     config.title.verticalAlign = 'top'\n }\n \n if (CHART_TYPE_SELECTED.plotOptions) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type] = CHART_TYPE_SELECTED.plotOptions;\n }\n \n if (CHART_IS_STACKED) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type].colorByPoint = false;\n     config.tooltip.pointFormat = '{series.name}: ' + CHART_POINT_FORMAT + '<br/>Total: {point.stackTotal}'\n     config.plotOptions.series.dataLabels.format = '{series.name}: ' + CHART_POINT_FORMAT\n }\n \n if (CHART_TOOLTIP_OVERRIDE !== null) {\n     config.tooltip.pointFormat = CHART_TOOLTIP_OVERRIDE;\n }\n \n \n /**\n  * ================\n  * PROCESSING STAGE\n  * ================ \n  */\n if (pages.length === 0) {\n     return config\n }\n \n let datasetSize = pages.length;\n let series = [];\n let series_labels = {};\n let categories = {};\n let data = {};\n let pageCounter = 0;\n pages.forEach(function (page) {\n     let value = getValueAndLabelOfAttribute(page, BASE_ATTRIBUTE)\n     let weight = 1;\n     if (value === null) {\n         return\n     }\n \n     let series = getValueAndLabelOfAttribute(page, STACK_ATTRIBUTE);\n \n     if (!CHART_IS_STACKED || series === null) {\n         series = {\n             value: '',\n             label: CHART_TITLE\n         }\n     }\n \n     if (WEIGHT_ATTRIBUTE) {\n         weight = page.get(WEIGHT_ATTRIBUTE) || 1\n     }\n \n     if (value.length) {\n         value.forEach(function (item) {\n             addSeriesData(item, weight, series, data, categories, series_labels)\n         })\n     } else {\n         addSeriesData(value, weight, series, data, categories, series_labels)\n     }\n     pageCounter++;\n });\n\n // This will display the number of pages in the center\n config.title.text += pageCounter;\n \n /**\n  * TODO Sort stacked series, too\n  */\n \n Object.keys(series_labels).sort().forEach(function (series_label) {\n     series_labels[series_label] = series.length\n \n     series.push({\n         name: series_label,\n         type: CHART_TYPE_SELECTED.chart.type,\n         data: [],\n         innerSize: '50%'\n     })\n \n })\n \n Object.keys(data).forEach(function (key) {\n     let currentDataItem = {\n         name: data[key].name,\n         y: data[key].count\n     }\n     let seriesId = series_labels[data[key].series]\n \n     if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series_internal)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series_internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].internal)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].name)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].name]\n     }\n \n     series[seriesId].data.push(currentDataItem)\n })\n \n /**\n  * Add empty entries to series and sort them\n  */\n  let allDataKeys = [];\n  Object.keys(data).forEach(function (key) {\n      let label = data[key].name;\n      if (allDataKeys.indexOf(label) !== -1) {\n          return;\n      }\n  \n      series.forEach(function (serie) {\n          if (!serie.data.some(function (data) {\n                  return data.name === label\n              })) {\n              serie.data.push({\n                  name: label,\n                  y: 0\n              })\n          }\n      })\n      allDataKeys.push(label)\n  })\n \n /**\n  * sort series.data by name\n  */\n series.forEach(function (serie) {\n     serie.data.sort(function (a, b) {\n         if (!a.hasOwnProperty('name') || a.name == b.name) {\n             return 0\n         }\n         /**\n          * sort depending on CHART_SORT_ASCENDING\n          */\n         return ((CHART_SORT_ASCENDING && a.name > b.name) || (!CHART_SORT_ASCENDING && a.name < b.name)) ? 1 : -1\n     })\n })\n \n /**\n  * ============\n  * OUTPUT STAGE\n  * ============ \n  */\n \n config.series = series;\n return config;\n \n /**\n  * ==================\n  * BUSINESS FUNCTIONS\n  * ==================\n  */\n \n /**\n  * ================\n  * HELPER FUNCTIONS\n  * ================\n  */\n \n /**\n  * \n  * @param {object} value \n  * @param {Number} weight \n  * @param {object} series \n  * @param {object[]} data \n  * @param {object[]} categories \n  * @param {String[]} series_labels \n  */\n function addSeriesData(value, weight, series, data, categories, series_labels) {\n     let key = value.value + series.value;\n \n     if (data[key] === undefined) {\n         data[key] = {\n             count: 0,\n             name: value.label,\n             internal: value.value,\n             series: series.label,\n             series_internal: series.value\n         }\n     }\n \n     data[key].count += weight || 1;\n \n     if (!categories.hasOwnProperty(data[key].name)) {\n         categories[data[key].name] = 0\n     }\n \n     if (!series_labels.hasOwnProperty(data[key].series)) {\n         series_labels[data[key].series] = 0\n     }\n }\n \n \n /**\n  * \n  * @param {Page} page \n  * @param {object} attribute \n  * @returns \n  */\n function getValueAndLabelOfAttribute(page, attribute) {\n     let result = null;\n     if (!page) {\n         return result;\n     }\n     if (!attribute) {\n         return {\n             value: page.getRealUid(),\n             label: page.getName()\n         };\n     }\n \n     let value = page.get(attribute, false);\n     if (value === null) {\n         return result;\n     }\n     let value_label = page.get(attribute, true) || value;\n \n     let className = typeof value === 'object' ? String(value.getClass()) : 'String'\n \n     switch (className) {\n         case 'String':\n         case 'class java.lang.String':\n             result = {\n                 value: value,\n                 label: value_label\n             }\n             break;\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedGroup':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPerson':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPage':\n             result = {\n                 value: value.getRealUid(),\n                 label: value.getName()\n             }\n             break;\n         case 'class java.util.ArrayList':\n         case 'class com.google.common.collect.SingletonImmutableList':\n         case 'class com.google.common.collect.RegularImmutableList':\n             /**\n              * TODO Multi-Value\n              */\n             result = [];\n             cplace.each(value, function (item) {\n                 if (typeof item !== 'object' || String(item.getClass()) === 'class java.lang.String') {\n                     /**\n                      * FIXME enum label / enum internal name\n                      */\n                     result.push({\n                         value: item,\n                         label: item\n                     })\n                 } else {\n                     result.push({\n                         value: item.getRealUid(),\n                         label: item.getName()\n                     })\n                 }\n             })\n             break;\n         default:\n             /**\n              * TODO Reference\n              */\n             log('Class of ' + value + ' is \"' + value.class + '\"')\n             log(typeof value.class)\n             log(typeof value)\n     }\n \n     return result\n }\n \n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n function log(text) {\n     if (!DEBUG) {\n         return\n     }\n     let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n \n     cplace.log(logOutput);\n }",
    "attributes": null,
    "type_name": null,
    "counter": 16
}