[
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Cycle\n*Triggering attribute: Status\n*Sets the status for the name generation pattern \n*Author :Laxmi Udapudi\n*/\n\ncplace.setLogName('Set_the_Current_Status')\nfunction main() {\n    let cycle = changeEvent.getEntity();\n    let status = cycle.get('cf.cplace.solution.okr.status');\n\n    if (status == '#25 Current') {\n        updatePage(cycle, {\n            'cf.cplace.solution.okr.statusForNameGenerationPattern': 'Current'\n        })\n    } else {\n        updatePage(cycle, {\n            'cf.cplace.solution.okr.statusForNameGenerationPattern': undefined\n        })\n\n    }\n}\n\nmain();\n\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n    let key = null;\n    for (key in customAttributes) {\n        if (customAttributes.hasOwnProperty(key)) {\n            page.registerAttributeForRefresh(key)\n        }\n    }\n    return cplace.actions().updatePage(page, {\n        customAttributes: customAttributes,\n    }\n        , {\n            setGeneratedName: true\n        }\n    );\n}",
        "attributes": [
            "cf.cplace.solution.okr.status"
        ],
        "type_name": "cf.cplace.solution.okr.cycle"
    },
    {
        "type": "cf.cplace.platform.PageAction",
        "code": "/// <reference path=\"../typeDefinitions/globals.d.ts\" />\n\n/**\n * Description : checks the Current Cycle for the key results \n * @author \n */\n\n\n//14-14\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Set to false to suspend logging\n * @type {Boolean}\n */\nconst DEBUG = true;\n\n/**\n * Set to false, to disable this page action\n * @type {Boolean}\n */\nconst ENABLED = true;\n\n/**\n* Get millisecond starting time of the script\n* @type {Number}\n*/\nconst START_TIME = new Date().getTime()\n\n/** @type {Number} */\nlet LAST_TIME = START_TIME;\n\n/**\n * Hint: set a declarative name for all of your logs\n */\ncplace.setLogName('pageaction-task-');\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\n// Everything older than this will be flaged als \"outdated\"\nconst THRESHOLD_DAYS = 14;\n\nconst ACTIONS = {\n    DEFAULT: 'DEFAULT',\n}\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n\n/**\n * TODO check which action should be performed.\n * For instance if you want a toggle like archive / restore, you can define both actions in one page action easily.\n */\nconst ACTION = ACTIONS.DEFAULT;\n\nconst RESULT_MESSAGE = {\n    DEFAULT: {\n        'de': 'Aktion erfolgreich ausgef\u00fchrt',\n        'en': 'Action successfull',\n    }\n}\n\nfunction main() {\n    return { checkAccess, call }\n}\n\nfunction checkAccess() {\n    try {\n        return ENABLED ? isActionAllowed(page) : false\n    } catch (e) {\n        cplace.error(e)\n        return false;\n    }\n}\n\nfunction call() {\n    try {\n        return doBusinessAction(page)\n    } catch (e) {\n        cplace.error(e)\n        if (DEBUG) {\n            throw e\n        }\n\n        return {\n            success: false,\n            message: e\n        }\n    }\n}\n\nreturn main();\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n\n\n/**\n * Return true if the action is allowed and visible\n * @param {Page} page \n * @returns {Boolean}\n */\nfunction isActionAllowed(page) {\n    let status = page.get('cf.cplace.solution.okr.status');\n\n    return status == '#25 Current';\n}\n\n/**\n * Do the business action\n * \n * @param {Page} page \n * @returns {Object}\n */\nfunction doBusinessAction(page) {\n    timeSinceStart('start')\n\n    let allResults = page.getIncomingPages('cf.cplace.solution.okr.keyResult', 'cf.cplace.solution.okr.cycle');\n\n    allResults.forEach(function (result) {\n        log('resulting key results :'+result);\n        checkAndUpdatePage(result);\n    });\n\n    timeSinceStart('final');\n    return {\n        success: true, // default is true\n        //job: jobId, //if your action starts a job and you want to show job modal\n        message: RESULT_MESSAGE[ACTION]\n    }\n}\n\nfunction checkAndUpdatePage(page) {\n    let lastModified = page.get('cf.cplace.solution.okr.lastUpdate');\n    let now = new DateTime();\n\n    let refDate = now.minusDays(THRESHOLD_DAYS);\n\n    if (lastModified && refDate.isAfter(lastModified)) {\n        updatePage(page, {\n            'cf.cplace.solution.okr.progressIndicator': '#45 outdated'\n        });\n    }\n}\n\n\n//--------------------------------------------------------------------------------------//\n//                                       HELPER FUNCTIONS                               //\n//--------------------------------------------------------------------------------------//\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n    let key = null;\n    for (key in customAttributes) {\n        if (customAttributes.hasOwnProperty(key)) {\n            page.registerAttributeForRefresh(key)\n        }\n    }\n    return cplace.actions().updatePage(page, {\n        customAttributes: customAttributes,\n    }\n        , {\n            setGeneratedName: true\n        }\n    );\n}\n\n/**\n * Log to cplace\n * @param {any} text \n */\nfunction log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}\n\n\nfunction timeSinceStart(msg) {\n    if (!DEBUG) {\n        return\n    }\n    let now = new Date().getTime();\n    cplace.log([(now - START_TIME) + 'ms', (now - LAST_TIME) + 'ms', msg].join(' -- '))\n    LAST_TIME = now;\n}",
        "attributes": null,
        "type_name": "cf.cplace.solution.okr.cycle"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/**\n * Erstelle Progress Seite beim anlegen eines Key Results\n * Watched Attributes: 'cf.cplace.solution.okr.title'\n * @LukasScheiring\n */\n\n/**\n * ======================\n * LOG AND DEBUG SETTINGS\n * ======================\n */\n const DEBUG = true;\n\n /**\n  * Hint: set a declarative name for all of your logs\n  */\n cplace.setLogName(\"Create Progress Page\");\n \n /**\n  * ===================\n  * CONFIGURATION STAGE\n  * ===================\n  *\n  */\n \n const ATTRIBUTES = {\n     KEY_RESULT: {\n         TYPE: 'cf.cplace.solution.okr.keyResult',\n         ATTR: {\n             TITLE: 'cf.cplace.solution.okr.title',\n             PROGRESS: 'cf.cplace.solution.okr.progress',\n         },\n     },\n     PROGRESS: {\n         TYPE: 'cf.cplace.solution.okr.progress',\n         ATTR: {\n            KEY_RESULT: 'cf.cplace.solution.okr.keyResult'\n         }\n     }\n\n }\n \n /**\n  * ====================\n  * INITIALIZATION STAGE\n  * ====================\n  */\n const page = changeEvent.getEntity();\n \n const keyResultProgress = page.get(ATTRIBUTES.KEY_RESULT.ATTR.PROGRESS);\n const currentUser = cplace.utils().getCurrentUser();\n \n\n // Lege Progress Objekt an\n if (pageIsNew() || keyResultProgress === null) {\n    let ca = {\n      'cf.cplace.solution.okr.keyResult' : page\n    };\n   \n   // ca['cf.cplace.solution.okr.keyResult'] = page;\n   cplace.log('page'+page);\n   cplace.log('ca'+JSON.stringify(ca));\n    let newProgress = cplace.actions().createPage( {\n        customType: ATTRIBUTES.PROGRESS.TYPE,\n        space: page.getSpaceId(),\n        customAttributes: ca,\n        }, {\n        setGeneratedName: true\n    });\n    \n    //\u00c4ndere Progress von Key Result auf neues Objekt\n    let ca2 = {};\n    ca2[ATTRIBUTES.KEY_RESULT.ATTR.PROGRESS] = newProgress;\n    cplace.actions().updatePage(page, {\n        customAttributes: ca2\n    });\n    page.registerAttributeForRefresh(ATTRIBUTES.KEY_RESULT.ATTR.PROGRESS);\n}\n return;\n \n \n /**\n  * ==================\n  * BUSINESS FUNCTIONS\n  * ==================\n  */\n \n  //Checke ob Seite neu angelegt wurde\n function pageIsNew () {\n     let bool = changeEvent.isNew();\n     return bool;\n };\n \n \n \n /**\n  * ================\n  * HELPER FUNCTIONS\n  * ================\n  */\n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n function log(text) {\n     if (!DEBUG) {\n         return\n     }    \n     let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n \n     cplace.log(logOutput);\n }",
        "attributes": [
            "cf.cplace.solution.okr.title"
        ],
        "type_name": "cf.cplace.solution.okr.keyResult"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "const KEY_RESULT = {\n  TYPE : 'cf.cplace.solution.okr.keyResult',\n  ATTR :{\n    PROGRESS : 'cf.cplace.solution.okr.progress',\n    CONFIDENCE_LEVEL :'cf.cplace.solution.okr.confidenceLevel',\n  }\n}\n\nconst PROGRESS = {\n  TYPE : 'cf.cplace.solution.okr.progress',\n  ATTR : {\n    KEY_RESULT:'cf.cplace.solution.okr.keyResult',\n    CONFIDENCE_LEVEL:'cf.cplace.solution.okr.confidenceLevel',\n  }\n}\n\n\nfunction main(){\n  let page = changeEvent.getEntity();\n  let confidenceLevel = page.get(KEY_RESULT.ATTR.CONFIDENCE_LEVEL);\n  let progress = page.get(KEY_RESULT.ATTR.PROGRESS);\n  if (!isSet(progress) || !isSet(confidenceLevel)) {\n    // Nothing to sync with\n    return;\n  }\n  let processConfidence = progress.get(PROGRESS.ATTR.CONFIDENCE_LEVEL);\n  if (confidenceLevel === processConfidence)  {\n    return;\n  }\n  cplace.actions().updatePage(progress, {\n    customAttributes: {\n      'cf.cplace.solution.okr.confidenceLevel': confidenceLevel\n    }\n  }\n                             );\n  progress.registerAttributeForRefresh('cf.cplace.solution.okr.confidenceLevel');\n}\n\nreturn main();\n\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}",
        "attributes": [
            "cf.cplace.solution.okr.confidenceLevel"
        ],
        "type_name": "cf.cplace.solution.okr.keyResult"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Keyresult\n*Triggering attributes:\n*Description: whenever the confidencelevel o the keyResult is changed this changelistener updates the same in progress \n*Author: Laxmi udapudi\n*/\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast'\n  }\n}\nconst PROGRESS = {\n  TYPE: 'cf.cplace.solution.okr.progress',\n  ATTR: {\n    KEY_RESULT: 'cf.cplace.solution.okr.keyResult',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast'\n  }\n}\n\ncplace.setLogName('sync_gf_on_progress')\n\nfunction main() {\n\n  let keyresult = changeEvent.getEntity();\n  let gradingForecast = keyresult.get(KEY_RESULT.ATTR.GRADING_FORECAST);\n  let progress = keyresult.get(KEY_RESULT.ATTR.PROGRESS);\n  let processGrading = progress.get(PROGRESS.ATTR.GRADING_FORECAST);\n\n  if (!isSet(progress) || !isSet(gradingForecast)) {\n    // Nothing to sync with\n    return;\n  }\n\n  if (gradingForecast === processGrading) {\n    return;\n  }\n\n  updatePage(progress, {\n    'cf.cplace.solution.okr.gradingForecast': gradingForecast\n  })\n}\n\nreturn main();\n\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}",
        "attributes": [
            "cf.cplace.solution.okr.gradingForecast"
        ],
        "type_name": "cf.cplace.solution.okr.keyResult"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "const KEY_RESULT = {\n  TYPE : 'cf.cplace.solution.okr.keyResult',\n  ATTR :{\n    PROGRESS : 'cf.cplace.solution.okr.progress',\n    CONFIDENCE_LEVEL :'cf.cplace.solution.okr.confidenceLevel',\n    PROGRESS_INDICATOR : 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\nconst PROGRESS = {\n  TYPE : 'cf.cplace.solution.okr.progress',\n  ATTR : {\n    KEY_RESULT:'cf.cplace.solution.okr.keyResult',\n    CONFIDENCE_LEVEL:'cf.cplace.solution.okr.confidenceLevel',\n    PROGRESS_INDICATOR :'cf.cplace.solution.okr.progressIndicator'\n  }\n}\n\ncplace.setLogName('set _outdated_ProgressIndicator');\n\nfunction main(){\n  let page = changeEvent.getEntity();\n  let indicator = page.get(KEY_RESULT.ATTR.PROGRESS_INDICATOR);\n  let progress = page.get(KEY_RESULT.ATTR.PROGRESS);\n  // only update outdated, all other indicators should be updated when sync of confidencelevel happens\n  if (!isSet(progress) || !isSet(indicator)) {\n    // Nothing to sync\n    return;\n  }\n  let resultIndicator = progress.get(PROGRESS.ATTR.PROGRESS_INDICATOR);\n  if (indicator === '#45 outdated' && resultIndicator !== '#45 outdated') {\n    return updateIndicator(progress,indicator);\n  }\n  if (indicator !== '#45 outdated' && resultIndicator === '#45 outdated') {\n    return updateIndicator(progress,indicator);\n  }\n}\n\nreturn main();\n\nfunction updateIndicator(progress,indicator) {\n  cplace.log(\"Keyresult updates indicator\")\n  cplace.actions().updatePage(progress, {\n    customAttributes: {\n      'cf.cplace.solution.okr.progressIndicator': indicator\n    }\n  }\n                             );\n  progress.registerAttributeForRefresh('cf.cplace.solution.okr.progressIndicator');\n}\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}",
        "attributes": [
            "cf.cplace.solution.okr.progressIndicator"
        ],
        "type_name": "cf.cplace.solution.okr.keyResult"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Keyresult\n*Description: whenever the progressIndicator of the keyResult is changed this changelistener updates the confidencelvel\n*Author: Laxmi udapudi\n*/\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\nconst PROGRESS = {\n  TYPE: 'cf.cplace.solution.okr.progress',\n  ATTR: {\n    KEY_RESULT: 'cf.cplace.solution.okr.keyResult',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\ncplace.setLogName('sync_ProgressIndicator_on_progress');\n\nfunction main() {\n  let keyResult = changeEvent.getEntity();\n  let progressIndicator = keyResult.get(KEY_RESULT.ATTR.PROGRESS_INDICATOR);\n  let confidenceLevel = keyResult.get(KEY_RESULT.ATTR.CONFIDENCELEVEL);\n\n  switch (progressIndicator) {\n    case '#45 outdated':\n      // Do nothing\n      break;\n    case '#15 green':\n      if (parseFloat(confidenceLevel) < 0.7) {\n        updatePage(keyResult, {\n          'cf.cplace.solution.okr.confidenceLevel': '0.7'\n        })\n      }\n      break;\n    case '#25 yellow':\n      if (parseFloat(confidenceLevel) < 0.4 || parseFloat(confidenceLevel) > 0.6) {\n        updatePage(keyResult, {\n          'cf.cplace.solution.okr.confidenceLevel': '0.5'\n        })\n      }\n      break;\n    case '#35 red':\n      if (parseFloat(confidenceLevel) > 0.3) {\n        updatePage(keyResult, {\n          'cf.cplace.solution.okr.confidenceLevel': '0.3'\n        })\n      }\n      break;\n    default:\n      updatePage(keyResult, {\n        'cf.cplace.solution.okr.confidenceLevel': '1'\n      })\n      break;\n  }\n}\n\nmain();\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}",
        "attributes": [
            "cf.cplace.solution.okr.progressIndicator"
        ],
        "type_name": "cf.cplace.solution.okr.keyResult"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Keyresult\n*Description: whenever the confidencelevel of the keyresult is changed this changelistener updates the progressIndicator\n*Author: Laxmi udapudi\n*/\n//cplace.setLogName('sync_cf_on_progress');\n\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\nconst PROGRESS = {\n  TYPE: 'cf.cplace.solution.okr.progress',\n  ATTR: {\n    KEY_RESULT: 'cf.cplace.solution.okr.keyResult',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\n\nfunction main() {\n  let keyresult = changeEvent.getEntity();\n  let confidenceLevel = keyresult.get(KEY_RESULT.ATTR.CONFIDENCELEVEL);\n\n  if (isSet(confidenceLevel)) {\n    cplace.log(\"Confidence set\");\n    let indicator = getIndicator(parseFloat(confidenceLevel));\n    let setIndicator = keyresult.get(KEY_RESULT.ATTR.PROGRESS_INDICATOR);\n\n    if (setIndicator === indicator) {\n      return;\n    }\n\n    cplace.log(\"confidence notequal indicator\");\n    updatePage(keyresult, {\n      'cf.cplace.solution.okr.progressIndicator': indicator\n    })\n  } else {\n    updatePage(keyresult, {\n      'cf.cplace.solution.okr.progressIndicator': '#35 red'\n    })\n\n  }\n}\n\nreturn main();\n\nfunction getIndicator(confidenceLevel) {\n  if (confidenceLevel < 0.4) {\n    return '#35 red';\n  }\n  if (confidenceLevel < 0.7) {\n    return '#25 yellow';\n  }\n  return '#15 green';\n}\n\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}",
        "attributes": [
            "cf.cplace.solution.okr.confidenceLevel"
        ],
        "type_name": "cf.cplace.solution.okr.keyResult"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Triggering Attribute : Give Big Support\n*Updates the receiveBigSupport on change of giveBigSupport\n*Author:laxmi Udapudi\n*/\n\n\n/*Set the distinguish name for log*/\ncplace.setLogName('cl_update_receive_big _Support')\nconst DEBUG = true;\n\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator',\n    BIG_SUPPORT: 'cf.cplace.solution.okr.giveBigSupport',\n    RECEIVE_SUPPORT: 'cf.cplace.solution.okr.receiveBigSupport'\n  }\n}\n\nfunction main() {\n  let keyResult = changeEvent.getEntity();\n  let currentSupports = keyResult.get(KEY_RESULT.ATTR.BIG_SUPPORT);\n  let oldSupports = changeEvent.getOldValues(KEY_RESULT.ATTR.BIG_SUPPORT);\n  let addedSupports = [];\n  let removedSupports = [];\n\n  currentSupports.forEach(function (support) {\n    if (!oldSupports.contains(support)) {\n      addedSupports.push(support);\n    }\n  });\n  oldSupports.forEach(function (support) {\n    if (!currentSupports.contains(support)) {\n      removedSupports.push(support);\n    }\n  });\n\n  log('Added: ' + addedSupports);\n  log('Removed: ' + removedSupports);\n\n  if (addedSupports.length === 0 && removedSupports.length === 0) {\n    return;\n  }\n\n  addedSupports.forEach(function (support) {\n    addReference(keyResult, support);\n  });\n  removedSupports.forEach(function (support) {\n    removeReference(keyResult, support);\n  })\n}\n\nreturn main();\n\n/*\n*function checks for the duplicates and updates the receive big support \n*@params{provider,recevier}\n*/\nfunction addReference(provider, receiver) {\n  let receiverValues = receiver.get(KEY_RESULT.ATTR.RECEIVE_SUPPORT) || [];\n\n  // Avoid duplication\n  if (receiverValues.contains(provider)) {\n    return;\n  }\n\n  let newValues = [...receiverValues, provider];\n  updatePage(receiver, {\n    'cf.cplace.solution.okr.receiveBigSupport': newValues\n  })\n\n}\n\n/*\n*function removes the reference and updates the receive big support \n*@params{provider,recevier}\n*/\n\nfunction removeReference(provider, receiver) {\n  let receiverValues = receiver.get(KEY_RESULT.ATTR.RECEIVE_SUPPORT) || [];\n  let newValues = [];\n\n  receiverValues.forEach(function (element) {\n    if (element.getId() !== provider.getId()) {\n      newValues.push(element);\n    }\n  });\n\n  updatePage(receiver, {\n    'cf.cplace.solution.okr.receiveBigSupport': newValues\n  })\n}\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}\n\n/**\n* Log to cplace\n* @param {any} text\n*/\nfunction log(text) {\n  if (!DEBUG) {\n    return\n  }\n  let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n  cplace.log(logOutput);\n}",
        "attributes": [
            "cf.cplace.solution.okr.giveBigSupport"
        ],
        "type_name": "cf.cplace.solution.okr.keyResult"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "const KEY_RESULT = {\n  TYPE : 'cf.cplace.solution.okr.keyResult',\n  ATTR :{\n    PROGRESS : 'cf.cplace.solution.okr.progress',\n    CONFIDENCE_LEVEL :'cf.cplace.solution.okr.confidenceLevel',\n  }\n}\nconst PROGRESS = {\n  TYPE : 'cf.cplace.solution.okr.progress',\n  ATTR : {\n    KEY_RESULT:'cf.cplace.solution.okr.keyResult',\n    CONFIDENCE_LEVEL:'cf.cplace.solution.okr.confidenceLevel',\n  }\n}\nfunction main(){\n  //const attributeToSync = 'cf.cplace.solution.okr.confidenceLevel';\n  let page = changeEvent.getEntity();\n  let confidenceLevel = page.get(PROGRESS.ATTR.CONFIDENCE_LEVEL);\n  let keyResult = page.get(PROGRESS.ATTR.KEY_RESULT);\n  if (!isSet(keyResult) || !isSet(confidenceLevel)) {\n    // Nothing to sync with\n    return;\n  }\n  let resultConfidence = keyResult.get(KEY_RESULT.ATTR.CONFIDENCE_LEVEL);\n  if (confidenceLevel === resultConfidence)  {\n    return;\n  }\n  cplace.actions().updatePage(keyResult, {\n    customAttributes: {\n      'cf.cplace.solution.okr.confidenceLevel': confidenceLevel\n    }\n  }\n                             );\n  keyResult.registerAttributeForRefresh('cf.cplace.solution.okr.confidenceLevel');\n}\n\nreturn main();\n\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}",
        "attributes": [
            "cf.cplace.solution.okr.confidenceLevel"
        ],
        "type_name": "cf.cplace.solution.okr.progress"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Progress\n*Description: whenever the gradingForecast of the progress is changed this changelistener updates the same in keyResult\n*Triggering attribute : \n*Author: Laxmi udapudi\n*/\n\ncplace.setLogName('set_gf_on_progress')\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast'\n  }\n}\nconst PROGRESS = {\n  TYPE: 'cf.cplace.solution.okr.progress',\n  ATTR: {\n    KEY_RESULT: 'cf.cplace.solution.okr.keyResult',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast'\n  }\n}\n\nfunction main() {\n\n  let progress = changeEvent.getEntity();\n  let gradingForecast = progress.get(PROGRESS.ATTR.GRADING_FORECAST);\n  let keyResult = progress.get(PROGRESS.ATTR.KEY_RESULT);\n  let processGrading = keyResult.get(KEY_RESULT.ATTR.GRADING_FORECAST);\n\n  if (!isSet(progress) || !isSet(gradingForecast)) {\n    // Nothing to sync with\n    return;\n  }\n\n  if (gradingForecast === processGrading) {\n    return;\n  }\n\n  updatePage(keyResult, {\n    'cf.cplace.solution.okr.gradingForecast': gradingForecast\n  })\n}\n\nreturn main();\n\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}",
        "attributes": [
            "cf.cplace.solution.okr.gradingForecast"
        ],
        "type_name": "cf.cplace.solution.okr.progress"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Progress\n*Description: whenever the progressIndicator of the progress is changed this changelistener updates the same in keyResult\n*Triggering attribute : \n*Author: Laxmi udapudi\n*/\ncplace.setLogName('sync_progressIndicator_on_keyresult')\n\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n\n  }\n}\nconst PROGRESS = {\n  TYPE: 'cf.cplace.solution.okr.progress',\n  ATTR: {\n    KEY_RESULT: 'cf.cplace.solution.okr.keyResult',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\n\nfunction main() {\n\n  let progress = changeEvent.getEntity();\n  let progressIndicator = progress.get(PROGRESS.ATTR.PROGRESS_INDICATOR);\n  let keyResult = progress.get(PROGRESS.ATTR.KEY_RESULT);\n  let processIndicator = keyResult.get(PROGRESS.ATTR.PROGRESS_INDICATOR);\n\n  if (!isSet(progress) || !isSet(progressIndicator)) {\n    // Nothing to sync with\n    return;\n  }\n\n  if (progressIndicator === processIndicator) {\n    return;\n  }\n\n  updatePage(keyResult, {\n    'cf.cplace.solution.okr.progressIndicator': progressIndicator\n  })\n}\n\nreturn main();\n\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}",
        "attributes": [
            "cf.cplace.solution.okr.progressIndicator"
        ],
        "type_name": "cf.cplace.solution.okr.progress"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Keyresult\n*Description: whenever the progressIndicator of the progress is changed this changelistener updates the confidencelvel\n*Author: Laxmi udapudi\n*/\n\ncplace.setLogName('sync_PI_on_KR')\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\nconst PROGRESS = {\n  TYPE: 'cf.cplace.solution.okr.progress',\n  ATTR: {\n    KEY_RESULT: 'cf.cplace.solution.okr.keyResult',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\n\nfunction main() {\n  let progress = changeEvent.getEntity();\n  let progressIndicator = progress.get(PROGRESS.ATTR.PROGRESS_INDICATOR);\n  let confidenceLevel = progress.get(PROGRESS.ATTR.CONFIDENCELEVEL);\n\n  switch (progressIndicator) {\n    case '#45 outdated':\n      // Do nothing\n      break;\n    case '#15 green':\n      if (parseFloat(confidenceLevel) < 0.7) {\n        updatePage(progress, {\n          'cf.cplace.solution.okr.confidenceLevel': '0.7'\n        })\n      }\n      break;\n    case '#25 yellow':\n      if (parseFloat(confidenceLevel) < 0.4 || parseFloat(confidenceLevel) > 0.6) {\n        updatePage(progress, {\n          'cf.cplace.solution.okr.confidenceLevel': '0.5'\n        })\n      }\n      break;\n    case '#35 red':\n      if (parseFloat(confidenceLevel) > 0.3) {\n        updatePage(progress, {\n          'cf.cplace.solution.okr.confidenceLevel': '0.3'\n        })\n      }\n      break;\n    default:\n      updatePage(progress, {\n        'cf.cplace.solution.okr.confidenceLevel': '1'\n      })\n      break;\n  }\n}\n\nmain();\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}",
        "attributes": [
            "cf.cplace.solution.okr.progressIndicator"
        ],
        "type_name": "cf.cplace.solution.okr.progress"
    },
    {
        "type": "cf.cplace.platform.ChangeListener",
        "code": "/*\n*Changelistener\n*Type:Keyresult\n*Description: whenever the confidencelevel of the progress is changed this changelistener updates the progressIndicator\n*Author: Laxmi udapudi\n*/\ncplace.setLogName('sync_cf_on_KR')\nconst KEY_RESULT = {\n  TYPE: 'cf.cplace.solution.okr.keyResult',\n  ATTR: {\n    TITLE: 'cf.cplace.solution.okr.title',\n    PROGRESS: 'cf.cplace.solution.okr.progress',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\nconst PROGRESS = {\n  TYPE: 'cf.cplace.solution.okr.progress',\n  ATTR: {\n    KEY_RESULT: 'cf.cplace.solution.okr.keyResult',\n    CONFIDENCELEVEL: 'cf.cplace.solution.okr.confidenceLevel',\n    GRADING_FORECAST: 'cf.cplace.solution.okr.gradingForecast',\n    PROGRESS_INDICATOR: 'cf.cplace.solution.okr.progressIndicator'\n  }\n}\n\nfunction main() {\n  let progress = changeEvent.getEntity();\n  let confidenceLevel = progress.get(PROGRESS.ATTR.CONFIDENCELEVEL);\n\n  if (isSet(confidenceLevel)) {\n    cplace.log(\"Confidence set\");\n    let indicator = getIndicator(parseFloat(confidenceLevel));\n    let setIndicator = progress.get('cf.cplace.solution.okr.progressIndicator');\n\n    if (setIndicator === indicator) {\n      return;\n    }\n\n    cplace.log(\"confidence notequal indicator\");\n    updatePage(progress, {\n      'cf.cplace.solution.okr.progressIndicator': indicator\n    })\n  } else {\n    updatePage(progress, {\n      'cf.cplace.solution.okr.progressIndicator': '#35 red'\n    })\n\n  }\n}\n\nmain()\n\nfunction getIndicator(confidenceLevel) {\n  if (confidenceLevel < 0.4) {\n    return '#35 red';\n  }\n  if (confidenceLevel < 0.7) {\n    return '#25 yellow';\n  }\n  return '#15 green';\n}\n\n// Check if a value is set\nfunction isSet(value) {\n  return !!value;\n}\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n  let key = null;\n  for (key in customAttributes) {\n    if (customAttributes.hasOwnProperty(key)) {\n      page.registerAttributeForRefresh(key)\n    }\n  }\n  return cplace.actions().updatePage(page, {\n    customAttributes: customAttributes,\n  }\n    , {\n      setGeneratedName: true\n    }\n  );\n}",
        "attributes": [
            "cf.cplace.solution.okr.confidenceLevel"
        ],
        "type_name": "cf.cplace.solution.okr.progress"
    },
    {
        "type": "cf.cplace.platform.PageAction",
        "code": "/**\n * Raise Hands / Lower Hands action on task\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName('pageaction-task-raise-hands');\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst LABEL = {\n    RAISE: {\n        'en': 'Raise Hand',\n        'de': 'Hand heben'\n    },\n    LOWER: {\n        'en': 'Lower Hand',\n        'de': 'Hand runter'\n    }\n}\n\nconst RESULT_MESSAGE = {\n    RAISE: {\n        'en': 'Hand raised',\n        'de': 'Hand gehoben'\n    },\n    LOWER: {\n        'en': 'Hand lowered',\n        'de': 'Hand runter genommen'\n    }\n}\n\nconst ICON = {\n    RAISE: 'fa-hand-stop-o',\n    LOWER: 'fa-check'\n}\n\n\nconst TASK = {\n    TYPE: 'cf.cplace.digitalBoard.task',\n    ATTR: {\n        TITLE: 'cf.cplace.digitalBoard.title',\n        DESCRIPTION: 'cf.cplace.digitalBoard.description',\n        RESPONSIBLE: 'cf.cplace.digitalBoard.responsible',\n        BOARD: 'cf.cplace.digitalBoard.board',\n        SHARED_BOARDS: 'cf.cplace.digitalBoard.shareToOtherBoards',\n        PRIORITY: 'cf.cplace.digitalBoard.priority',\n        STATUS: 'cf.cplace.digitalBoard.status',\n        IS_PRIVATE: 'cf.cplace.digitalBoard.privateTask',\n        UPDATE_PERMISSIONS: 'cf.cplace.digitalBoard.updatePermissions',\n        ESCALATE_BOARD: 'cf.cplace.digitalBoard.escalateToBoard',\n        ESCALATION_LEVEL: 'cf.cplace.digitalBoard.escalationLevel',\n    },\n    STATUS: {\n        OPEN: 'open',\n        IN_PROGRESS: 'in progress',\n        IN_REVIEW: 'in review',\n        DONE: 'done',\n        ARCHIVED: 'archived'\n    },\n    ESCALATION_LEVEL: {\n        NONE: '#15 - none',\n        HAND_RAISED: '#25 - handRaised',\n        ESCALATED: '#35 - escalated',\n    }\n}\n\n\n\nfunction checkAccess() {\n    return true;\n}\n\nfunction label() {\n    return (page.get(TASK.ATTR.ESCALATION_LEVEL) === TASK.ESCALATION_LEVEL.NONE) ?\n        LABEL.RAISE : LABEL.LOWER\n}\n\nfunction icon() {\n    return (page.get(TASK.ATTR.ESCALATION_LEVEL) === TASK.ESCALATION_LEVEL.NONE) ?\n        ICON.RAISE : ICON.LOWER\n}\n\nfunction call() {\n    return doBusinessAction(page)\n}\n\nfunction main(){\nreturn {\n    checkAccess,\n    label,\n    icon,\n    call\n}\n}\n\nreturn main();\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Do the business action\n * \n * @param {Page} page \n * @returns {Object}\n */\nfunction doBusinessAction(page) {\n    let result = (page.get(TASK.ATTR.ESCALATION_LEVEL) === TASK.ESCALATION_LEVEL.NONE) ?\n        raiseHand(page) : lowerHand(page)\n    return {\n        success: true, // default is true\n        //job: jobId, //if your action starts a job and you want to show job modal\n        message: result // Override the success message to be displayed to the user or provide error message.\n    }\n}\n\nfunction raiseHand(task) {\n    let customAttributes = {};\n    customAttributes[TASK.ATTR.ESCALATION_LEVEL] = TASK.ESCALATION_LEVEL.HAND_RAISED;\n    updatePage(task, customAttributes);\n    return RESULT_MESSAGE.RAISE\n}\n\nfunction lowerHand(task) {\n    let customAttributes = {};\n    customAttributes[TASK.ATTR.ESCALATION_LEVEL] = TASK.ESCALATION_LEVEL.NONE;\n    updatePage(task, customAttributes);\n    return RESULT_MESSAGE.LOWER\n}\n\n\n\n/*\n*Update the cplace page whenever there is change in attributes\n* @param {Page<T>} page\n* @param {(keyof CplaceTypes[T])[]} attributes\n*/\nfunction updatePage(page, customAttributes) {\n    let key = null;\n    for (key in customAttributes) {\n        if (customAttributes.hasOwnProperty(key)) {\n            page.registerAttributeForRefresh(key)\n        }\n    }\n    return cplace.actions().updatePage(page, {\n        customAttributes: customAttributes,\n    }\n        , {\n            setGeneratedName: true\n        }\n    );\n}\n\n\n\n//--------------------------------------------------------------------------------------//\n//                                       HELPER FUNCTIONS                               //\n//--------------------------------------------------------------------------------------//\n\n\n/**\n * Log to cplace\n * @param {any} text \n */\nfunction log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": "cf.cplace.solution.okr.task"
    },
    {
        "type": "cf.cplace.platform.Validator",
        "code": "/*\n*Validator \n*checks for progressUpdated to be true\n*/\nfunction main() {\n   let result = null;\n   let updated = page.get('cf.cplace.solution.okr.progressUpdated');\n\n   if (!updated) {\n      result = 'The progess must be updated!';\n   }\n\n   return result;\n}\n\nreturn main();",
        "attributes": null,
        "type_name": "cf.cplace.solution.okr.progressUpdated"
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"./typeDefinitions/cplaceJS_type.js\" />\n/**\n * Template for Highchart\n * \n * Instructions:\n * - configure a highchart widget with a search or connected table\n * - look in this script for the following line: !!!! CHANGE FROM HERE !!!! and change your options there\n * - the main options are: BASE_ATTRIBUTE and CHART_TYPE_SELECTED\n * \n * TODO:\n * - Color Attribute\n * - builtin Attributes\n * - more charts\n * - date format for series / data points\n * - multi language\n * - Alias label for internal names\n * - sort of series\n *   \n * \n * \n * @author Bastian Rang <bastian.rang@collaboration-factory.de>\n * @version 2021-08-05\n */\n\n/**\n * ======================\n * LOG AND DEBUG SETTINGS\n * ======================\n */\n const DEBUG = true;\n\n /**\n  * Hint: set a declarative name for all of your logs\n  */\n cplace.setLogName(\"highchart-template\");\n \n /**\n  * ===================\n  * CONFIGURATION STAGE\n  * ===================\n  */\n \n /**\n  * DO NOT CHANGE THESE CONFIGURATIONS WITHOUT STRONG REASON !!!!!\n  */\n const CHART_DEFINITION = {\n     PIE: {\n         chart: {\n             type: 'pie'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     SEMICIRCLE: {\n         chart: {\n             type: 'pie'\n         },\n         plotOptions: {\n             startAngle: -90,\n             endAngle: 90,\n             center: ['50%', '75%'],\n             size: '110%',\n             innerSize: '70%'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     BAR: {\n         chart: {\n             type: 'bar'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n     COLUMN: {\n         chart: {\n             type: 'column'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n }\n \n \n \n /**\n  * ==================================================================================\n  * !!!! CHANGE FROM HERE !!!!\n  */\n \n /**\n  * Optional: Show a title inside of the chart area\n  */\n const CHART_TITLE = ''\n \n /**\n  * Set to null or leave blank to use the Pagename\n  * \n  * TODO builtinFeatureValue starts with underscore: '_creator'\n  */\n const BASE_ATTRIBUTE = 'cf.cplace.solution.okr.progressIndicator';\n \n /**\n  * Optional: Stacking is only possible for bar and column charts\n  * \n  */\n const STACK_ATTRIBUTE = null;\n \n /**\n  * Optional: Define an attribute of the page that acts as weight. If null, each entry has a weight of 1.\n  * The weight is used as sum of each datapoint.\n  */\n const WEIGHT_ATTRIBUTE = null;\n \n /**\n  * Define the base type of the chart: \n  * - CHART_DEFINITION.PIE\n  * - CHART_DEFINITION.SEMICIRCLE\n  * - CHART_DEFINITION.BAR\n  * - CHART_DEFINITION.COLUMN\n  */\n const CHART_TYPE_SELECTED = CHART_DEFINITION.PIE;\n \n /**\n  * Define colors for the chart\n  */\n const CHART_COLORS = {\n     BACKGROUND: '#F2F4FA',\n     TEXT: 'var(--text-color)',\n     SERIES: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a'],\n     CATEGORY: {\n         '#15 green': '#AEDB3C',\n         '#25 yellow': '#FFBA00',\n         '#35 red': '#DB0F35',\n         '#45 outdated': '#bcbcbc'\n     }\n }\n \n /**\n  * @type {Boolean} sort axes ascending (true) or descending (false)\n  */\n const CHART_SORT_ASCENDING = true;\n \n /**\n  * @type {Boolean} show legend under chart\n  */\n const CHART_SHOW_LEGEND = false;\n \n /**\n  * @type {Boolean} show labels on all datapoints\n  */\n const CHART_SHOW_LABELS = false;\n \n /**\n  * @type {Boolean} show values as percentage\n  */\n const CHART_SHOW_PERCENTAGE = false;\n \n /**\n  * @type {null|String} override tooltip text\n  * - use {point.y} as placeholder for absolute values\n  * - use {point.percentage:.1f}% as placeholder for percantage\n  * - use {point.stackTotal} for sum of stack\n  * - use {point.name} for name of data point\n  * - use {series.name} for name of data series\n  */\n const CHART_TOOLTIP_OVERRIDE = null;\n \n \n /**\n  * DO NOT CHANGE AFTER THIS LINE\n  * ==================================================================================\n  */\n \n const CHART_IS_STACKED = !!STACK_ATTRIBUTE && CHART_TYPE_SELECTED.isStackable;\n \n const CHART_POINT_FORMAT = (CHART_TYPE_SELECTED.isPercentageAvailable && CHART_SHOW_PERCENTAGE) ? '{point.percentage:.1f}%' : '{point.y}'\n \n /**\n  * ====================\n  * INITIALIZATION STAGE\n  * ====================\n  */\n \n let config = {\n     title: {\n         text: CHART_TITLE,\n         align: 'center',\n         verticalAlign: 'middle',\n         margin: 0,\n         useHtml: true,\n         style: {\n             color: CHART_COLORS.TEXT,\n             fontSize: \"2em\",\n             fontWeight: \"bold\"\n         }\n     },\n     chart: CHART_TYPE_SELECTED.chart,\n     legend: {\n         enabled: CHART_SHOW_LEGEND,\n         layout: 'horizontal',\n         align: 'center',\n         verticalAlign: 'bottom',\n         itemStyle: {\n             color: CHART_COLORS.TEXT,\n             fontWeight: \"normal\"\n         }\n     },\n     pane: {\n         size: '100%'\n     },\n     tooltip: {\n         pointFormat: '<b>' + CHART_POINT_FORMAT + '</b>'\n     },\n     plotOptions: {\n         pie: {\n            borderWidth: 10,\n            borderColor: 'var(--body-bg)',\n         },\n         series: {\n             showInLegend: CHART_SHOW_LEGEND,\n             dataLabels: {\n                 enabled: CHART_SHOW_LABELS,\n                 format: '<b>{point.name}</b>: ' + CHART_POINT_FORMAT\n             },\n             cursor: 'pointer',\n             stacking: (CHART_IS_STACKED && CHART_SHOW_PERCENTAGE) ? 'percent' : CHART_IS_STACKED\n         }\n     },\n     colors: CHART_COLORS.SERIES,\n     series: [],\n     xAxis: {\n         type: 'category'\n     },\n     yAxis: {\n         allowDecimals: false,\n         title: ''\n     }\n }\n \n config.chart.backgroundColor = CHART_COLORS.BACKGROUND\n config.chart.spacingBottom = 0\n config.chart.spacingTop = 0\n \n if (CHART_TITLE && CHART_SHOW_LEGEND && CHART_TYPE_SELECTED.hasFloatingTitle) {\n     config.title.verticalAlign = 'top'\n }\n \n if (CHART_TYPE_SELECTED.plotOptions) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type] = CHART_TYPE_SELECTED.plotOptions;\n }\n \n if (CHART_IS_STACKED) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type].colorByPoint = false;\n     config.tooltip.pointFormat = '{series.name}: ' + CHART_POINT_FORMAT + '<br/>Total: {point.stackTotal}'\n     config.plotOptions.series.dataLabels.format = '{series.name}: ' + CHART_POINT_FORMAT\n }\n \n if (CHART_TOOLTIP_OVERRIDE !== null) {\n     config.tooltip.pointFormat = CHART_TOOLTIP_OVERRIDE;\n }\n \n \n /**\n  * ================\n  * PROCESSING STAGE\n  * ================ \n  */\n if (pages.length === 0) {\n     return config\n }\n \n let datasetSize = pages.length;\n let series = [];\n let series_labels = {};\n let categories = {};\n let data = {};\n let pageCounter = 0;\n pages.forEach(function (page) {\n     let value = getValueAndLabelOfAttribute(page, BASE_ATTRIBUTE)\n     let weight = 1;\n     if (value === null) {\n         return\n     }\n \n     let series = getValueAndLabelOfAttribute(page, STACK_ATTRIBUTE);\n \n     if (!CHART_IS_STACKED || series === null) {\n         series = {\n             value: '',\n             label: CHART_TITLE\n         }\n     }\n \n     if (WEIGHT_ATTRIBUTE) {\n         weight = page.get(WEIGHT_ATTRIBUTE) || 1\n     }\n \n     if (value.length) {\n         value.forEach(function (item) {\n             addSeriesData(item, weight, series, data, categories, series_labels)\n         })\n     } else {\n         addSeriesData(value, weight, series, data, categories, series_labels)\n     }\n     pageCounter++;\n });\n\n // This will display the number of pages in the center\n config.title.text += pageCounter;\n \n /**\n  * TODO Sort stacked series, too\n  */\n \n Object.keys(series_labels).sort().forEach(function (series_label) {\n     series_labels[series_label] = series.length\n \n     series.push({\n         name: series_label,\n         type: CHART_TYPE_SELECTED.chart.type,\n         data: [],\n         innerSize: '50%'\n     })\n \n })\n \n Object.keys(data).forEach(function (key) {\n     let currentDataItem = {\n         name: data[key].name,\n         y: data[key].count\n     }\n     let seriesId = series_labels[data[key].series]\n \n     if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series_internal)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series_internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].internal)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].name)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].name]\n     }\n \n     series[seriesId].data.push(currentDataItem)\n })\n \n /**\n  * Add empty entries to series and sort them\n  */\n  let allDataKeys = [];\n  Object.keys(data).forEach(function (key) {\n      let label = data[key].name;\n      if (allDataKeys.indexOf(label) !== -1) {\n          return;\n      }\n  \n      series.forEach(function (serie) {\n          if (!serie.data.some(function (data) {\n                  return data.name === label\n              })) {\n              serie.data.push({\n                  name: label,\n                  y: 0\n              })\n          }\n      })\n      allDataKeys.push(label)\n  })\n \n /**\n  * sort series.data by name\n  */\n series.forEach(function (serie) {\n     serie.data.sort(function (a, b) {\n         if (!a.hasOwnProperty('name') || a.name == b.name) {\n             return 0\n         }\n         /**\n          * sort depending on CHART_SORT_ASCENDING\n          */\n         return ((CHART_SORT_ASCENDING && a.name > b.name) || (!CHART_SORT_ASCENDING && a.name < b.name)) ? 1 : -1\n     })\n })\n \n /**\n  * ============\n  * OUTPUT STAGE\n  * ============ \n  */\n \n config.series = series;\n return config;\n \n /**\n  * ==================\n  * BUSINESS FUNCTIONS\n  * ==================\n  */\n \n /**\n  * ================\n  * HELPER FUNCTIONS\n  * ================\n  */\n \n /**\n  * \n  * @param {object} value \n  * @param {Number} weight \n  * @param {object} series \n  * @param {object[]} data \n  * @param {object[]} categories \n  * @param {String[]} series_labels \n  */\n function addSeriesData(value, weight, series, data, categories, series_labels) {\n     let key = value.value + series.value;\n \n     if (data[key] === undefined) {\n         data[key] = {\n             count: 0,\n             name: value.label,\n             internal: value.value,\n             series: series.label,\n             series_internal: series.value\n         }\n     }\n \n     data[key].count += weight || 1;\n \n     if (!categories.hasOwnProperty(data[key].name)) {\n         categories[data[key].name] = 0\n     }\n \n     if (!series_labels.hasOwnProperty(data[key].series)) {\n         series_labels[data[key].series] = 0\n     }\n }\n \n \n /**\n  * \n  * @param {Page} page \n  * @param {object} attribute \n  * @returns \n  */\n function getValueAndLabelOfAttribute(page, attribute) {\n     let result = null;\n     if (!page) {\n         return result;\n     }\n     if (!attribute) {\n         return {\n             value: page.getRealUid(),\n             label: page.getName()\n         };\n     }\n \n     let value = page.get(attribute, false);\n     if (value === null) {\n         return result;\n     }\n     let value_label = page.get(attribute, true) || value;\n \n     let className = typeof value === 'object' ? String(value.getClass()) : 'String'\n \n     switch (className) {\n         case 'String':\n         case 'class java.lang.String':\n             result = {\n                 value: value,\n                 label: value_label\n             }\n             break;\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedGroup':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPerson':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPage':\n             result = {\n                 value: value.getRealUid(),\n                 label: value.getName()\n             }\n             break;\n         case 'class java.util.ArrayList':\n         case 'class com.google.common.collect.SingletonImmutableList':\n         case 'class com.google.common.collect.RegularImmutableList':\n             /**\n              * TODO Multi-Value\n              */\n             result = [];\n             cplace.each(value, function (item) {\n                 if (typeof item !== 'object' || String(item.getClass()) === 'class java.lang.String') {\n                     /**\n                      * FIXME enum label / enum internal name\n                      */\n                     result.push({\n                         value: item,\n                         label: item\n                     })\n                 } else {\n                     result.push({\n                         value: item.getRealUid(),\n                         label: item.getName()\n                     })\n                 }\n             })\n             break;\n         default:\n             /**\n              * TODO Reference\n              */\n             log('Class of ' + value + ' is \"' + value.class + '\"')\n             log(typeof value.class)\n             log(typeof value)\n     }\n \n     return result\n }\n \n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n function log(text) {\n     if (!DEBUG) {\n         return\n     }\n     let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n \n     cplace.log(logOutput);\n }",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/*\n*Highchart\n*Displays the cycle timeline\n*/\n\n\nconst CYCLE = {\n    TYPE: 'cf.cplace.solution.okr.cycle',\n    ATTR: {\n        START: 'cf.cplace.solution.okr.start',\n        END: 'cf.cplace.solution.okr.end',\n        YEAR: 'cf.cplace.solution.okr.year',\n        STATUS: 'cf.cplace.solution.okr.status'\n    }\n}\n\nconst MEETING = {\n    TYPE: 'cf.cplace.solution.okr.meeting',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.okr.title',\n        MEETING_TYPE: 'cf.cplace.solution.okr.meetingType',\n        DATE: 'cf.cplace.solution.okr.date',\n        CYCLE: 'cf.cplace.solution.okr.cycle'\n    }\n}\n\n/*************INITIALIZATION************* */\nconst dataObj = { cycleNames: [], seriesCyclePhase: [], seriesInputPhase: [], seriesWorkshop: [], seriesStrategy: [] }\nconst counterArray = [];\nconst row = 0;\nconst values = [];\nconst sortedPages = []\n\nlet workshop;\nlet workshopDate;\nlet messages = {\n    inputPhase: {\n        en: 'Input Phase ',\n        de: 'Input-Phase '\n    },\n    cyclePhase: {\n        en: 'Cycle Implementation Phase ',\n        de: 'Cycle Umsetzungs-Phase '\n    },\n    workshop: {\n        en: 'Workshop ',\n        de: 'Workshop '\n    },\n    strategy: {\n        en: 'Strategy Update ',\n        de: 'Strategie Update '\n    }\n};\n\nfunction genearteData(embeddingPage) {\n    const cycle = embeddingPage;\n    const cycleName = cycle.getName();\n    const cycleStart = cycle.get(CYCLE.ATTR.START);\n    const cycleEnd = cycle.get(CYCLE.ATTR.END);\n    const lang = cplace.utils().getCurrentUser().getUserLanguage();\n    const meetings = cycle.getIncomingPages(MEETING.TYPE, MEETING.ATTR.CYCLE);\n    cplace.each(meetings, function (meeting) {\n        if (meeting.get('cf.cplace.solution.okr.meetingType') == \"Workshop\") {\n            workshop = meeting;\n        };\n    })\n\n    if (workshop) {\n        workshopDate = workshop.get(MEETING.ATTR.DATE);\n    }\n\n    if (cycleStart && cycleEnd && workshop) {\n\n        dataObj.cycleNames.push(cycleName);\n        dataObj.seriesCyclePhase.push({\n            x: cycleStart.getMillis(),\n            x2: cycleEnd.getMillis(),\n            y: row,\n            color: '#006ae5',\n            dataLabels: {\n                format: messages.cyclePhase[lang] + cycleName\n            },\n            name: messages.cyclePhase[lang] + cycleName\n        });\n        dataObj.seriesInputPhase.push({\n            x: workshopDate.minusDays(21).getMillis(),\n            x2: workshopDate.getMillis(),\n            color: '#00ffcd',\n            y: row,\n            dataLabels: {\n                format: messages.inputPhase[lang]\n            },\n            name: messages.inputPhase[lang] + cycleName\n        });\n        dataObj.seriesWorkshop.push({\n            x: workshopDate.getMillis(),\n            y: row,\n            date: cycleStart.toString(\"MMM/dd\"),\n            dataLabels: {\n                format: messages.workshop[lang]\n            },\n            color: '#151821',\n            name: messages.inputPhase[lang]\n        })\n        dataObj.seriesStrategy.push({\n            x: cycleEnd.minusDays(28).getMillis(),\n            y: row,\n            date: cycleStart.toString(\"MMM/dd\"),\n            color: '#151821',\n            dataLabels: {\n                format: messages.strategy[lang]\n            },\n            name: messages.strategy[lang]\n        })\n    }\n\n    return dataObj;\n\n}\nfunction main() {\n    const data = genearteData(embeddingPage);\n\n    const chart = {\n        chart: {\n            type: 'xrange',\n            zoomType: 'x',\n            backgroundColor: '#F2F4FA',\n        },\n        legend: {\n            enabled: false\n        },\n        title: {\n            text: ''\n        },\n        xAxis: {\n            type: 'datetime',\n            plotLines: [{\n                value: new Date().setHours(0),\n                dashStyle: 'dash',\n                width: 2,\n                zIndex: 5,\n            }],\n            lineColor: '#F2F4FA',\n            tickLength: 1,\n        },\n        yAxis: {\n            title: '',\n            labels: {\n                enabled: false\n            },\n            gridLineColor: 'rgba(255,255,255,0)',\n            lineColor: '#F2F4FA',\n            categories: data.cycleNames,\n            reversed: true,\n            max: 0\n        },\n        plotOptions: {\n            series: {\n                borderRadius: 5,\n                dataLabels: {\n                    enabled: true\n                }\n            }\n        },\n        series: [{\n            name: '',\n            data: data.seriesCyclePhase,\n            dataLabels: {\n                enabled: true\n            }\n        }, {\n            name: '',\n            data: data.seriesInputPhase,\n            dataLabels: {\n                enabled: true\n            }\n        }, {\n            type: 'scatter',\n            stickyTracking: false,\n            marker: {\n                enabled: true,\n                symbol: 'diamond',\n                lineColor: 'white',\n                lineWidth: 1,\n                radius: 13\n            },\n            data: data.seriesWorkshop\n        }, {\n            type: 'scatter',\n            stickyTracking: false,\n            marker: {\n                enabled: true,\n                symbol: 'diamond',\n                lineColor: 'white',\n                lineWidth: 1,\n                radius: 13\n            },\n            data: data.seriesStrategy\n        }],\n        tooltip: {\n            enabled: false\n        }\n    };\n    return chart\n}\n\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var cycle = embeddingPage;\nvar meetings = cycle.getIncomingPages('cf.cplace.solution.okr.meeting', 'cf.cplace.solution.okr.cycle');\nvar workshop;\ncplace.each(meetings, function(meeting) {\n  if (meeting.get('cf.cplace.solution.okr.meetingType') == \"Workshop\") {\n    workshop = meeting;\n  };\n})\n\nvar cycleNames = [];\nvar counterArray = [];\nvar row = 0;\nvar values = [];\nvar sortedPages = []\nvar seriesCyclePhase = [];\nvar seriesInputPhase = [];\nvar seriesWorkshop = [];\nvar seriesStrategy = [];\nvar lang = cplace.utils().getCurrentUser().getUserLanguage();\n\nvar messages = {\n  inputPhase: {\n    en: 'Input Phase ',\n    de: 'Input-Phase '\n  },\n  cyclePhase: {\n    en: 'Cycle Implementation Phase ',\n    de: 'Cycle Umsetzungs-Phase '\n  },\n  workshop: {\n    en: 'Workshop ',\n    de: 'Workshop '\n  },\n  strategy: {\n    en: 'Strategy Update ',\n    de: 'Strategie Update '\n  }\n};\n\n\nvar cycleName = cycle.getName();\nvar cycleStart = cycle.get('cf.cplace.solution.okr.start');\nvar cycleEnd = cycle.get('cf.cplace.solution.okr.end');\nvar workshopDate;\nif (workshop) {\n  workshopDate = workshop.get('cf.cplace.solution.okr.date');  \n}\n\nif (cycleStart && cycleEnd && workshop) {\n\n  cycleNames.push(cycleName);\n  seriesCyclePhase.push({\n    x: cycleStart.getMillis(),\n    x2: cycleEnd.getMillis(),\n    y: row,\n    color: '#006ae5',\n    dataLabels: {\n      format: messages.cyclePhase[lang] + cycleName\n    },\n    name: messages.cyclePhase[lang] + cycleName\n  });\n  seriesInputPhase.push({\n    x: workshopDate.minusDays(21).getMillis(),\n    x2: workshopDate.getMillis(),\n    color: '#151821',\n    y: row,\n    dataLabels: {\n      format: messages.inputPhase[lang]\n    },\n    name: messages.inputPhase[lang] + cycleName\n  });\n  seriesWorkshop.push({\n    x: workshopDate.getMillis(),\n    y: row,\n    date: cycleStart.toString(\"MMM/dd\"),\n    dataLabels: {\n      format: messages.workshop[lang]\n    },\n    color: '#a5ffd6',\n    name: messages.inputPhase[lang]\n  })\n  seriesStrategy.push({\n    x: cycleEnd.minusDays(28).getMillis(),\n    y: row,\n    date: cycleStart.toString(\"MMM/dd\"),\n    color: '#a5ffd6',\n    dataLabels: {\n      format: messages.strategy[lang]\n    },\n    name: messages.strategy[lang]\n  })\n\n\n}\n\nvar chart = {\n  chart: {\n    type: 'xrange',\n    zoomType: 'x',\n\tbackgroundColor: '#F2F4FA',\n  },\n  legend: {\n    enabled: false\n  },\n  title: {\n    text: ''\n  },\n  xAxis: {\n    type: 'datetime',\n    plotLines: [{\n      value: new Date().setHours(0),\n      dashStyle: 'dash',\n      width: 2,\n      zIndex: 5,\n    }],\n    lineColor: '#F2F4FA',\n    tickLength: 1,\n  },\n  yAxis: {\n    title: '',\n    labels: {\n      enabled: false\n    },\n    gridLineColor: 'rgba(255,255,255,0)',\n    lineColor: '#F2F4FA',\n    categories: cycleNames,\n    reversed: true,\n    max: 0\n  },\n  plotOptions: {\n    series: {\n      borderRadius: 5,\n      dataLabels: {\n        enabled: true\n      }\n    }\n  },\n  series: [{\n    name: '',\n    data: seriesCyclePhase,\n    dataLabels: {\n      enabled: true\n    }\n  }, {\n    name: '',\n    data: seriesInputPhase,\n    dataLabels: {\n      enabled: true\n    }\n  }, {\n    type: 'scatter',\n    stickyTracking: false,\n    marker: {\n      enabled: true,\n      symbol: 'diamond',\n      lineColor: 'white',\n      lineWidth: 1,\n      radius: 13\n    },\n    data: seriesWorkshop\n  }, {\n    type: 'scatter',\n    stickyTracking: false,\n    marker: {\n      enabled: true,\n      symbol: 'diamond',\n      lineColor: 'white',\n      lineWidth: 1,\n      radius: 13\n    },\n    data: seriesStrategy\n  }],\n  tooltip: {\n    enabled: false\n  }\n};\nreturn chart",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"./typeDefinitions/cplaceJS_type.js\" />\n/**\n * Template for Highchart\n * \n * Instructions:\n * - configure a highchart widget with a search or connected table\n * - look in this script for the following line: !!!! CHANGE FROM HERE !!!! and change your options there\n * - the main options are: BASE_ATTRIBUTE and CHART_TYPE_SELECTED\n * \n * TODO:\n * - Color Attribute\n * - builtin Attributes\n * - more charts\n * - date format for series / data points\n * - multi language\n * - Alias label for internal names\n * - sort of series\n *   \n * \n * \n * @author Bastian Rang <bastian.rang@collaboration-factory.de>\n * @version 2021-08-05\n */\n\n/**\n * ======================\n * LOG AND DEBUG SETTINGS\n * ======================\n */\n const DEBUG = true;\n\n /**\n  * Hint: set a declarative name for all of your logs\n  */\n cplace.setLogName(\"highchart-template\");\n \n /**\n  * ===================\n  * CONFIGURATION STAGE\n  * ===================\n  */\n \n /**\n  * DO NOT CHANGE THESE CONFIGURATIONS WITHOUT STRONG REASON !!!!!\n  */\n const CHART_DEFINITION = {\n     PIE: {\n         chart: {\n             type: 'pie'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     SEMICIRCLE: {\n         chart: {\n             type: 'pie'\n         },\n         plotOptions: {\n             startAngle: -90,\n             endAngle: 90,\n             center: ['50%', '75%'],\n             size: '110%',\n             innerSize: '50%'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     BAR: {\n         chart: {\n             type: 'bar'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n     COLUMN: {\n         chart: {\n             type: 'column'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n }\n \n \n \n /**\n  * ==================================================================================\n  * !!!! CHANGE FROM HERE !!!!\n  */\n \n /**\n  * Optional: Show a title inside of the chart area\n  */\n const CHART_TITLE = ''\n \n /**\n  * Set to null or leave blank to use the Pagename\n  * \n  * TODO builtinFeatureValue starts with underscore: '_creator'\n  */\n const BASE_ATTRIBUTE = 'cf.cplace.solution.okr.progressIndicator';\n \n /**\n  * Optional: Stacking is only possible for bar and column charts\n  * \n  */\n const STACK_ATTRIBUTE = null;\n \n /**\n  * Optional: Define an attribute of the page that acts as weight. If null, each entry has a weight of 1.\n  * The weight is used as sum of each datapoint.\n  */\n const WEIGHT_ATTRIBUTE = null;\n \n /**\n  * Define the base type of the chart: \n  * - CHART_DEFINITION.PIE\n  * - CHART_DEFINITION.SEMICIRCLE\n  * - CHART_DEFINITION.BAR\n  * - CHART_DEFINITION.COLUMN\n  */\n const CHART_TYPE_SELECTED = CHART_DEFINITION.PIE;\n \n /**\n  * Define colors for the chart\n  */\n const CHART_COLORS = {\n     BACKGROUND: '#F2F4FA',\n     TEXT: 'var(--text-color)',\n     SERIES: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a'],\n     CATEGORY: {\n         '#15 green': '#AEDB3C',\n         '#25 yellow': '#FFBA00',\n         '#35 red': '#DB0F35',\n         '#45 outdated': '#bcbcbc'\n     }\n }\n \n /**\n  * @type {Boolean} sort axes ascending (true) or descending (false)\n  */\n const CHART_SORT_ASCENDING = true;\n \n /**\n  * @type {Boolean} show legend under chart\n  */\n const CHART_SHOW_LEGEND = false;\n \n /**\n  * @type {Boolean} show labels on all datapoints\n  */\n const CHART_SHOW_LABELS = false;\n \n /**\n  * @type {Boolean} show values as percentage\n  */\n const CHART_SHOW_PERCENTAGE = false;\n \n /**\n  * @type {null|String} override tooltip text\n  * - use {point.y} as placeholder for absolute values\n  * - use {point.percentage:.1f}% as placeholder for percantage\n  * - use {point.stackTotal} for sum of stack\n  * - use {point.name} for name of data point\n  * - use {series.name} for name of data series\n  */\n const CHART_TOOLTIP_OVERRIDE = null;\n \n \n /**\n  * DO NOT CHANGE AFTER THIS LINE\n  * ==================================================================================\n  */\n \n const CHART_IS_STACKED = !!STACK_ATTRIBUTE && CHART_TYPE_SELECTED.isStackable;\n \n const CHART_POINT_FORMAT = (CHART_TYPE_SELECTED.isPercentageAvailable && CHART_SHOW_PERCENTAGE) ? '{point.percentage:.1f}%' : '{point.y}'\n \n /**\n  * ====================\n  * INITIALIZATION STAGE\n  * ====================\n  */\n \n let config = {\n     title: {\n         text: CHART_TITLE,\n         align: 'center',\n         verticalAlign: 'middle',\n         margin: 0,\n         y: 10,\n         useHtml: true,\n         style: {\n             color: CHART_COLORS.TEXT,\n             fontSize: \"2em\",\n             fontWeight: \"bold\"\n         }\n     },\n     chart: CHART_TYPE_SELECTED.chart,\n     legend: {\n         enabled: CHART_SHOW_LEGEND,\n         layout: 'horizontal',\n         align: 'center',\n         verticalAlign: 'bottom',\n         itemStyle: {\n             color: CHART_COLORS.TEXT,\n             fontWeight: \"normal\"\n         }\n     },\n     pane: {\n         size: '100%'\n     },\n     tooltip: {\n         pointFormat: '<b>' + CHART_POINT_FORMAT + '</b>'\n     },\n     plotOptions: {\n         pie: {\n            borderWidth: 10,\n            borderColor: 'var(--body-bg)',\n         },\n         series: {\n             showInLegend: CHART_SHOW_LEGEND,\n             dataLabels: {\n                 enabled: CHART_SHOW_LABELS,\n                 format: '<b>{point.name}</b>: ' + CHART_POINT_FORMAT\n             },\n             cursor: 'pointer',\n             stacking: (CHART_IS_STACKED && CHART_SHOW_PERCENTAGE) ? 'percent' : CHART_IS_STACKED\n         }\n     },\n     colors: CHART_COLORS.SERIES,\n     series: [],\n     xAxis: {\n         type: 'category'\n     },\n     yAxis: {\n         allowDecimals: false,\n         title: ''\n     }\n }\n \n config.chart.backgroundColor = CHART_COLORS.BACKGROUND\n config.chart.spacingBottom = 0\n config.chart.spacingTop = 0\n \n if (CHART_TITLE && CHART_SHOW_LEGEND && CHART_TYPE_SELECTED.hasFloatingTitle) {\n     config.title.verticalAlign = 'top'\n }\n \n if (CHART_TYPE_SELECTED.plotOptions) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type] = CHART_TYPE_SELECTED.plotOptions;\n }\n \n if (CHART_IS_STACKED) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type].colorByPoint = false;\n     config.tooltip.pointFormat = '{series.name}: ' + CHART_POINT_FORMAT + '<br/>Total: {point.stackTotal}'\n     config.plotOptions.series.dataLabels.format = '{series.name}: ' + CHART_POINT_FORMAT\n }\n \n if (CHART_TOOLTIP_OVERRIDE !== null) {\n     config.tooltip.pointFormat = CHART_TOOLTIP_OVERRIDE;\n }\n \n \n /**\n  * ================\n  * PROCESSING STAGE\n  * ================ \n  */\n if (pages.length === 0) {\n     return config\n }\n \n let datasetSize = pages.length;\n let series = [];\n let series_labels = {};\n let categories = {};\n let data = {};\n let pageCounter = 0;\n pages.forEach(function (page) {\n     let value = getValueAndLabelOfAttribute(page, BASE_ATTRIBUTE)\n     let weight = 1;\n     if (value === null) {\n         return\n     }\n \n     let series = getValueAndLabelOfAttribute(page, STACK_ATTRIBUTE);\n \n     if (!CHART_IS_STACKED || series === null) {\n         series = {\n             value: '',\n             label: CHART_TITLE\n         }\n     }\n \n     if (WEIGHT_ATTRIBUTE) {\n         weight = page.get(WEIGHT_ATTRIBUTE) || 1\n     }\n \n     if (value.length) {\n         value.forEach(function (item) {\n             addSeriesData(item, weight, series, data, categories, series_labels)\n         })\n     } else {\n         addSeriesData(value, weight, series, data, categories, series_labels)\n     }\n     pageCounter++;\n });\n\n // This will display the number of pages in the center\n config.title.text += pageCounter;\n \n /**\n  * TODO Sort stacked series, too\n  */\n \n Object.keys(series_labels).sort().forEach(function (series_label) {\n     series_labels[series_label] = series.length\n \n     series.push({\n         name: series_label,\n         type: CHART_TYPE_SELECTED.chart.type,\n         data: [],\n         innerSize: '50%'\n     })\n \n })\n \n Object.keys(data).forEach(function (key) {\n     let currentDataItem = {\n         name: data[key].name,\n         y: data[key].count\n     }\n     let seriesId = series_labels[data[key].series]\n \n     if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series_internal)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series_internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].internal)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].name)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].name]\n     }\n \n     series[seriesId].data.push(currentDataItem)\n })\n \n /**\n  * Add empty entries to series and sort them\n  */\n  let allDataKeys = [];\n  Object.keys(data).forEach(function (key) {\n      let label = data[key].name;\n      if (allDataKeys.indexOf(label) !== -1) {\n          return;\n      }\n  \n      series.forEach(function (serie) {\n          if (!serie.data.some(function (data) {\n                  return data.name === label\n              })) {\n              serie.data.push({\n                  name: label,\n                  y: 0\n              })\n          }\n      })\n      allDataKeys.push(label)\n  })\n \n /**\n  * sort series.data by name\n  */\n series.forEach(function (serie) {\n     serie.data.sort(function (a, b) {\n         if (!a.hasOwnProperty('name') || a.name == b.name) {\n             return 0\n         }\n         /**\n          * sort depending on CHART_SORT_ASCENDING\n          */\n         return ((CHART_SORT_ASCENDING && a.name > b.name) || (!CHART_SORT_ASCENDING && a.name < b.name)) ? 1 : -1\n     })\n })\n \n /**\n  * ============\n  * OUTPUT STAGE\n  * ============ \n  */\n \n config.series = series;\n return config;\n \n /**\n  * ==================\n  * BUSINESS FUNCTIONS\n  * ==================\n  */\n \n /**\n  * ================\n  * HELPER FUNCTIONS\n  * ================\n  */\n \n /**\n  * \n  * @param {object} value \n  * @param {Number} weight \n  * @param {object} series \n  * @param {object[]} data \n  * @param {object[]} categories \n  * @param {String[]} series_labels \n  */\n function addSeriesData(value, weight, series, data, categories, series_labels) {\n     let key = value.value + series.value;\n \n     if (data[key] === undefined) {\n         data[key] = {\n             count: 0,\n             name: value.label,\n             internal: value.value,\n             series: series.label,\n             series_internal: series.value\n         }\n     }\n \n     data[key].count += weight || 1;\n \n     if (!categories.hasOwnProperty(data[key].name)) {\n         categories[data[key].name] = 0\n     }\n \n     if (!series_labels.hasOwnProperty(data[key].series)) {\n         series_labels[data[key].series] = 0\n     }\n }\n \n \n /**\n  * \n  * @param {Page} page \n  * @param {object} attribute \n  * @returns \n  */\n function getValueAndLabelOfAttribute(page, attribute) {\n     let result = null;\n     if (!page) {\n         return result;\n     }\n     if (!attribute) {\n         return {\n             value: page.getRealUid(),\n             label: page.getName()\n         };\n     }\n \n     let value = page.get(attribute, false);\n     if (value === null) {\n         return result;\n     }\n     let value_label = page.get(attribute, true) || value;\n \n     let className = typeof value === 'object' ? String(value.getClass()) : 'String'\n \n     switch (className) {\n         case 'String':\n         case 'class java.lang.String':\n             result = {\n                 value: value,\n                 label: value_label\n             }\n             break;\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedGroup':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPerson':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPage':\n             result = {\n                 value: value.getRealUid(),\n                 label: value.getName()\n             }\n             break;\n         case 'class java.util.ArrayList':\n         case 'class com.google.common.collect.SingletonImmutableList':\n         case 'class com.google.common.collect.RegularImmutableList':\n             /**\n              * TODO Multi-Value\n              */\n             result = [];\n             cplace.each(value, function (item) {\n                 if (typeof item !== 'object' || String(item.getClass()) === 'class java.lang.String') {\n                     /**\n                      * FIXME enum label / enum internal name\n                      */\n                     result.push({\n                         value: item,\n                         label: item\n                     })\n                 } else {\n                     result.push({\n                         value: item.getRealUid(),\n                         label: item.getName()\n                     })\n                 }\n             })\n             break;\n         default:\n             /**\n              * TODO Reference\n              */\n             log('Class of ' + value + ' is \"' + value.class + '\"')\n             log(typeof value.class)\n             log(typeof value)\n     }\n \n     return result\n }\n \n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n function log(text) {\n     if (!DEBUG) {\n         return\n     }\n     let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n \n     cplace.log(logOutput);\n }",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var lang = cplace.utils().getCurrentUser().getUserLanguage();\n\nvar messages = {\n  message: {\n    en: '<p style=\"font-size: 14px; margin-left: 5px;color:#343C4C\">Check the actuality of the Key Result Confidence Levels.</p> ',\n    de: '\u00dcberpr\u00fcfen Sie die Aktualit\u00e4t der Key Result Confidence Levels. '\n  }\n}\n\nreturn messages.message[lang]",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"../../typeDefinitions/globals.d.ts\" />\n\n/**\n * Description\n * @author \n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\n\n/**\n * Set to false to suspend logging\n * @type {Boolean}\n */\n const DEBUG = true;\n\n /**\n  * Set to false, to disable this page action\n  * @type {Boolean}\n  */\n  const ENABLED = true;\n \n  /**\n  * Get millisecond starting time of the script\n  * @type {Number}\n  */\n const START_TIME = new Date().getTime()\n \n /** @type {Number} */\n let LAST_TIME = START_TIME;\n \n /**\n  * Hint: set a declarative name for all of your logs\n  */\n  cplace.setLogName('pageaction-task-');\n\n  //--------------------------------------------------------------------------------------//\n //                                       CONFIGURATION                                  //\n //--------------------------------------------------------------------------------------//\n \n const REF_ATTRIBUTE = 'cf.cplace.solution.okr.set';\n\n // Everything older than this will be flaged als \"outdated\"\n const THRESHOLD_DAYS = 14;\n \n const ACTIONS = {\n    DEFAULT: 'DEFAULT',\n }\n //--------------------------------------------------------------------------------------//\n //                                       INITIALIZATION                                 //\n //--------------------------------------------------------------------------------------//\n \nreturn {\n    // \"checkAccess\" function will check if the button should be enabled given the current context\n    checkAccess: function() {\n        return true; // Allowed for all users\n    },\n    // \"call\" function contains the actual business logic and can optionally return an object\n    // containing a success message\n    call: function() {\n        log('Starting Low-Code button script execution');\n\n        doBusinessAction(embeddingPage)\n        \n        return {\n           message: {\n             de: 'Erfolgreich beendet',\n             en: 'Finished successfully'\n           }\n        }\n    }\n}\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS LOGIC                                 //\n//--------------------------------------------------------------------------------------//\n /**\n  * Do the business action\n  * \n  * @param {Page} page \n  * @returns {Object}\n  */\n  function doBusinessAction(page) {\n    let allResults = page.getIncomingPages('cf.cplace.solution.okr.progress', REF_ATTRIBUTE);\n\n    allResults.forEach(function(result) {\n       checkAndUpdatePage(result);\n    });\n    cplace.actions().refresh();\n\n    return {\n        success: true, // default is true\n        //job: jobId, //if your action starts a job and you want to show job modal\n        message: 'Outdated results have been flagged.'\n    }\n}\n\nfunction checkAndUpdatePage(page) {\n   let lastModified = page.get('cf.cplace.solution.okr.lastUpdate');\n   let now = new DateTime();\n\n   let refDate = now.minusDays(THRESHOLD_DAYS);\n\n   if (lastModified && refDate.isAfter(lastModified)) {\n       updatePage(page);\n   }\n}\n\nfunction updatePage(page) {\n   log(page.getName());\n   cplace.actions().updatePage(page, {\n       customAttributes: {\n           'cf.cplace.solution.okr.progressIndicator': '#45 outdated'\n       }\n   });\n\n   page.registerAttributeForRefresh('cf.cplace.solution.okr.progressIndicator');\n}\n\n//--------------------------------------------------------------------------------------//\n//                                       HELPER FUNCTIONS                               //\n//--------------------------------------------------------------------------------------//\n\n\n/**\n * Log to cplace\n * @param {any} text \n */\n function log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var set = embeddingPage;\nvar orgUnit = set.get('cf.cplace.solution.okr.organizationalUnit');\n\nreturn \"<div class='custom-stm-set-banner \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\" + orgUnit.getName() + \"</div>\"",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"./typeDefinitions/cplaceJS_type.js\" />\n/**\n * Template for Highchart\n * \n * Instructions:\n * - configure a highchart widget with a search or connected table\n * - look in this script for the following line: !!!! CHANGE FROM HERE !!!! and change your options there\n * - the main options are: BASE_ATTRIBUTE and CHART_TYPE_SELECTED\n * \n * TODO:\n * - Color Attribute\n * - builtin Attributes\n * - more charts\n * - date format for series / data points\n * - multi language\n * - Alias label for internal names\n * - sort of series\n *   \n * \n * \n * @author Bastian Rang <bastian.rang@collaboration-factory.de>\n * @version 2021-08-05\n */\n\n/**\n * ======================\n * LOG AND DEBUG SETTINGS\n * ======================\n */\n const DEBUG = true;\n\n /**\n  * Hint: set a declarative name for all of your logs\n  */\n cplace.setLogName(\"highchart-template\");\n \n /**\n  * ===================\n  * CONFIGURATION STAGE\n  * ===================\n  */\n \n /**\n  * DO NOT CHANGE THESE CONFIGURATIONS WITHOUT STRONG REASON !!!!!\n  */\n const CHART_DEFINITION = {\n     PIE: {\n         chart: {\n             type: 'pie'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     SEMICIRCLE: {\n         chart: {\n             type: 'pie'\n         },\n         plotOptions: {\n             startAngle: -90,\n             endAngle: 90,\n             center: ['50%', '75%'],\n             size: '110%',\n             innerSize: '50%'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     BAR: {\n         chart: {\n             type: 'bar'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n     COLUMN: {\n         chart: {\n             type: 'column'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n }\n \n \n \n /**\n  * ==================================================================================\n  * !!!! CHANGE FROM HERE !!!!\n  */\n \n /**\n  * Optional: Show a title inside of the chart area\n  */\n const CHART_TITLE = ''\n \n /**\n  * Set to null or leave blank to use the Pagename\n  * \n  * TODO builtinFeatureValue starts with underscore: '_creator'\n  */\n const BASE_ATTRIBUTE = 'cf.cplace.solution.okr.progressIndicator';\n \n /**\n  * Optional: Stacking is only possible for bar and column charts\n  * \n  */\n const STACK_ATTRIBUTE = null;\n \n /**\n  * Optional: Define an attribute of the page that acts as weight. If null, each entry has a weight of 1.\n  * The weight is used as sum of each datapoint.\n  */\n const WEIGHT_ATTRIBUTE = null;\n \n /**\n  * Define the base type of the chart: \n  * - CHART_DEFINITION.PIE\n  * - CHART_DEFINITION.SEMICIRCLE\n  * - CHART_DEFINITION.BAR\n  * - CHART_DEFINITION.COLUMN\n  */\n const CHART_TYPE_SELECTED = CHART_DEFINITION.PIE;\n \n /**\n  * Define colors for the chart\n  */\n const CHART_COLORS = {\n     BACKGROUND: '#F2F4FA',\n     TEXT: 'var(--text-color)',\n     SERIES: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a'],\n     CATEGORY: {\n         '#15 green': '#AEDB3C',\n         '#25 yellow': '#FFBA00',\n         '#35 red': '#DB0F35',\n         '#45 outdated': '#bcbcbc'\n     }\n }\n \n /**\n  * @type {Boolean} sort axes ascending (true) or descending (false)\n  */\n const CHART_SORT_ASCENDING = true;\n \n /**\n  * @type {Boolean} show legend under chart\n  */\n const CHART_SHOW_LEGEND = false;\n \n /**\n  * @type {Boolean} show labels on all datapoints\n  */\n const CHART_SHOW_LABELS = false;\n \n /**\n  * @type {Boolean} show values as percentage\n  */\n const CHART_SHOW_PERCENTAGE = false;\n \n /**\n  * @type {null|String} override tooltip text\n  * - use {point.y} as placeholder for absolute values\n  * - use {point.percentage:.1f}% as placeholder for percantage\n  * - use {point.stackTotal} for sum of stack\n  * - use {point.name} for name of data point\n  * - use {series.name} for name of data series\n  */\n const CHART_TOOLTIP_OVERRIDE = null;\n \n \n /**\n  * DO NOT CHANGE AFTER THIS LINE\n  * ==================================================================================\n  */\n \n const CHART_IS_STACKED = !!STACK_ATTRIBUTE && CHART_TYPE_SELECTED.isStackable;\n \n const CHART_POINT_FORMAT = (CHART_TYPE_SELECTED.isPercentageAvailable && CHART_SHOW_PERCENTAGE) ? '{point.percentage:.1f}%' : '{point.y}'\n \n /**\n  * ====================\n  * INITIALIZATION STAGE\n  * ====================\n  */\n \n let config = {\n     title: {\n         text: CHART_TITLE,\n         align: 'center',\n         verticalAlign: 'middle',\n         margin: 0,\n         y: 10,\n         useHtml: true,\n         style: {\n             color: CHART_COLORS.TEXT,\n             fontSize: \"2em\",\n             fontWeight: \"bold\"\n         }\n     },\n     chart: CHART_TYPE_SELECTED.chart,\n     legend: {\n         enabled: CHART_SHOW_LEGEND,\n         layout: 'horizontal',\n         align: 'center',\n         verticalAlign: 'bottom',\n         itemStyle: {\n             color: CHART_COLORS.TEXT,\n             fontWeight: \"normal\"\n         }\n     },\n     pane: {\n         size: '100%'\n     },\n     tooltip: {\n         pointFormat: '<b>' + CHART_POINT_FORMAT + '</b>'\n     },\n     plotOptions: {\n         pie: {\n            borderWidth: 10,\n            borderColor: 'var(--body-bg)',\n         },\n         series: {\n             showInLegend: CHART_SHOW_LEGEND,\n             dataLabels: {\n                 enabled: CHART_SHOW_LABELS,\n                 format: '<b>{point.name}</b>: ' + CHART_POINT_FORMAT\n             },\n             cursor: 'pointer',\n             stacking: (CHART_IS_STACKED && CHART_SHOW_PERCENTAGE) ? 'percent' : CHART_IS_STACKED\n         }\n     },\n     colors: CHART_COLORS.SERIES,\n     series: [],\n     xAxis: {\n         type: 'category'\n     },\n     yAxis: {\n         allowDecimals: false,\n         title: ''\n     }\n }\n \n config.chart.backgroundColor = CHART_COLORS.BACKGROUND\n config.chart.spacingBottom = 0\n config.chart.spacingTop = 0\n \n if (CHART_TITLE && CHART_SHOW_LEGEND && CHART_TYPE_SELECTED.hasFloatingTitle) {\n     config.title.verticalAlign = 'top'\n }\n \n if (CHART_TYPE_SELECTED.plotOptions) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type] = CHART_TYPE_SELECTED.plotOptions;\n }\n \n if (CHART_IS_STACKED) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type].colorByPoint = false;\n     config.tooltip.pointFormat = '{series.name}: ' + CHART_POINT_FORMAT + '<br/>Total: {point.stackTotal}'\n     config.plotOptions.series.dataLabels.format = '{series.name}: ' + CHART_POINT_FORMAT\n }\n \n if (CHART_TOOLTIP_OVERRIDE !== null) {\n     config.tooltip.pointFormat = CHART_TOOLTIP_OVERRIDE;\n }\n \n \n /**\n  * ================\n  * PROCESSING STAGE\n  * ================ \n  */\n if (pages.length === 0) {\n     return config\n }\n \n let datasetSize = pages.length;\n let series = [];\n let series_labels = {};\n let categories = {};\n let data = {};\n let pageCounter = 0;\n pages.forEach(function (page) {\n     let value = getValueAndLabelOfAttribute(page, BASE_ATTRIBUTE)\n     let weight = 1;\n     if (value === null) {\n         return\n     }\n \n     let series = getValueAndLabelOfAttribute(page, STACK_ATTRIBUTE);\n \n     if (!CHART_IS_STACKED || series === null) {\n         series = {\n             value: '',\n             label: CHART_TITLE\n         }\n     }\n \n     if (WEIGHT_ATTRIBUTE) {\n         weight = page.get(WEIGHT_ATTRIBUTE) || 1\n     }\n \n     if (value.length) {\n         value.forEach(function (item) {\n             addSeriesData(item, weight, series, data, categories, series_labels)\n         })\n     } else {\n         addSeriesData(value, weight, series, data, categories, series_labels)\n     }\n     pageCounter++;\n });\n\n // This will display the number of pages in the center\n config.title.text += pageCounter;\n \n /**\n  * TODO Sort stacked series, too\n  */\n \n Object.keys(series_labels).sort().forEach(function (series_label) {\n     series_labels[series_label] = series.length\n \n     series.push({\n         name: series_label,\n         type: CHART_TYPE_SELECTED.chart.type,\n         data: [],\n         innerSize: '50%'\n     })\n \n })\n \n Object.keys(data).forEach(function (key) {\n     let currentDataItem = {\n         name: data[key].name,\n         y: data[key].count\n     }\n     let seriesId = series_labels[data[key].series]\n \n     if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series_internal)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series_internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].internal)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].name)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].name]\n     }\n \n     series[seriesId].data.push(currentDataItem)\n })\n \n /**\n  * Add empty entries to series and sort them\n  */\n  let allDataKeys = [];\n  Object.keys(data).forEach(function (key) {\n      let label = data[key].name;\n      if (allDataKeys.indexOf(label) !== -1) {\n          return;\n      }\n  \n      series.forEach(function (serie) {\n          if (!serie.data.some(function (data) {\n                  return data.name === label\n              })) {\n              serie.data.push({\n                  name: label,\n                  y: 0\n              })\n          }\n      })\n      allDataKeys.push(label)\n  })\n \n /**\n  * sort series.data by name\n  */\n series.forEach(function (serie) {\n     serie.data.sort(function (a, b) {\n         if (!a.hasOwnProperty('name') || a.name == b.name) {\n             return 0\n         }\n         /**\n          * sort depending on CHART_SORT_ASCENDING\n          */\n         return ((CHART_SORT_ASCENDING && a.name > b.name) || (!CHART_SORT_ASCENDING && a.name < b.name)) ? 1 : -1\n     })\n })\n \n /**\n  * ============\n  * OUTPUT STAGE\n  * ============ \n  */\n \n config.series = series;\n return config;\n \n /**\n  * ==================\n  * BUSINESS FUNCTIONS\n  * ==================\n  */\n \n /**\n  * ================\n  * HELPER FUNCTIONS\n  * ================\n  */\n \n /**\n  * \n  * @param {object} value \n  * @param {Number} weight \n  * @param {object} series \n  * @param {object[]} data \n  * @param {object[]} categories \n  * @param {String[]} series_labels \n  */\n function addSeriesData(value, weight, series, data, categories, series_labels) {\n     let key = value.value + series.value;\n \n     if (data[key] === undefined) {\n         data[key] = {\n             count: 0,\n             name: value.label,\n             internal: value.value,\n             series: series.label,\n             series_internal: series.value\n         }\n     }\n \n     data[key].count += weight || 1;\n \n     if (!categories.hasOwnProperty(data[key].name)) {\n         categories[data[key].name] = 0\n     }\n \n     if (!series_labels.hasOwnProperty(data[key].series)) {\n         series_labels[data[key].series] = 0\n     }\n }\n \n \n /**\n  * \n  * @param {Page} page \n  * @param {object} attribute \n  * @returns \n  */\n function getValueAndLabelOfAttribute(page, attribute) {\n     let result = null;\n     if (!page) {\n         return result;\n     }\n     if (!attribute) {\n         return {\n             value: page.getRealUid(),\n             label: page.getName()\n         };\n     }\n \n     let value = page.get(attribute, false);\n     if (value === null) {\n         return result;\n     }\n     let value_label = page.get(attribute, true) || value;\n \n     let className = typeof value === 'object' ? String(value.getClass()) : 'String'\n \n     switch (className) {\n         case 'String':\n         case 'class java.lang.String':\n             result = {\n                 value: value,\n                 label: value_label\n             }\n             break;\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedGroup':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPerson':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPage':\n             result = {\n                 value: value.getRealUid(),\n                 label: value.getName()\n             }\n             break;\n         case 'class java.util.ArrayList':\n         case 'class com.google.common.collect.SingletonImmutableList':\n         case 'class com.google.common.collect.RegularImmutableList':\n             /**\n              * TODO Multi-Value\n              */\n             result = [];\n             cplace.each(value, function (item) {\n                 if (typeof item !== 'object' || String(item.getClass()) === 'class java.lang.String') {\n                     /**\n                      * FIXME enum label / enum internal name\n                      */\n                     result.push({\n                         value: item,\n                         label: item\n                     })\n                 } else {\n                     result.push({\n                         value: item.getRealUid(),\n                         label: item.getName()\n                     })\n                 }\n             })\n             break;\n         default:\n             /**\n              * TODO Reference\n              */\n             log('Class of ' + value + ' is \"' + value.class + '\"')\n             log(typeof value.class)\n             log(typeof value)\n     }\n \n     return result\n }\n \n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n function log(text) {\n     if (!DEBUG) {\n         return\n     }\n     let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n \n     cplace.log(logOutput);\n }",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var lang = cplace.utils().getCurrentUser().getUserLanguage();\n\nvar messages = {\n  message: {\n    en: '<p style=\"font-size: 14px; margin-left: 5px;color:#343C4C\">Enter your progress and submit your Key Result Updates. </p>',\n    de: 'Tragen sie Ihren Fortschritt ein und reichen Sie Ihr Key Result Updates ein. '\n  }\n}\n\nreturn messages.message[lang]",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"../../typeDefinitions/cplaceJS_type.js\" />\n\n //--------------------------------------------------------------------------------------//\n //                                       CONFIGURATION                                  //\n //--------------------------------------------------------------------------------------//\n const DEBUG = true;\n\n //--------------------------------------------------------------------------------------//\n //                                       HELPER FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\n\n /**\n  * Log to cplace\n  * @param {any} text\n  */\n  function log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}\n\n //--------------------------------------------------------------------------------------//\n //                                       BUSINESS FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\nfunction updatePage(progress) {\n\n  cplace.actions().updatePage(progress, {\n    customAttributes: {\n        'cf.cplace.solution.okr.lastUpdate': new DateTime()\n    }\n  });\n}\n\nreturn {\n    // \"checkAccess\" function will check if the button should be enabled given the current context\n    checkAccess: function() {\n        return true; // Allowed for all users\n    },\n    // \"call\" function contains the actual business logic and can optionally return an object\n    // containing a success message\n    call: function() {\n        log('Starting Low-Code button script \"okr-submitResults\" execution');\n        let allResults = embeddingPage.getIncomingPages('cf.cplace.solution.okr.progress', 'cf.cplace.solution.okr.objective');\n\n        allResults.forEach(function(result) {\n          updatePage(result);\n       });\n       cplace.actions().refresh();\n\n        return {\n           message: {\n             de: 'Erfolgreich beendet',\n             en: 'Finished successfully'\n           }\n        }\n    }\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var objective = embeddingPage;\nvar set = objective.get('cf.cplace.solution.okr.set');\nvar orgUnit = set.get('cf.cplace.solution.okr.organizationalUnit');\n\nreturn \"<div class='custom-stm-set-banner \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\"+set.getName()+\"</div>\"",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"./typeDefinitions/cplaceJS_type.js\" />\n/**\n * Template for Highchart\n * \n * Instructions:\n * - configure a highchart widget with a search or connected table\n * - look in this script for the following line: !!!! CHANGE FROM HERE !!!! and change your options there\n * - the main options are: BASE_ATTRIBUTE and CHART_TYPE_SELECTED\n * \n * TODO:\n * - Color Attribute\n * - builtin Attributes\n * - more charts\n * - date format for series / data points\n * - multi language\n * - Alias label for internal names\n * - sort of series\n *   \n * \n * \n * @author Bastian Rang <bastian.rang@collaboration-factory.de>\n * @version 2021-08-05\n */\n\n/**\n * ======================\n * LOG AND DEBUG SETTINGS\n * ======================\n */\n const DEBUG = true;\n\n /**\n  * Hint: set a declarative name for all of your logs\n  */\n cplace.setLogName(\"highchart-template\");\n \n /**\n  * ===================\n  * CONFIGURATION STAGE\n  * ===================\n  */\n \n /**\n  * DO NOT CHANGE THESE CONFIGURATIONS WITHOUT STRONG REASON !!!!!\n  */\n const CHART_DEFINITION = {\n     PIE: {\n         chart: {\n             type: 'pie'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     SEMICIRCLE: {\n         chart: {\n             type: 'pie'\n         },\n         plotOptions: {\n             startAngle: -90,\n             endAngle: 90,\n             center: ['50%', '75%'],\n             size: '110%',\n             innerSize: '50%'\n         },\n         isPercentageAvailable: true,\n         isStackable: false,\n         hasFloatingTitle: false\n     },\n     BAR: {\n         chart: {\n             type: 'bar'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n     COLUMN: {\n         chart: {\n             type: 'column'\n         },\n         plotOptions: {\n             colorByPoint: true\n         },\n         isPercentageAvailable: true,\n         isStackable: true,\n         hasFloatingTitle: true\n     },\n }\n \n \n \n /**\n  * ==================================================================================\n  * !!!! CHANGE FROM HERE !!!!\n  */\n \n /**\n  * Optional: Show a title inside of the chart area\n  */\n const CHART_TITLE = ''\n \n /**\n  * Set to null or leave blank to use the Pagename\n  * \n  * TODO builtinFeatureValue starts with underscore: '_creator'\n  */\n const BASE_ATTRIBUTE = 'cf.cplace.solution.okr.progressIndicator';\n \n /**\n  * Optional: Stacking is only possible for bar and column charts\n  * \n  */\n const STACK_ATTRIBUTE = null;\n \n /**\n  * Optional: Define an attribute of the page that acts as weight. If null, each entry has a weight of 1.\n  * The weight is used as sum of each datapoint.\n  */\n const WEIGHT_ATTRIBUTE = null;\n \n /**\n  * Define the base type of the chart: \n  * - CHART_DEFINITION.PIE\n  * - CHART_DEFINITION.SEMICIRCLE\n  * - CHART_DEFINITION.BAR\n  * - CHART_DEFINITION.COLUMN\n  */\n const CHART_TYPE_SELECTED = CHART_DEFINITION.PIE;\n \n /**\n  * Define colors for the chart\n  */\n const CHART_COLORS = {\n     BACKGROUND: '#F2F4FA',\n     TEXT: 'var(--text-color)',\n     SERIES: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a'],\n     CATEGORY: {\n         '#15 green': '#AEDB3C',\n         '#25 yellow': '#FFBA00',\n         '#35 red': '#DB0F35',\n         '#45 outdated': '#bcbcbc'\n     }\n }\n \n /**\n  * @type {Boolean} sort axes ascending (true) or descending (false)\n  */\n const CHART_SORT_ASCENDING = true;\n \n /**\n  * @type {Boolean} show legend under chart\n  */\n const CHART_SHOW_LEGEND = false;\n \n /**\n  * @type {Boolean} show labels on all datapoints\n  */\n const CHART_SHOW_LABELS = false;\n \n /**\n  * @type {Boolean} show values as percentage\n  */\n const CHART_SHOW_PERCENTAGE = false;\n \n /**\n  * @type {null|String} override tooltip text\n  * - use {point.y} as placeholder for absolute values\n  * - use {point.percentage:.1f}% as placeholder for percantage\n  * - use {point.stackTotal} for sum of stack\n  * - use {point.name} for name of data point\n  * - use {series.name} for name of data series\n  */\n const CHART_TOOLTIP_OVERRIDE = null;\n \n \n /**\n  * DO NOT CHANGE AFTER THIS LINE\n  * ==================================================================================\n  */\n \n const CHART_IS_STACKED = !!STACK_ATTRIBUTE && CHART_TYPE_SELECTED.isStackable;\n \n const CHART_POINT_FORMAT = (CHART_TYPE_SELECTED.isPercentageAvailable && CHART_SHOW_PERCENTAGE) ? '{point.percentage:.1f}%' : '{point.y}'\n \n /**\n  * ====================\n  * INITIALIZATION STAGE\n  * ====================\n  */\n \n let config = {\n     title: {\n         text: CHART_TITLE,\n         align: 'center',\n         verticalAlign: 'middle',\n         margin: 0,\n         y: 10,\n         useHtml: true,\n         style: {\n             color: CHART_COLORS.TEXT,\n             fontSize: \"2em\",\n             fontWeight: \"bold\"\n         }\n     },\n     chart: CHART_TYPE_SELECTED.chart,\n     legend: {\n         enabled: CHART_SHOW_LEGEND,\n         layout: 'horizontal',\n         align: 'center',\n         verticalAlign: 'bottom',\n         itemStyle: {\n             color: CHART_COLORS.TEXT,\n             fontWeight: \"normal\"\n         }\n     },\n     pane: {\n         size: '100%'\n     },\n     tooltip: {\n         pointFormat: '<b>' + CHART_POINT_FORMAT + '</b>'\n     },\n     plotOptions: {\n         pie: {\n            borderWidth: 10,\n            borderColor: 'var(--body-bg)',\n         },\n         series: {\n             showInLegend: CHART_SHOW_LEGEND,\n             dataLabels: {\n                 enabled: CHART_SHOW_LABELS,\n                 format: '<b>{point.name}</b>: ' + CHART_POINT_FORMAT\n             },\n             cursor: 'pointer',\n             stacking: (CHART_IS_STACKED && CHART_SHOW_PERCENTAGE) ? 'percent' : CHART_IS_STACKED\n         }\n     },\n     colors: CHART_COLORS.SERIES,\n     series: [],\n     xAxis: {\n         type: 'category'\n     },\n     yAxis: {\n         allowDecimals: false,\n         title: ''\n     }\n }\n \n config.chart.backgroundColor = CHART_COLORS.BACKGROUND\n config.chart.spacingBottom = 0\n config.chart.spacingTop = 0\n \n if (CHART_TITLE && CHART_SHOW_LEGEND && CHART_TYPE_SELECTED.hasFloatingTitle) {\n     config.title.verticalAlign = 'top'\n }\n \n if (CHART_TYPE_SELECTED.plotOptions) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type] = CHART_TYPE_SELECTED.plotOptions;\n }\n \n if (CHART_IS_STACKED) {\n     config.plotOptions[CHART_TYPE_SELECTED.chart.type].colorByPoint = false;\n     config.tooltip.pointFormat = '{series.name}: ' + CHART_POINT_FORMAT + '<br/>Total: {point.stackTotal}'\n     config.plotOptions.series.dataLabels.format = '{series.name}: ' + CHART_POINT_FORMAT\n }\n \n if (CHART_TOOLTIP_OVERRIDE !== null) {\n     config.tooltip.pointFormat = CHART_TOOLTIP_OVERRIDE;\n }\n \n \n /**\n  * ================\n  * PROCESSING STAGE\n  * ================ \n  */\n if (pages.length === 0) {\n     return config\n }\n \n let datasetSize = pages.length;\n let series = [];\n let series_labels = {};\n let categories = {};\n let data = {};\n let pageCounter = 0;\n pages.forEach(function (page) {\n     let value = getValueAndLabelOfAttribute(page, BASE_ATTRIBUTE)\n     let weight = 1;\n     if (value === null) {\n         return\n     }\n \n     let series = getValueAndLabelOfAttribute(page, STACK_ATTRIBUTE);\n \n     if (!CHART_IS_STACKED || series === null) {\n         series = {\n             value: '',\n             label: CHART_TITLE\n         }\n     }\n \n     if (WEIGHT_ATTRIBUTE) {\n         weight = page.get(WEIGHT_ATTRIBUTE) || 1\n     }\n \n     if (value.length) {\n         value.forEach(function (item) {\n             addSeriesData(item, weight, series, data, categories, series_labels)\n         })\n     } else {\n         addSeriesData(value, weight, series, data, categories, series_labels)\n     }\n     pageCounter++;\n });\n\n // This will display the number of pages in the center\n config.title.text += pageCounter;\n \n /**\n  * TODO Sort stacked series, too\n  */\n \n Object.keys(series_labels).sort().forEach(function (series_label) {\n     series_labels[series_label] = series.length\n \n     series.push({\n         name: series_label,\n         type: CHART_TYPE_SELECTED.chart.type,\n         data: [],\n         innerSize: '50%'\n     })\n \n })\n \n Object.keys(data).forEach(function (key) {\n     let currentDataItem = {\n         name: data[key].name,\n         y: data[key].count\n     }\n     let seriesId = series_labels[data[key].series]\n \n     if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series_internal)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series_internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].internal)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].internal]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].series)) {\n         series[seriesId].color = CHART_COLORS.CATEGORY[data[key].series]\n     } else if (CHART_COLORS.CATEGORY.hasOwnProperty(data[key].name)) {\n         currentDataItem.color = CHART_COLORS.CATEGORY[data[key].name]\n     }\n \n     series[seriesId].data.push(currentDataItem)\n })\n \n /**\n  * Add empty entries to series and sort them\n  */\n  let allDataKeys = [];\n  Object.keys(data).forEach(function (key) {\n      let label = data[key].name;\n      if (allDataKeys.indexOf(label) !== -1) {\n          return;\n      }\n  \n      series.forEach(function (serie) {\n          if (!serie.data.some(function (data) {\n                  return data.name === label\n              })) {\n              serie.data.push({\n                  name: label,\n                  y: 0\n              })\n          }\n      })\n      allDataKeys.push(label)\n  })\n \n /**\n  * sort series.data by name\n  */\n series.forEach(function (serie) {\n     serie.data.sort(function (a, b) {\n         if (!a.hasOwnProperty('name') || a.name == b.name) {\n             return 0\n         }\n         /**\n          * sort depending on CHART_SORT_ASCENDING\n          */\n         return ((CHART_SORT_ASCENDING && a.name > b.name) || (!CHART_SORT_ASCENDING && a.name < b.name)) ? 1 : -1\n     })\n })\n \n /**\n  * ============\n  * OUTPUT STAGE\n  * ============ \n  */\n \n config.series = series;\n return config;\n \n /**\n  * ==================\n  * BUSINESS FUNCTIONS\n  * ==================\n  */\n \n /**\n  * ================\n  * HELPER FUNCTIONS\n  * ================\n  */\n \n /**\n  * \n  * @param {object} value \n  * @param {Number} weight \n  * @param {object} series \n  * @param {object[]} data \n  * @param {object[]} categories \n  * @param {String[]} series_labels \n  */\n function addSeriesData(value, weight, series, data, categories, series_labels) {\n     let key = value.value + series.value;\n \n     if (data[key] === undefined) {\n         data[key] = {\n             count: 0,\n             name: value.label,\n             internal: value.value,\n             series: series.label,\n             series_internal: series.value\n         }\n     }\n \n     data[key].count += weight || 1;\n \n     if (!categories.hasOwnProperty(data[key].name)) {\n         categories[data[key].name] = 0\n     }\n \n     if (!series_labels.hasOwnProperty(data[key].series)) {\n         series_labels[data[key].series] = 0\n     }\n }\n \n \n /**\n  * \n  * @param {Page} page \n  * @param {object} attribute \n  * @returns \n  */\n function getValueAndLabelOfAttribute(page, attribute) {\n     let result = null;\n     if (!page) {\n         return result;\n     }\n     if (!attribute) {\n         return {\n             value: page.getRealUid(),\n             label: page.getName()\n         };\n     }\n \n     let value = page.get(attribute, false);\n     if (value === null) {\n         return result;\n     }\n     let value_label = page.get(attribute, true) || value;\n \n     let className = typeof value === 'object' ? String(value.getClass()) : 'String'\n \n     switch (className) {\n         case 'String':\n         case 'class java.lang.String':\n             result = {\n                 value: value,\n                 label: value_label\n             }\n             break;\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedGroup':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPerson':\n         case 'class cf.cplace.platform.scripting.api.wrapper.entity.WrappedPage':\n             result = {\n                 value: value.getRealUid(),\n                 label: value.getName()\n             }\n             break;\n         case 'class java.util.ArrayList':\n         case 'class com.google.common.collect.SingletonImmutableList':\n         case 'class com.google.common.collect.RegularImmutableList':\n             /**\n              * TODO Multi-Value\n              */\n             result = [];\n             cplace.each(value, function (item) {\n                 if (typeof item !== 'object' || String(item.getClass()) === 'class java.lang.String') {\n                     /**\n                      * FIXME enum label / enum internal name\n                      */\n                     result.push({\n                         value: item,\n                         label: item\n                     })\n                 } else {\n                     result.push({\n                         value: item.getRealUid(),\n                         label: item.getName()\n                     })\n                 }\n             })\n             break;\n         default:\n             /**\n              * TODO Reference\n              */\n             log('Class of ' + value + ' is \"' + value.class + '\"')\n             log(typeof value.class)\n             log(typeof value)\n     }\n \n     return result\n }\n \n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n function log(text) {\n     if (!DEBUG) {\n         return\n     }\n     let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n \n     cplace.log(logOutput);\n }",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var lang = cplace.utils().getCurrentUser().getUserLanguage();\n\nvar messages = {\n  message: {\n    en: '<p style=\"font-size: 14px; margin-left: 10px;color:#343C4C\">Enter your progress and submit your Key Result Update. </p>',\n    de: 'Tragen sie Ihren Fortschritt ein und reichen Sie Ihr Key Result Update ein. '\n  }\n}\n\nreturn messages.message[lang]",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"../../typeDefinitions/cplaceJS_type.js\" />\n\n //--------------------------------------------------------------------------------------//\n //                                       CONFIGURATION                                  //\n //--------------------------------------------------------------------------------------//\n const DEBUG = true;\n\n //--------------------------------------------------------------------------------------//\n //                                       HELPER FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n  function log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}\n\n //--------------------------------------------------------------------------------------//\n //                                       BUSINESS FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\n \n\nreturn {\n    // \"checkAccess\" function will check if the button should be enabled given the current context\n    checkAccess: function() {\n        return true; // Allowed for all users\n    },\n    // \"call\" function contains the actual business logic and can optionally return an object\n    // containing a success message\n    call: function() {\n        log('Starting Low-Code button script \"submitResult\" execution');\n        let progress = embeddingPage.get('cf.cplace.solution.okr.progress');\n\n        cplace.actions().updatePage(progress, {\n            customAttributes: {\n                'cf.cplace.solution.okr.lastUpdate': new DateTime()\n            }\n        });\n        progress.registerAttributeForRefresh('cf.cplace.solution.okr.lastUpdate');\n        return {\n           message: {\n             de: 'Erfolgreich beendet',\n             en: 'Finished successfully'\n           }\n        }\n    }\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"../../typeDefinitions/cplaceJS_type.js\" />\n\n //--------------------------------------------------------------------------------------//\n //                                       CONFIGURATION                                  //\n //--------------------------------------------------------------------------------------//\n const DEBUG = true;\n\n //--------------------------------------------------------------------------------------//\n //                                       HELPER FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\n \n /**\n  * Log to cplace\n  * @param {any} text \n  */\n  function log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}\n\n //--------------------------------------------------------------------------------------//\n //                                       BUSINESS FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\n \n\nreturn {\n    // \"checkAccess\" function will check if the button should be enabled given the current context\n    checkAccess: function() {\n        return true; // Allowed for all users\n    },\n    // \"call\" function contains the actual business logic and can optionally return an object\n    // containing a success message\n    call: function() {\n        log('Starting Low-Code button script execution');\n\n\n        cplace.actions().updatePage(embeddingPage, {\n            customAttributes: {\n                'cf.cplace.solution.okr.lastUpdate': new DateTime()\n            }\n        });\n        \n        return {\n           message: {\n             de: 'Erfolgreich beendet',\n             en: 'Finished successfully'\n           }\n        }\n    }\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var keyResult = embeddingPage;\nvar objective = keyResult.get('cf.cplace.solution.okr.objective');\nvar set = objective.get('cf.cplace.solution.okr.set');\nvar orgUnit = set.get('cf.cplace.solution.okr.organizationalUnit');\n\nreturn \"<div class='custom-stm-set-banner \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\"+objective.getName()+\"</div>\"",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/*\n*Highchart\n*Displays the version history of the confidencelevel of keyResult type\n*/\n\nfunction generateData(embeddingPage) {\n    let data = [];\n\n    let confidenceValue = embeddingPage.getVersionHistoryOfAttribute('cf.cplace.solution.okr.confidenceLevel');\n    if (confidenceValue.length > 1) {\n        data = [{ y: 0, date: null }];\n        cplace.each(confidenceValue, function (cv) {\n            // cplace.log(cv.getNewValue());\n            let cvValue = cv.getNewValue() ? cv.getNewValue().toString() : '';\n            let cvDate = cv.getWhen();\n            let lastThree = cvValue.substr(cvValue.length - 3);\n            if (cvValue) {\n                data.push({\n                    y: parseFloat(lastThree),\n                    date: cvDate.toString()\n                });\n            } else {\n                data.push({\n                    y: 0.5,\n                    date: cvDate.toString()\n                })\n            }\n        })\n        data.push({ y: 1, date: null })\n    }\n    //cplace.log(data);\n    return data;\n}\n\n\nfunction main() {\n    const dataObj = generateData(embeddingPage);\n    return {\n        chart: {\n            height: 200,\n            backgroundColor: '#F2F4FA'\n        },\n        title: {\n            text: '<b>Confidence Value: ' + embeddingPage.get('cf.cplace.solution.okr.confidenceLevel') + '</b>',\n            align: 'center',\n            useHtml: true\n        },\n        xAxis: {\n            reversed: true,\n            min: 1,\n            max: dataObj.length - 2,\n            labels: {\n                enabled: false\n            },\n            lineColor: '#fcfcfc',\n            tickLength: 1,\n            showLastLabel: false,\n        },\n        yAxis: {\n            title: '',\n            min: 0,\n            max: 1,\n            labels: {\n                enabled: false\n            },\n            gridLineColor: 'rgba(255,255,255,0)',\n            lineColor: '#ffffff',\n        },\n        plotOptions: {\n            series: {\n                lineWidth: 7,\n                tickWidth: 10,\n                marker: {\n                    fillColor: 'rgba(0,0,0,.1)',\n                    radius: 6\n                }\n            }\n        },\n        legend: {\n            enabled: false\n        },\n        credits: {\n            enabled: false\n        },\n        series: [{\n            data: dataObj,\n            name: 'Confidence Levels',\n            color: {\n                linearGradient: {\n                    x1: 0,\n                    x2: 0,\n                    y1: 0,\n                    y2: 1\n                },\n                stops: [\n                    [0, 'rgba(174,219,60,1)'],\n                    [0.5, 'rgba(255,186,0,1)'],\n                    [1, 'rgba(219,15,53,1)']\n                ]\n            },\n        }],\n        tooltip: {\n            shared: true,\n            useHTML: true,\n            headerFormat: 'Confidence Level: ' + '<b>{point.y}</b><br>',\n            pointFormat: '--<br>{point.date}',\n        }\n    }\n}\n\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/*\n*Highcahrt\n*Displays the organisation chart\n*/\n\ncplace.setLogName('hc_organisation_chart');\n\n\n/// <reference path=\"../../typeDefinitions/cplaceJS_type.js\" />\n/**\n * Template for Highchart\n *\n * Instructions:\n * - configure a highchart widget with a search or connected table\n * - look in this script for the following line: !!!! CHANGE FROM HERE !!!! and change your options there\n * - the main options are: BASE_ATTRIBUTE and CHART_TYPE_SELECTED\n *\n * TODO:\n * - Color Attribute\n * - builtin Attributes\n * - more charts\n * - date format for series / data points\n * - multi language\n * - Alias label for internal names\n * - sort of series\n *\n *\n *\n * @author Bastian Rang <bastian.rang@collaboration-factory.de>\n * @version 2021-08-05\n */\n\n/**\n * ======================\n * LOG AND DEBUG SETTINGS\n * ======================\n */\nconst DEBUG = false;\n\n/**\n * Hint: set a declarative name for all of your logs\n */\ncplace.setLogName(\"highchart-template\");\n\n/**\n * ===================\n * CONFIGURATION STAGE\n * ===================\n */\n\n/**\n * DO NOT CHANGE THESE CONFIGURATIONS WITHOUT STRONG REASON !!!!!\n */\nconst CHART_DEFINITION = {\n    PIE: {\n        chart: {\n            type: \"pie\",\n        },\n        isPercentageAvailable: true,\n        isStackable: false,\n        hasFloatingTitle: false,\n    },\n    SEMICIRCLE: {\n        chart: {\n            type: \"pie\",\n        },\n        plotOptions: {\n            startAngle: -90,\n            endAngle: 90,\n            center: [\"50%\", \"75%\"],\n            size: \"110%\",\n            innerSize: \"50%\",\n        },\n        isPercentageAvailable: true,\n        isStackable: false,\n        hasFloatingTitle: false,\n    },\n    BAR: {\n        chart: {\n            type: \"bar\",\n        },\n        plotOptions: {\n            colorByPoint: true,\n        },\n        isPercentageAvailable: true,\n        isStackable: true,\n        hasFloatingTitle: true,\n    },\n    COLUMN: {\n        chart: {\n            type: \"column\",\n        },\n        plotOptions: {\n            colorByPoint: true,\n        },\n        isPercentageAvailable: true,\n        isStackable: true,\n        hasFloatingTitle: true,\n    },\n};\n\n/**\n * ==================================================================================\n * !!!! CHANGE FROM HERE !!!!\n */\n\n/**\n * Optional: Show a title inside of the chart area\n */\nconst CHART_TITLE = \"\";\n\n/**\n * Define the base type of the chart:\n * - CHART_DEFINITION.PIE\n * - CHART_DEFINITION.SEMICIRCLE\n * - CHART_DEFINITION.BAR\n * - CHART_DEFINITION.COLUMN\n */\nconst CHART_TYPE_SELECTED = CHART_DEFINITION.PIE;\n\n/**\n * Define the color of a node by it's ID.\n */\nconst PAGE_COLOR_MAP = {\n    \"Company\": \"var(--color-company)\",\n    \"Engineering\": \"var(--color-engineering)\",\n    \"Product\": \"var(--color-product)\",\n    \"Marketing\": \"var(--color-marketing)\",\n    \"Sales\": \"var(--color-sales)\",\n};\n/**\n * Define colors for the chart\n */\nconst CHART_COLORS = {\n    BACKGROUND: \"var(--body-bg)\",\n    TEXT: \"var(--text-color)\",\n    SERIES: [\"#e31a1c\", \"#fdbf6f\", \"#ff7f00\", \"#6a3d9a\"],\n    CATEGORY: {\n        \"#15 green\": \"#AEDB3C\",\n        \"#25 yellow\": \"#FFBA00\",\n        \"#35 red\": \"#DB0F35\",\n        \"#45 outdated\": \"#bcbcbc\",\n    },\n};\n\n/**\n * @type {Boolean} show legend under chart\n */\nconst CHART_SHOW_LEGEND = false;\n\n/**\n * @type {Boolean} show labels on all datapoints\n */\nconst CHART_SHOW_LABELS = true;\n\n/**\n * @type {null|String} override tooltip text\n * - use {point.y} as placeholder for absolute values\n * - use {point.percentage:.1f}% as placeholder for percantage\n * - use {point.stackTotal} for sum of stack\n * - use {point.name} for name of data point\n * - use {series.name} for name of data series\n */\nconst CHART_TOOLTIP_OVERRIDE = null;\n\n/**\n * DO NOT CHANGE AFTER THIS LINE\n * ==================================================================================\n */\n\nconst CHART_POINT_FORMAT = \"{point.y}\";\n\n/**\n * ====================\n * INITIALIZATION STAGE\n * ====================\n */\nconst levelConfig = [\n    {\n        level: 0,\n        color: \"silver\",\n    },\n    {\n        level: 1,\n        color: \"#980104\",\n    },\n    {\n        level: 2,\n        color: \"#359154\",\n    },\n];\n    let nodes = [];\n    let data = [];\n    let series = [];\n/**\n * ================\n * PROCESSING STAGE\n * ================\n */\n\n\nfunction generateData(pages) {\n\n\n    pages.forEach(function (page) {\n        nodes.push(mapToDataNode(page));\n        loadChildren(page);\n    });\n  \n  \n  \n    series.push({\n        type: \"organization\",\n        name: \"\",\n        keys: [\"from\", \"to\"],\n        // Hierarchy definition\n        data: data,\n        // Styling definiton\n        levels: levelConfig,\n        // Content definiton (getting matched to \"data\" by \"id\")\n        nodes: nodes,\n    });\n\n    return series\n}\n\nfunction main() {\n    let series = generateData(pages);\n\n    if (CHART_TOOLTIP_OVERRIDE !== null) {\n        config.tooltip.pointFormat = CHART_TOOLTIP_OVERRIDE;\n    }\n\n    let config = {\n        chart: {\n            inverted: true,\n            backgroundColor: \"#f3f4fa\",\n        },\n        title: {\n            text: CHART_TITLE,\n            useHtml: true,\n            style: {\n                color: CHART_COLORS.TEXT,\n                fontSize: \"2em\",\n                fontWeight: \"bold\",\n            },\n        },\n        legend: {\n            enabled: CHART_SHOW_LEGEND,\n            layout: \"horizontal\",\n            align: \"center\",\n            verticalAlign: \"bottom\",\n            itemStyle: {\n                color: CHART_COLORS.TEXT,\n                fontWeight: \"normal\",\n            },\n        },\n        pane: {\n            size: \"100%\",\n        },\n        tooltip: false,\n        plotOptions: {\n            pie: {\n                borderWidth: 10,\n                borderColor: \"var(--body-bg)\",\n            },\n            series: {\n                showInLegend: CHART_SHOW_LEGEND,\n                dataLabels: {\n                    enabled: CHART_SHOW_LABELS,\n                    format: \"<b>{point.name}</b><br/><span><b>Set Lead: </b><span>{point.leads}</span></span>\",\n                },\n                cursor: \"default\",\n            },\n        },\n        colors: CHART_COLORS.SERIES,\n        series: series,\n    };\n\n    return config\n\n}\n\nreturn main();\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n\nfunction loadChildren(page) {\n    let children = page.getIncomingPages(\n        \"cf.cplace.solution.okr.organizationalUnit\",\n        \"cf.cplace.solution.okr.organizationalUnit\"\n    );\n    \n  \n    children.forEach(function (child) {\n        nodes.push(mapToDataNode(child));\n        data.push([page.getId(), child.getId()]);\n\n        // go on\n        loadChildren(child);\n    });\n}\n\nfunction mapToDataNode(page) {\n    let map = {\n        id: page.getId(),\n        name: page.getName(),\n        height: 75,\n    };\n\n    let color = PAGE_COLOR_MAP[page.getName()];\n    if (color) {\n        map.color = color;\n    }\n\n    let set = getCurrentSet(page);\n    let leads = set.get(\"cf.cplace.solution.okr.setLead\");\n    let leadNames = \"\";\n    leads.forEach(function (lead) {\n        if (leadNames) {\n            leadNames += \"<br/>\";\n        }\n        leadNames += lead.getName();\n    });\n\n    map.leads = leadNames;\n    return map;\n  \n}\n\n\n\n/**\n * ================\n * HELPER FUNCTIONS\n * ================\n */\n\nfunction getCurrentCycle(page) {\n    let search = new Search();\n    search\n        .add(Filters.type(\"cf.cplace.solution.okr.cycle\"))\n        .add(Filters.space(page.getSpace()))\n        .add(Filters.customAttribute(\"cf.cplace.solution.okr.status\").eq(\"#25 Current\"));\n\n    return search.findAllPages();\n}\n\nfunction getCurrentSet(unit) {\n    let currentCycle = getCurrentCycle(unit);\n    let result = null;\n\n    currentCycle.forEach(function (cycle) {\n        let search = new Search();\n        search\n            .add(Filters.type(\"cf.cplace.solution.okr.set\"))\n            .add(Filters.space(unit.getSpace()))\n            .add(Filters.customAttribute(\"cf.cplace.solution.okr.cycle\").references(cycle))\n            .add(Filters.customAttribute(\"cf.cplace.solution.okr.organizationalUnit\").references(unit));\n\n        let sets = search.findAllPages();\n\n        sets.forEach(function (set) {\n            result = set;\n        });\n\n        return;\n    });\n\n    return result;\n}\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    let logOutput = typeof text !== \"string\" ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var currentUser = cplace.utils().getCurrentUser();\n\nvar orgUnits = currentUser.getIncomingPages('cf.cplace.solution.okr.organizationalUnit', 'cf.cplace.solution.okr.assignedEmployee');\n\nvar lang = currentUser.getUserLanguage();\nvar result = \"\";\ncplace.each(orgUnits, function(orgUnit) {\n    var messages = {\n        message: {\n            en: 'Welcome ' + currentUser.getName() + '. You are assigned to the Org. Unit <b>' + orgUnit.getName() +'</b>.',\n            de: 'Hallo ' + currentUser.getName() + '. Sie sind der Org. Einheit <b>' + orgUnit.getName() + '</b> zugewiesen.'\n        }\n    }\n\n    result += \"<div class='custom-stm-set-banner \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\" + messages.message[lang] + \"</div>\"\n    cplace.log('result'+result)\n});\n\nreturn result;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/*\n*Highchart\n*Displays the strategic priorities of different dimensions\n*/\n\n\n/***** Start configuration *****/\n\nconst PRIORITY = {\n    TYPE: 'cf.cplace.solution.okr.priority',\n    ATTR: {\n        DATE: 'cf.cplace.solution.okr.date',\n        TITLE: 'cf.cplace.solution.okr.title',\n        DIMENSION: 'cf.cplace.solution.okr.dimension',\n        STRATEGY: 'cf.cplace.solution.okr.strategyDashboard'\n    }\n}\n\nconst chartBackgroundColor = '#F2F4FA';\nconst todayPlotLineColor = '#244761';\nconst roadmapDimensions = ['Marketing', 'Sales', 'Engineering', 'Product', 'Company'];\nconst roadmapDimensionColors = ['#2364AA', '#3DA5D9', '#73BFB8', '#FEC601', '#f72585'];\nconst plotBandColorSuffix = '40';\t// alpha value in hex\nconst plotLineColor = '#ffffff';\nconst milestoneSize = 7;\n\n/***** End configuration *****/\n\nfunction generateData(pages) {\n\n    let dataObj = {\n        categories: [], plotLines: [], plotBands: [], series: createSeries(), firstDate: null,\n        lastDate: null\n    }\n    let yIndex = 0,\n        yIndexStart = 0,\n        lastRoadmapItemGroup = null;\n\n\n    // loop each roadmap dimension and roadmap item\n    roadmapDimensions.forEach(function (roadmapDimension, idx) {\n        // Prepare roadmap items for current dimension\n        let roadmapItemsByDimension = [];\n        cplace.each(pages, function (roadmapItem) {\n            if (roadmapDimension == roadmapItem.get(PRIORITY.ATTR.DIMENSION).getName()) {\n                roadmapItemsByDimension.push(roadmapItem);\n                // eval maximum axis extent\n                let date = roadmapItem.get(PRIORITY.ATTR.DATE);\n                dataObj.firstDate = (dataObj.firstDate == null || date.isBefore(dataObj.firstDate) ? date : dataObj.firstDate);\n                dataObj.lastDate = (dataObj.lastDate == null || date.isAfter(dataObj.lastDate) ? date : dataObj.lastDate);\n            }\n        });\n\n        /*\n        // quarters as categories for x-axis (if *not* using datetime)\n        let quarterDate = firstDate.withDayOfMonth(1).withMonthOfYear((((firstDate.getMonthOfYear() - 1) / 3) * 3) + 1);\n        let lastDateShown = lastDate.plusMonths(5).plusWeeks(2);\n        while (quarterDate.isBefore(lastDateShown)) {\n          categories.push(quarterDate);\n          quarterDate = quarterDate.plusMonths(3);\n        }\n        */\n\n        yIndex++;\n        yIndexStart = yIndex;\n        yIndex++;\n\n        roadmapItemsByDimension.sort(function (a, b) {\n            let dateA = Date.parse(a.get('cf.cplace.solution.okr.date'));\n            let dateB = Date.parse(b.get('cf.cplace.solution.okr.date'));\n\n            const groupA = a.get('cf.cplace.solution.okr.roadmapItemGroup');\n            const groupB = b.get('cf.cplace.solution.okr.roadmapItemGroup');\n            if (groupA != null && groupB == null) {\n                return -1;\n            }\n            if (groupA == null && groupB != null) {\n                return 1;\n            }\n            if (groupA != null && groupB != null && groupA.getId() != groupB.getId()) {\n                dateA = Date.parse(groupA.getBuiltinFeatureValue(\"createdAt\"));\n                dateB = Date.parse(groupB.getBuiltinFeatureValue(\"createdAt\"));\n            }\n\n            return dateA - dateB;\n        });\n\n        lastRoadmapItemGroup = null;\n        roadmapItemsByDimension.forEach(function (roadmapItem, idx2) {\n            let date = roadmapItem.get(PRIORITY.ATTR.DATE);\n\n            if (date) {\n                let name = roadmapItem.getName();\n                let url = roadmapItem.getUrl();\n\n                // separate item groups by a line\n                let roadmapItemGroup = roadmapItem.get('cf.cplace.solution.okr.roadmapItemGroup');\n                let group = (roadmapItemGroup != null ? roadmapItemGroup.getName() : null);\n                if ((lastRoadmapItemGroup == null && roadmapItemGroup != null && idx2 > 0)\n                    || (lastRoadmapItemGroup != null && roadmapItemGroup == null)\n                    || lastRoadmapItemGroup != null && roadmapItemGroup != null && lastRoadmapItemGroup.getId() != roadmapItemGroup.getId()) {\n                    dataObj.plotLines.push(createPlotline(yIndex));\n                    yIndex++;\n                }\n\n                /*\n                let q = 0;\n                while (q < categories.length && categories[q].isBefore(date)) {\n                  q++;\n                }\n                */\n\n                let dataItem = createDataItem(group, name, url, new Date(date), yIndex, roadmapDimensionColors[idx]);\n                dataObj.series.data.push(dataItem);\n\n                // remember last item group for pairing/separating them\n                lastRoadmapItemGroup = roadmapItemGroup;\n                yIndex++;\n            }\n        });\n\n        // group whole dimension into a band\n        if (roadmapItemsByDimension.length > 0) {\n            dataObj.plotBands.push(createPlotband(roadmapDimension, yIndexStart, yIndex, roadmapDimensionColors[idx]));\n        }\n\n    });\n    return dataObj;\n}\n\nfunction createSeries() {\n    return {\n        showInLegend: false,\n        type: 'scatter',\n        data: []\n    };\n}\n\nfunction createDataItem(group, name, url, date, y, color) {\n    return {\n        tooltip: (group != null ? group + \" - \" : \"\") + name,\n        name: name,\n        url: url,\n        x: Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0),\n        y: y,\n        color: color\n    }\n}\n\nfunction createPlotline(value) {\n    return {\n        color: plotLineColor,\n        width: 1,\n        zIndex: 1,\n        value: value\n    }\n}\n\nfunction createPlotband(name, from, to, color) {\n    return {\n        from: from,\n        to: to,\n        label: {\n            useHTML: true,\n            text: \"<h4>\" + name + \"</h4>\",\n            rotation: 0,\n            x: 5,\n            y: -10,\n            textAlign: 'left'\n        },\n        color: color + plotBandColorSuffix\n    }\n}\n\nfunction main() {\n    let dataObj = generateData(pages);\n    // add some months/weeks for displaying enough space on the right for longer labels\n    let lastAxisDate = new Date(dataObj.lastDate.plusMonths(5).plusWeeks(2));\n\n    let chart = {\n        chart: {\n            type: 'xrange',\n            backgroundColor: chartBackgroundColor,\n            zoomType: 'xy'\n        },\n        title: {\n            text: ''\n        },\n        xAxis: {\n            type: 'datetime',\n            opposite: true,\n            lineColor: chartBackgroundColor,\n            tickInterval: 3 * 30 * 24 * 3600 * 1000, // 3 Months\n            startOnTick: true,\n            max: Date.UTC(lastAxisDate.getFullYear(), lastAxisDate.getMonth(), lastAxisDate.getDate(), 0, 0, 0, 0),\n            labels: {\n                useHTML: true,\n                format: '<h3 style=\"text-align:center;\">{value: %Y<br>Q%Q}</h3>',\n                distance: 20,\n                x: 50,\n                style: {\n                    color: '#234965'\n                }\n            },\n            tickLength: 5,\n            gridLineWidth: 1,\n            gridLineColor: '#ccd6eb',\n            gridLineDashStyle: 'Dash',\n            plotLines: [{\n                value: Date.now(),\n                dashStyle: 'dot',\n                width: 3,\n                color: todayPlotLineColor,\n                zIndex: 1,\n                label: {\n                    align: 'right',\n                    y: 36\n                }\n            }],\n        },\n        yAxis: {\n            title: {\n                text: ''\n            },\n            labels: {\n                enabled: false\n            },\n            reversed: true,\n            gridLineWidth: 0,\n            plotLines: dataObj.plotLines,\n            plotBands: dataObj.plotBands\n        },\n        tooltip: {\n            headerFormat: '',\n            pointFormat: '<b>{point.tooltip}</b><br/>{point.x: %d.%m.%Y}',\n            style: {\n                pointerEvents: 'auto',\n                color: '#234965'\n            }\n        },\n        plotOptions: {\n            scatter: {\n                findNearestPointBy: 'xy',\n                marker: {\n                    enabled: true,\n                    symbol: 'diamond',\n                    radius: milestoneSize\n                },\n                dataLabels: {\n                    enabled: true,\n                    allowOverlap: true,\n                    color: '#234965',\n                    style: {\n                        textOutline: 0\n                    },\n                    format: \"<a href='{point.url}'>{point.name}</a>\",\n                    align: 'left',\n                    verticalAlign: 'middle',\n                    x: milestoneSize\n                },\n            }\n        },\n        series: [dataObj.series]\n    };\n\n    return chart;\n}\n\nreturn main();",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var currentUser = cplace.utils().getCurrentUser();\ncplace.log(currentUser);\nvar orgUnits = currentUser.getIncomingPages('cf.cplace.solution.okr.organizationalUnit', 'cf.cplace.solution.okr.assignedEmployee');\n\nvar lang = currentUser.getUserLanguage();\nvar result = \"\";\ncplace.each(orgUnits, function(orgUnit) {\n  cplace.log(orgUnit.getName());\n  var messages = {\n    message: {\n      en: 'Strategy',\n      de: 'Strategy'\n    }\n  }\n\n  result += \"<div class='custom-stm-dashboard-banner \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\" + messages.message[lang] + \"</div>\"\n\n});\n\nreturn result;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var currentUser = cplace.utils().getCurrentUser();\ncplace.log(currentUser);\nvar orgUnits = currentUser.getIncomingPages('cf.cplace.solution.okr.organizationalUnit', 'cf.cplace.solution.okr.assignedEmployee');\n\nvar lang = currentUser.getUserLanguage();\nvar result = \"\";\ncplace.each(orgUnits, function(orgUnit) {\n  cplace.log(orgUnit.getName());\n  var messages = {\n    message: {\n      en: 'Meetings',\n      de: 'Meetings'\n    }\n  }\n\n  result += \"<div class='custom-stm-dashboard-banner \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\" + messages.message[lang] + \"</div>\"\n\n});\n\nreturn result;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var currentUser = cplace.utils().getCurrentUser();\ncplace.log(currentUser);\nvar orgUnits = currentUser.getIncomingPages('cf.cplace.solution.okr.organizationalUnit', 'cf.cplace.solution.okr.assignedEmployee');\n\nvar lang = currentUser.getUserLanguage();\nvar result = \"\";\ncplace.each(orgUnits, function(orgUnit) {\n  cplace.log(orgUnit.getName());\n  var messages = {\n    message: {\n      en: 'OKR Manual',\n      de: 'OKR Manual'\n    }\n  }\n\n  result += \"<div class='custom-stm-dashboard-banner' \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\" + messages.message[lang] + \"</div>\"\n\n});\n\nreturn result;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "/// <reference path=\"../../typeDefinitions/cplaceJS_type.js\" />\n\n //--------------------------------------------------------------------------------------//\n //                                       CONFIGURATION                                  //\n //--------------------------------------------------------------------------------------//\n const DEBUG = true;\n\n const preventChange = false;\n\n //--------------------------------------------------------------------------------------//\n //                                       HELPER FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\n\n /**\n  * Log to cplace\n  * @param {any} text\n  */\n  function log(text) {\n    if (!DEBUG) {\n        return\n    }\n    let logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n\n    cplace.log(logOutput);\n}\n\n //--------------------------------------------------------------------------------------//\n //                                       BUSINESS FUNCTIONS                               //\n //--------------------------------------------------------------------------------------//\n\n function updateCurrentCycle(page, settingsPage) {\n   let editorGroups = settingsPage.get('cf.cplace.solution.okr.editors');\n\n   if (preventChange) {\n     return;\n   }\n    cplace.actions().updatePage(page, {\n        writers:  {\n            'additiveInheritance': false,\n            '-': editorGroups // remove these editors\n        },\n        customAttributes: {\n            'cf.cplace.solution.okr.status': '#35 Closed'\n        }\n    });\n }\n\n function updateNextCycle(page) {\n\n  if (preventChange) {\n    return;\n  }\n    setInitialDateOnKRs(page);\n    cplace.actions().updatePage(page, {\n        customAttributes: {\n            'cf.cplace.solution.okr.status': '#25 Current'\n        }\n    });\n }\n\n function setInitialDateOnKRs(cycle) {\n    let results = cycle.getIncomingPages('cf.cplace.solution.okr.progress', 'cf.cplace.solution.okr.cycle');\n\n    let now = new DateTime();\n    results.forEach(function(page) {\n      if (preventChange) {\n        return;\n      }\n        cplace.actions().updatePage(page, {\n            customAttributes: {\n                'cf.cplace.solution.okr.lastUpdate': now\n            }\n        });\n    });\n }\n\n\nreturn {\n    // \"checkAccess\" function will check if the button should be enabled given the current context\n    checkAccess: function() {\n        return true; // Allowed for all users\n    },\n    // \"call\" function contains the actual business logic and can optionally return an object\n    // containing a success message\n    call: function() {\n        log('Starting switch-to-next-cycle-script');\n\n        let settingsPage = embeddingPage.get('cf.cplace.solution.okr.settings');\n        log('Settings:' + settingsPage.getName());\n\n        let currentCycle = settingsPage.get('cf.cplace.solution.okr.currentCycle');\n        let nextCycle = additionalData.get('cf.cplace.solution.okr.nextCycle');\n\n        if (!currentCycle) {\n            return {\n                message: {\n                    de: 'Fehler in den Einstellungen, der aktuelle Zyklus ist nicht bekannt.',\n                    en: 'Error found in settings - the current cycle is not set.'\n                }\n            }\n        }\n\n        log('Current: ' + currentCycle.getName());\n        log('Next: ' + nextCycle.getName());\n\n        updateCurrentCycle(currentCycle, settingsPage);\n        updateNextCycle(nextCycle);\n\n\n        // Everything done, update internal reference\n        log('Update reference to next cycle');\n\n        if (!preventChange) {\n          cplace.actions().updatePage(settingsPage, {\n            customAttributes: {\n              'cf.cplace.solution.okr.currentCycle': nextCycle\n            }\n          });\n        }\n\n        return {\n           message: {\n             de: 'Erfolgreich beendet',\n             en: 'Finished successfully'\n           }\n        }\n    }\n}",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var currentUser = cplace.utils().getCurrentUser();\ncplace.log(currentUser);\nvar orgUnits = currentUser.getIncomingPages('cf.cplace.solution.okr.organizationalUnit', 'cf.cplace.solution.okr.assignedEmployee');\n\nvar lang = currentUser.getUserLanguage();\nvar result = \"\";\ncplace.each(orgUnits, function(orgUnit) {\n  cplace.log(orgUnit.getName());\n  var messages = {\n    message: {\n      en: 'Administration',\n      de: 'Administration'\n    }\n  }\n\n  result += \"<div class='custom-stm-dashboard-banner \" + orgUnit.getName().replace(/\\W+(.)/g) + \"'>\" + messages.message[lang] + \"</div>\"\n\n});\n\nreturn result;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "var layoutConfig = {\n    layouts: selectedLayouts,\n    active: selectedActiveLayout\n};\n\nreturn layoutConfig;",
        "attributes": null,
        "type_name": null
    },
    {
        "type": "custom_attribute",
        "code": "const ATTRIBUTES = {\n    MEETING: {\n        TYPE: 'cf.cplace.solution.okr.meeting',\n        ATTR: {\n            MEETING_TYPE: 'cf.cplace.solution.okr.meetingType'\n        },\n        MEETING_TYPE: {\n            ONE_ON_ONE: '#15 - 1on1',\n            LEADERASHIP: '#25 - leadership',\n            WORKSHOP: '#35 - workshop'\n        }\n    },\n    LAYOUTS: {\n        ONE_ON_ONE: 'cf.cplace.solution.okr.layout.1on1',\n        LEADERASHIP: 'cf.cplace.solution.okr.layout.leadership',\n        WORKSHOP: 'cf.cplace.solution.okr.layout.workshop',\n        FILES: 'cf.cplace.solution.okr.layout.files'\n    }\n}\n\n\n\n\nlet layouts = [];\nlet meetingType = page.get(ATTRIBUTES.MEETING.ATTR.MEETING_TYPE);\n\nswitch (meetingType) {\n    case ATTRIBUTES.MEETING.MEETING_TYPE.ONE_ON_ONE:\n        layouts.push(ATTRIBUTES.LAYOUTS.ONE_ON_ONE);\n        break;\n    case ATTRIBUTES.MEETING.MEETING_TYPE.LEADERASHIP:\n        layouts.push(ATTRIBUTES.LAYOUTS.LEADERASHIP);\n        break;\n        case ATTRIBUTES.MEETING.MEETING_TYPE.WORKSHOP:\n            layouts.push(ATTRIBUTES.LAYOUTS.WORKSHOP);\n        break;\n    default:\n  }\n\n  layouts.push(ATTRIBUTES.LAYOUTS.FILES);\n\n\nlet layoutConfig = {\n    layouts: layouts,\n    active: layouts[0],\n  }\n  \n  return layoutConfig;",
        "attributes": null,
        "type_name": null
    }
]