{
    "type": "custom_attribute",
    "code": "/**\n * Displays all items grouped by Program (ART/Agile Release Train) and iteration.\n * Items can be of type Capability (Feature is a missing feature).\n * Dependencies between items are displayed as a line.\n *\n * Milestones that lie within the period of the iterations are displayed in a separate row.\n *\n * @author Daniel Fader\n * @version 15.03.2023\n */\n\n//--------------------------------------------------------------------------------------//\n//                                       LOG AND DEBUG                                  //\n//--------------------------------------------------------------------------------------//\nconst DEBUG = false;\ncplace.setLogName('highcharts-dependency-map-capability');\n\n//--------------------------------------------------------------------------------------//\n//                                       CONFIGURATION                                  //\n//--------------------------------------------------------------------------------------//\n\nconst TYPE_CAPABILITY = {\n    TYPE: 'cf.cplace.solution.safe.capability',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        TYPE: 'cf.cplace.solution.safe.capabilityType',\n        FEATURES: 'cf.cplace.solution.safe.feature',\n        PROGRAM: 'cf.cplace.solution.safe.program',\n        SOLUTION: 'cf.cplace.solution.safe.solution.reference',\n        PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n        TEMP_ITERATIONS: 'cf.cplace.solution.safe.iteration'\n    },\n    ENUM: {\n        TYPE: {\n            CAPABILITY: 'capability',\n            ENABLER: 'enabler'\n        }\n    }\n};\n\nconst TYPE_FEATURE = {\n    TYPE: 'cf.cplace.solution.safe.feature',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        ITERATIONS: 'cf.cplace.solution.safe.iterations',\n        PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n        CAPABILITY: 'cf.cplace.solution.safe.capability',\n        PROGRAM: 'cf.cplace.solution.safe.program'\n    }\n};\n\nconst TYPE_MILESTONE = {\n    TYPE: 'cf.cplace.solution.safe.safeMilestone',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        DATE: 'cf.cplace.solution.safe.date',\n        TYPE: 'cf.cplace.solution.safe.type',\n        RELEVANT_FOR: 'cf.cplace.solution.safe.relevantFor' // refers to Program\n    },\n    ENUM: {\n        TYPE: {\n            PI_MILESTONE: '#15 - PI Meilenstein',\n            FIXED_DATE: '#25 - Fixiertes Datum',\n            LEARNING_MILESTONE: '#35 - Learning Meilenstein'\n        }\n    }\n};\n\nconst TYPE_DEPENDENCY = {\n    TYPE: 'cf.cplace.solution.safe.dependency',\n    ATTR: {\n        A: 'cf.cplace.solution.safe.successor',\n        B: 'cf.cplace.solution.safe.predecessor',\n        TYPE: 'cf.cplace.solution.safe.type',\n        STATUS: 'cf.cplace.solution.safe.status',\n        DESCRIPTION: 'cf.cplace.solution.safe.description'\n    },\n    ENUM: {\n        TYPE: {\n            RELATED_TO: 'related to',\n            BLOCKED_BY: 'blocked by'\n        },\n        STATUS: {\n            IDENTIFIED: '15 - identified',\n            CONFLICT: '25 - conflict',\n            RESOLVED: '35 - resolved'\n        }\n    }\n};\n\nconst TYPE_PROGRAM_INCREMENT = {\n    TYPE: 'cf.cplace.solution.safe.programIncrement',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        START: 'cf.cplace.solution.safe.startDate',\n        END: 'cf.cplace.solution.safe.endDate',\n        PREDECESSOR: 'cf.cplace.solution.safe.predecessor' // Program Increment\n    }\n};\n\nconst TYPE_ITERATION = {\n    TYPE: 'cf.cplace.solution.safe.iteration',\n    ATTR: {\n        TITLE: 'cf.cplace.solution.safe.title',\n        PROGRAM_INCREMENT: 'cf.cplace.solution.safe.programIncrement',\n        START: 'cf.cplace.solution.safe.startDate',\n        END: 'cf.cplace.solution.safe.endDate',\n        PREDECESSOR: 'cf.cplace.solution.safe.predecessor' // Iteration\n    }\n};\n\nconst COLORS = {\n    INACTIVE: '#88bbee',\n    ACTIVE: '#4488aa',\n    DEPEND: '#888888',\n    DEPEND_HIGHLIGHT: '#A21622',\n    DEPEND_RESOLVED: '#19ad48',\n    SAFE_MILESTONE: '#3D8F8C',\n    RELEASE: '#366C81',\n    MILESTONE_PLOTBAND: '#E2F3F2',\n    RELEASE_PLOTBAND: '#E2EEF3',\n    CAPABILITY: '#0aa5ff',\n    ENABLER: '#ffc80c',\n    TODAY_PLOTLINE: 'lightgrey'\n};\n\nconst CATEGORY = {\n    SAFE_MILESTONE: 'SAFe Milestones'\n};\n\nconst ROW_SIZE = {\n    PERIOD: 2,\n    ITEM: 1\n};\n\nconst HEIGHTS = {\n    HEADER: 40,\n    ITEM: 25\n};\n\nconst MAX_DATA_LABEL_LENGTH = 25;\nconst DATA_LABEL_PADDING = 0.05;\n\nconst SEPARATOR = {\n    V: ' //VSEP// ',\n    H: ' --HSEP-- '\n};\n\nconst EMPTY_DIAGRAM = {\n    title: {\n        text: 'No data to display'\n    }\n};\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n/*\n*****************\nThis highchart is based on a heatmap, i.e. the chart is divided into a set of X * Y equally sized cells.\n* The first column(s) of the cells are used to show the vertical categories (categoriesVertical), which are provided as separate \"category\" series\n* The first row(s) of the cells are used to show the horizontal categories (categoriesHorizontal), which are provided as separate \"category\" series\n* The rest of the cells represent the data itself\n    * each cell can be identified by its set of vertical and horizontal categories saved as 'key' in the 'keys'-array in the form of a string like \"X Cat Level 1 - X Cat Level 2 / Y Cat Level 1 - Y Cat Level 2 - Y Cat Level 3\" (in theory the levels can be \"dynamic\", which is not used in this specific example. In this example only 1 level is used)\n    * for each cell the number of entities to be shown is counted as 'value' in the 'values'-array.\n    * the entities for each cell are represented as boxes/cards within the cell and are pushed as separate serie to the main data series\n    * dependencies between entities are represented as separate spline series, whereas start and end point of the splines are the left or right edge of the corresponding entity boxes/cards on the map\n\n/***** config options *****/\n\n// 1) category colors horizontal (for each level)\nlet catColorsH = ['#000000', '#dddddd', '#dddddd', '#cccccc', '#cccccc'];\n\n// 2) category colors vertical (for each level)\nlet catColorsV = ['#000000', '#dddddd', '#dddddd', '#cccccc', '#cccccc'];\nlet catColors = ['#dddddd', '#dddddd', '#dddddd', '#dddddd'];\n\n// 3) sort category names on this order\nconst sortOrders = [CATEGORY.SAFE_MILESTONE];\n\nconst maxCols = 1;\nconst maxRows = 1;\n\n\n/***** build up our category structures *****/\nlet categoriesHorizontal = { names: [], subs: [], startDates: [], endDates: [], colors: [], links: [] };\nlet categoriesVertical = { names: [], subs: [], startDates: [], endDates: [], colors: [], links: [] };\nlet keys = [];\nlet values = [];\nlet tooltips = [];\nlet shortNameMap = new Map();\nlet nameMap = new Map();\nlet titleMap = new Map();\nlet colorMap = new Map();\nlet depends = [];\nlet itemValues = [];\nlet itemCats = [];\n\n//--------------------------------------------------------------------------------------//\n//                                       INITIALIZATION                                 //\n//--------------------------------------------------------------------------------------//\n\n// If embedding page is Capability then itself is the item. Otherwise, use pages from connected table\nconst items = isPageOfTypeCapability(embeddingPage) ? [embeddingPage] : Array.from(pages);\nlog('items :'+items)\nlog('Items in pages: ' + items.length);\nif (items.length === 0) {\n    // noinspection JSAnnotator\n    return EMPTY_DIAGRAM;\n}\n\nconst missingDependencies = getMissingDependencies(items);\nitems.push(...missingDependencies);\nlog(`Added ${missingDependencies.length} missing items that the input items depend on.`);\n\nconst allPeriods = getAllPeriods(items);\nlog('allPeriods'+allPeriods)\nif (allPeriods.length === 0) {\n    // noinspection JSAnnotator\n    return EMPTY_DIAGRAM;\n}\n// const allPeriodNames = allPeriods.map(period => period.getName());\nconst allPeriodIds = allPeriods.map(period => period.getId());\nlog('Periods: ' + allPeriods.length);\n\nconst allPrograms = getPrograms(items);\nlog('Programs: ' + allPrograms.length);\n\n\n// Find release planning dashboard, needed for link in the release swimlane\n// const releasePlanningDashboard = Iterables.getFirst(solution.getIncomingPages(RELEASE_DASHBOARD.TYPE, RELEASE_DASHBOARD.ATTR.PROGRAM), null);\n// const releasesLink = releasePlanningDashboard.getUrl();\nconst releasesLink = 'wip';\n// Find PI Planning dashboard, needed for link in the safe milestone swimlane\n// const piManagementDashboard = Iterables.getFirst(solution.getIncomingPages(PI_PLANNING_DASHBOARD.TYPE, PI_PLANNING_DASHBOARD.ATTR.PROGRAM), null);\n// const piManagementLink = piManagementDashboard.getUrl();\nconst piManagementLink = 'wip';\n// Find solution train, needed for finding all programs\n// const solutionTrain = Iterables.getFirst(solution.getIncomingPages(TYPE_CAPABILITY.TYPE, TYPE_CAPABILITY.ATTR.SOLUTION), null);\n\n//find relevant Pis of the program\n// const piSearch = new Search();\n// piSearch.add(Filters.embeddingSpace());\n// piSearch.add(Filters.type(PI.TYPE));\n// piSearch.add(Filters.customAttribute(PI.ATTR.PROGRAM).references(solution));\n// let allPeriods = [];\n// cplace.each(pis, pi => {\n//     const periodStatus = pi.get(PI.ATTR.PERIOD_STATUS);\n//     if (periodStatus && periodStatus.get(PERIOD_STATUS.ATTR.ORDER) != null && periodStatus.get(PERIOD_STATUS.ATTR.ORDER) > -1) {\n//         relevantPiIds.push(pi.getId());\n//         allPeriods.push(pi);\n//     }\n// })\n\n// Create categories based on items\ncplace.each(items, item => {\n    let itemName = item.getName();\n    let itemTitle = item.get(TYPE_CAPABILITY.ATTR.TITLE);\n\n    // Determine dependencies\n    const itemDependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n    log('dependencies'+itemDependencies)\n    const lastItemIteration = getLastIteration(item);\n    const itemIterations = [];\n    if (lastItemIteration !== null) {\n        //only continue with feature, if it is in a relevant PI\n        const iterationId = lastItemIteration.getId();\n        if (allPeriodIds.includes(iterationId)) {\n            itemIterations.push(lastItemIteration);\n        } else {\n            return;\n        }\n    }\n\n    let itemPrograms = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n\n    cplace.each(itemIterations, iteration => {\n        const iterationName = iteration.getName();\n        const iterationUrl = iteration.getUrl();\n\n        // a) format/drilldown of horizontal (xAxis) categories\n        let catX = [\n            (iterationName == null ? ' ' : iterationName)\n        ];\n        // b) format/drilldown of vertical (yAxis) categories\n        let catYs = [];\n\n        cplace.each(itemPrograms, program => {\n            catYs.push({\n                name: [program.getName()],\n                link: program.getUrl()\n            })\n        })\n\n        if (catYs.length === 0) {\n            catYs.push({\n                name: ['w/o Program'],\n                link: null\n            });\n        }\n\n        // c) common keys across both axes (= name of cell within the chart)\n        const categories = [];\n        catYs.forEach(catY => {\n            const cat = [catX.join(SEPARATOR.H), catY.name.join(SEPARATOR.H)].join(SEPARATOR.V);\n            categories.push(cat)\n        });\n\n        // now add them to internal category model\n        categoriesHorizontal = addCategories(categoriesHorizontal, catX, 1, iteration, null, null, (iterationUrl == null ? ' ' : iterationUrl));\n        cplace.each(catYs, catY => {\n            categoriesVertical = addCategories(categoriesVertical, catY.name, 1, null, null, null, (catY.link == null ? ' ' : catY.link));\n        });\n\n        cplace.each(categories, cat => {\n            let idx = keys.indexOf(cat);\n            if (idx < 0) {\n                // key (category) not found -> add a new value\n                keys.push(cat);\n                values.push(1);\n                tooltips.push([itemName]);\n                // add feature name to name Map\n                nameMap.set(cat + 1, '<a href=\"' + item.getUrl() + '\">' + itemName + '</a>');\n                shortNameMap.set(cat + 1, '<a href=\"' + item.getUrl() + '\">' + item.getName().replace(itemTitle, '') + '</a>');\n                titleMap.set(cat + 1, itemTitle);\n                colorMap.set(cat + 1, (item.get(TYPE_CAPABILITY.ATTR.TYPE) === TYPE_CAPABILITY.ENUM.TYPE.CAPABILITY ? COLORS.CAPABILITY : COLORS.ENABLER));\n                //cplace.log ('1st entry nameMap: ' + nameMap.get(cat+1));\n                idx = keys.length - 1;\n            } else {\n                // found -> just update value\n                values[idx] = (values[idx] + 1);\n                tooltips[idx].push(itemName);\n                nameMap.set(cat + values[idx], '<a href=\"' + item.getUrl() + '\">' + itemName + '</a>');\n                shortNameMap.set(cat + values[idx], '<a href=\"' + item.getUrl() + '\">' + item.getName().replace(itemTitle, '') + '</a>');\n                titleMap.set(cat + values[idx], itemTitle);\n                colorMap.set(cat + values[idx], (item.get(TYPE_CAPABILITY.ATTR.TYPE) === TYPE_CAPABILITY.ENUM.TYPE.CAPABILITY ? COLORS.CAPABILITY : COLORS.ENABLER));\n                //cplace.log ('additional entry nameMap: ' + nameMap.get(cat+values[idx]));\n            }\n\n            // add dependencies\n            const itemId = item.getId();\n            if (itemCats[itemId] != null) {\n                itemCats[itemId].push(cat);\n                itemValues[itemId].push(values[idx]);\n            } else {\n                itemCats[itemId] = [cat];\n                itemValues[itemId] = [values[idx]];\n            }\n            itemDependencies.forEach(itemDependency => {\n                const from = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n                if (from && isPageOfTypeCapability(from)) {\n                    depends.push({ to: item, from: from, dependency: itemDependency });\n                }\n            });\n        });\n    });\n});\n\n// Manually add categories for missing ARTs and iterations (if no capability is in there, they were not added so far)\ncplace.each(allPeriods, period => {\n    let name = period.getName();\n    let url = period.getUrl();\n    let catX = [\n        (name == null ? ' ' : name)\n    ];\n    categoriesHorizontal = addCategories(categoriesHorizontal, catX, 1, period, null, null, (url == null ? ' ' : url));\n});\ncplace.each(allPrograms, program => {\n    let name = program.getName();\n    let url = program.getUrl();\n    let catY = [\n        (name == null ? ' ' : name)\n    ];\n    categoriesVertical = addCategories(categoriesVertical, catY, 1, null, null, null, (url == null ? ' ' : url));\n})\n\n// Add categories as swimlanes for the releases and SAFe milestones\n// categoriesVertical = addCategories(categoriesVertical, ['Releases'], 1, null, COLORS.RELEASE_PLOTBAND, 0, releasesLink);\ncategoriesVertical = addCategories(categoriesVertical, [CATEGORY.SAFE_MILESTONE], 1, null, COLORS.MILESTONE_PLOTBAND, 0, piManagementLink);\n\nlog('result H: ' + JSON.stringify(categoriesHorizontal));\nlog('result V: ' + JSON.stringify(categoriesVertical));\nlog('keys: ' + JSON.stringify(keys));\nlog('values: ' + JSON.stringify(values));\nlog('depends: ' + JSON.stringify(depends));\nlog('itemCats: ' + JSON.stringify(itemCats));\n\n//--------------------------------------------------------------------------------------//\n//                                       BUSINESS FUNCTIONS                             //\n//--------------------------------------------------------------------------------------//\n/**\n * Determines the periods used as columns of the board\n * @param {Page[]} items Capabilities\n * @returns {Page[]} Iterations in chronological order\n */\nfunction getAllPeriods(items) {\n    const periodsSet = new HashSet();\n    items.forEach(item => {\n        const pi = item.get(TYPE_CAPABILITY.ATTR.PROGRAM_INCREMENT);\n        if (!pi) {\n            return;\n        }\n        const iterations = pi.getIncomingPagesFromAllSpaces(TYPE_ITERATION.TYPE, TYPE_ITERATION.ATTR.PROGRAM_INCREMENT);\n        cplace.each(iterations, iteration => {\n            periodsSet.add(iteration);\n        });\n    });\n    const periods = Array.from(periodsSet);\n    return periods.sort((a, b) => a.get(TYPE_ITERATION.ATTR.START).isBefore(b.get(TYPE_ITERATION.ATTR.START)) ? -1 : 1);\n}\n\n/**\n * Determines all programs/ARTs that are included in the input data.\n * These elements are used to define the rows of the boards\n * @param {Page[]} items\n * @returns {Page[]} Programs\n */\nfunction getPrograms(items) {\n    const programSet = new HashSet();\n    items.forEach(item => {\n        const programs = item.get(TYPE_CAPABILITY.ATTR.PROGRAM);\n        if (!programs) {\n            return;\n        }\n        cplace.each(programs, program => programSet.add(program));\n    });\n    return Array.from(programSet);\n}\n\n/**\n * Searches dependencies of the items and returns those that are not yet included\n * @param {Page[]} items\n * @return {Page[]}\n */\nfunction getMissingDependencies(items) {\n    const dependencies = new HashSet();\n    items.forEach(item => {\n        const itemDependencies = Array.from(item.getIncomingPages(TYPE_DEPENDENCY.TYPE, TYPE_DEPENDENCY.ATTR.A) || []);\n        itemDependencies.forEach(itemDependency => {\n            const dependency = itemDependency.get(TYPE_DEPENDENCY.ATTR.B);\n            if (isPageOfTypeCapability(dependency)) {\n                dependencies.add(dependency);\n            }\n        });\n    });\n    return Array.from(dependencies).filter(a => !items.some(b => b.getId() === a.getId()));\n}\n\n/**\n * Determines the last iteration\n * @param {Page} item Category\n */\nfunction getLastIteration(item) {\n    const iterations = Array.from(item.get(TYPE_CAPABILITY.ATTR.TEMP_ITERATIONS));\n    // log(`Found ${iterations.length} iterations for item \"${item.getName()}\"`);\n    // TODO Use references of features to iterations once the data (model) is cleared\n    // const features = item.get(TYPE_CAPABILITY.ATTR.FEATURES);\n    // const iterationsSet = new HashSet();\n    // cplace.each(features, feature => {\n    //     const featureIterations = feature.get(TYPE_FEATURE.ATTR.ITERATIONS);\n    //     cplace.each(featureIterations, iteration => {\n    //         iterationsSet.add(iteration);\n    //     });\n    // });\n    //const iterations = Array.from(iterationsSet);\n    //log(`Found ${Iterables.size(features)} features and ${iterations.length} iterations for item \"${item.getName()}\"`);\n    let lastIteration = iterations.length > 0 ? iterations[0] : null;\n    iterations.forEach(iteration => {\n        if (lastIteration.get(TYPE_ITERATION.ATTR.END).isBefore(iteration.get(TYPE_ITERATION.ATTR.END))) {\n            lastIteration = iteration;\n        }\n    });\n    log(`Found ${iterations.length} iterations for item \"${item.getName()}\"`);\n    if (lastIteration) {\n        log(`Last iteration \"${lastIteration.getName()}\" ending ${lastIteration.get(TYPE_ITERATION.ATTR.END).toString()}`);\n    }\n    return lastIteration;\n}\n\n// helper function - insert new category into data structure (recursively)\nfunction addCategories(categories, names, level, iteration, color, order, link) {\n    // pop first name from stack and search\n    const categoryName = names.shift();\n    const idx = categories.names.indexOf(categoryName);\n    if (idx < 0) {\n        // not found yet -> insert new category name\n        let inserted = false;\n        const newOrder = sortOrders.indexOf(categoryName);\n        // now loop all current names and insert at right position (ordered!)\n        if (order != null) {\n            categories.names.forEach(cat => {\n                let currOrder = sortOrders.indexOf(cat);\n                if ((!inserted && newOrder >= 0 && currOrder >= 0 && newOrder < currOrder)\n                    || (!inserted && newOrder >= 0 && currOrder < 0) // if order of new category is specified and others are not\n                    || (!inserted && categoryName !== '' && categoryName < cat)) {\n                    categories.names.splice(order, 0, categoryName);\n\n                    // If there is an iteration, add StartDate and Enddate at catIdx Position\n                    categories.startDates.splice(order, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.START) : null));\n                    categories.endDates.splice(order, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.END) : null));\n\n                    // If there is a color, add it at catIdx Position\n                    categories.colors.splice(order, 0, (color ? color : null));\n\n                    // Add link for the category\n                    categories.links.splice(order, 0, (link ? link : null));\n\n                    if (names.length > 0) {\n                        // If there is more to check, go one level deeper\n                        categories.subs.splice(order, 0, addCategories({\n                            names: [],\n                            subs: [],\n                            startDates: [],\n                            endDates: [],\n                            colors: [],\n                            links: []\n                        }, names, level + 1, iteration, color, link));\n                    }\n                    inserted = true;\n                }\n            });\n        } else {\n            categories.names.forEach((cat, catIdx) => {\n                let currOrder = sortOrders.indexOf(cat);\n                if ((!inserted && newOrder >= 0 && currOrder >= 0 && newOrder < currOrder)\n                    || (!inserted && categoryName !== '' && categoryName < cat)) {\n                    categories.names.splice(catIdx, 0, categoryName);\n\n                    // if there is an iteration, add StartDate and Enddate at catIdx Position\n                    categories.startDates.splice(catIdx, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.START) : null));\n                    categories.endDates.splice(catIdx, 0, (iteration ? iteration.get(TYPE_ITERATION.ATTR.END) : null));\n\n                    // if there is a color, add it at catIdx Position\n                    categories.colors.splice(catIdx, 0, (color ? color : null));\n\n                    // add link for the category\n                    categories.links.splice(catIdx, 0, (link ? link : null));\n\n                    if (names.length > 0) {\n                        // if there is more to check, go one level deeper\n                        categories.subs.splice(catIdx, 0, addCategories({\n                            names: [],\n                            subs: [],\n                            startDates: [],\n                            endDates: [],\n                            colors: [],\n                            links: []\n                        }, names, level + 1, iteration, color, link));\n                    }\n                    inserted = true;\n                }\n            });\n        }\n        // nothing found -> add as last element in array\n        if (!inserted) {\n            log('Category not inserted');\n            categories.names.push(categoryName);\n\n            // there is an iteration, push new StartDate and Enddate\n            categories.startDates.push((iteration ? iteration.get(TYPE_ITERATION.ATTR.START) : null));\n            categories.endDates.push((iteration ? iteration.get(TYPE_ITERATION.ATTR.END) : null));\n\n            // if there is a color, add it at catIdx Position\n            categories.colors.push((color ? color : null));\n\n            // add link for the category\n            categories.links.push((link ? link : null));\n\n            if (names.length > 0) {\n                // if there is more to check, go one level deeper\n                categories.subs.push(addCategories({\n                    names: [],\n                    subs: [],\n                    startDates: [],\n                    endDates: [],\n                    colors: [],\n                    links: []\n                }, names, level + 1, iteration, color, link));\n            }\n        }\n    } else {\n        // found -> just go one level deeper\n        if (names.length > 0) {\n            // if there is more to check, go one level deeper\n            categories.subs[idx] = addCategories(categories.subs[idx], names, level + 1, iteration, color);\n        }\n    }\n    return categories;\n}\n\n// now build up highcharts data series\nconst series = [];\n\n// helper function - count (sub-) categories to derive x- and y-offsets (recursively)\nfunction countCategories(categories, xOffset, yOffset, level, maxLevel, dir) {\n    let cnt = 0;\n    // starting coordinate (depending on direction, vertical/horizontal)\n    if (dir === 'H') {\n        categories.start = xOffset;\n    } else {\n        categories.start = yOffset;\n    }\n\n    // loop all category names\n    categories.names.forEach((name, idx) => {\n        let subCnt = 1;\n        // go one level deeper, if there is more, and add up sub-categories\n        if (categories.subs && idx < categories.subs.length) {\n            categories.subs[idx] = countCategories(categories.subs[idx], xOffset, yOffset, level + 1, maxLevel, dir);\n            subCnt = categories.subs[idx].cnt;\n        }\n\n        // calc coordinates\n        let colSize = 1;//(level == maxLevel ? maxCols : 1);\t\t// last level will be size 2x1\n        let rowSize = 1;//(level == maxLevel ? maxRows : 1);\t\t// last level will be size 1x2\n        let rotation = 0;\n        let x = xOffset;\n        let y = yOffset;\n        let color = categories.colors[idx] !== null ? categories.colors[idx] : catColors[level]; //'#ffffff';\t\t// coloring by level\n        let fontColor = '#000000';\n        if (dir === 'H') {\n            // horizontal categories\n            colSize = subCnt;\t\t\t\t\t\t\t\t// span multiple columns\n            rotation = 0;                                 // no rotation (level == maxLevel ? -90 : 0);\t\t// rotate only on max level\n            x += (subCnt - 1) / 2;\n            y += level + (level === maxLevel ? (maxRows - 1) / 2.0 : 0);\n            //color = catColorsH[1+xOffset%2];\t\t\t\t// alternating colors from config object (1 or 2)\n            //fontColor = catColorsH[0];\t\t\t\t\t// first color from config object\n        } else {\n            // vertical categories\n            rowSize = subCnt;\t\t\t\t\t\t\t\t// span multiple rows\n            rotation = (level === maxLevel ? 0 : -90);\t\t// rotate all but max level\n            x += level + (level === maxLevel ? (maxCols - 1) / 2.0 : 0);\n            y += (subCnt - 1) / 2;\n            //color = catColorsV[1+yOffset%2];\t\t\t\t// alternating colors from config object (1 or 2)\n            //fontColor = catColorsV[0];\t\t\t\t\t// first color from config object\n        }\n\n        // Find link to the page the category should lead to\n        let link = categories.links[idx];\n\n        if (name != null && name.length > 1) {\n            // now add categories cell to series\n            series.push({\n                name: name,\n                colsize: colSize,\n                rowsize: rowSize,\n                dataLabels: { rotation: rotation, color: fontColor },\n                enableMouseTracking: false,\n                data: [{ x: x, y: y, value: level, name: '<a href=\"' + link + '\">' + name + '</a>', color: color }]\n            });\n        }\n\n        // update coordinates\n        if (dir === 'H') {\n            xOffset += subCnt;\n        } else {\n            yOffset += subCnt;\n        }\n        cnt += subCnt;\n    });\n    categories.cnt = cnt;\n    categories.end = categories.start + cnt;\n    return categories;\n}\n\n\n// helper function - maximum depth of categories\nfunction findMaxLevel(categories, level) {\n    let maxLevel = level;\n    if (categories.subs) {\n        categories.subs.forEach(sub => {\n            maxLevel = findMaxLevel(sub, level + 1);\n        });\n    }\n    return maxLevel;\n}\n\n// find maximum depth in both directions\nlet maxLevelV = findMaxLevel(categoriesVertical, 1);\nlet maxLevelH = findMaxLevel(categoriesHorizontal, 1);\n\n// count and build series objects for categories\ncategoriesVertical = countCategories(categoriesVertical, 0, maxLevelH + maxRows, 1, maxLevelV, 'V');\n//let maxOffsetV = categoriesVertical.cnt;\ncategoriesHorizontal = countCategories(categoriesHorizontal, maxLevelV + maxCols, 0, 1, maxLevelH, 'H');\n//let maxOffsetH = categoriesHorizontal.cnt;\n\nlog('result H: ' + JSON.stringify(categoriesHorizontal));\nlog('result V: ' + JSON.stringify(categoriesVertical));\n\n\nconst maxValue = Math.max(...values);\n\n// finally add cells for each value of the matrix\n// loop all keys (= joined category for both axes)\nkeys.forEach((key, idx) => {\n    // split key into categories and names\n    const cat = key.split(SEPARATOR.V);\n    const catX = cat[0].split(SEPARATOR.H);\n    const catY = cat[1].split(SEPARATOR.H);\n    const x = findCategory(categoriesHorizontal, catX);\n    const y = findCategory(categoriesVertical, catY);\n\n    let val = values[idx];\n\n    // special build up name of cell for tooltip\n    let name = '<b>' + key + '</b><br>';\n\n    const data = [];\n    let offset = -0.4 + 0.4 / maxValue;\n    for (let n = 0; n < val; n++) {\n        let mapKey = n + 1;\n        data.push({\n            x: x,\n            y: y + offset,\n            value: n,\n            name: nameMap.get(key + mapKey),\n            shortName: shortNameMap.get(key + mapKey),\n            color: colorMap.get(key + mapKey),\n            title: titleMap.get(key + mapKey)\n        });\n        offset += 0.8 / maxValue;\n    }\n\n    // add series for new data value (= single cell in matrix) ///TO DO: linking with same capability in other program swimlane\n    series.push({\n        name: tooltips[idx].join('<br>'),\n        colsize: 0.8,\n        rowsize: 0.7 / maxValue, //1,\n        pointPadding: 0,\n        borderRadius: 0, //25,\n        borderWidth: 1,\n        borderColor: 'rgba(0,0,0,0)',\n        dataLabels: {\n            enabled: true,\n            color: '#000000',\n            format: '{point.shortName}'\n        },\n        enableMouseTracking: true,\n        data: data //[{ x: x, y: y, value: val, name: val, color: color }]\n    });\n});\n\n\n// helper function - evaluate coordinates of given key (= category along both axes)\nfunction findCategory(categories, names) {\n    const categoryName = names.shift();\n    const idx = categories.names.indexOf(categoryName);\n    if (names.length > 0 && idx >= 0 && categories.subs && categories.subs.length > 0) {\n        return findCategory(categories.subs[idx], names);\n    }\n    return categories.start + idx;\n}\n\n// Iterate through all dependencies in order to draw them\ndepends.forEach(depend => {\n    const fromId = depend.from.getId();\n    const toId = depend.to.getId();\n    // split key into categories and names\n    const fromCats = itemCats[fromId];\n    if (!fromCats) {\n        return;\n    }\n    fromCats.forEach((fromCat, idx1) => {\n        const cat1 = fromCat.split(SEPARATOR.V);\n        const catX1 = [cat1[0]];//.split(\" - \");\n        //catX1.push(cat1[0]);\n        const catY1 = [cat1[1]];//.split(\" - \");\n        //catY1.push(cat1[1]);\n        const x1 = findCategory(categoriesHorizontal, catX1);\n        let y1 = findCategory(categoriesVertical, catY1);\n        y1 += -0.4 + 0.4 / maxValue + (itemValues[depend.from.getId()][idx1] - 1) * 0.8 / maxValue;\n\n        const toCats = itemCats[toId];\n        if (!toCats) {\n            // Dependency is not included in diagram scope and cannot be drawn\n            return;\n        }\n        toCats.forEach((toCat, idx2) => {\n            const cat2 = toCat.split(SEPARATOR.V);\n            const catX2 = [cat2[0]];\n            const catY2 = [cat2[1]];\n            const x2 = findCategory(categoriesHorizontal, catX2);\n            let y2 = findCategory(categoriesVertical, catY2);\n            y2 += -0.4 + 0.4 / maxValue + (itemValues[depend.to.getId()][idx2] - 1) * 0.8 / maxValue;\n            const description = depend.dependency.get(TYPE_DEPENDENCY.ATTR.DESCRIPTION) || ' ';\n            const dependencyType = depend.dependency.get(TYPE_DEPENDENCY.ATTR.TYPE);\n            const status = depend.dependency.get(TYPE_DEPENDENCY.ATTR.STATUS);\n\n            const dependencySeries = {\n                type: 'spline',\n                name: '<b>' + depend.to.getName() + '</b><br/>relates to:<br/>' + depend.from.getName() + '<br>' + description,\n                lineWidth: 1.5,\n                color: COLORS.DEPEND,\n                dashStyle: 'shortdot',\n                findNearestPointBy: 'xy',\n                data: [\n                    { x: x1 + 0.4, y: y1 },\n                    { x: x1 + 0.45, y: (y1 === y2 ? y1 + 0.02 : y1) },\n                    { x: x2 - 0.45, y: (y1 === y2 ? y2 - 0.02 : y2) },\n                    { x: x2 - 0.4, y: y2, marker: { enabled: true, symbol: 'diamond' } }\n                ]\n            };\n            if (dependencyType === TYPE_DEPENDENCY.ENUM.TYPE.BLOCKED_BY) {\n                dependencySeries.name = '<b>' + depend.to.getName() + '</b><br/>blocked by:<br/>' + depend.from.getName() + '<br>' + description;\n                dependencySeries.dashStyle = null;\n            }\n            if (status === TYPE_DEPENDENCY.ENUM.STATUS.CONFLICT) {\n                dependencySeries.color = COLORS.DEPEND_HIGHLIGHT;\n            } else if (status === TYPE_DEPENDENCY.ENUM.STATUS.RESOLVED) {\n                dependencySeries.color = COLORS.DEPEND_RESOLVED;\n            }\n            series.push(dependencySeries);\n        });\n    });\n});\n\n\n// Add releases\n// let releaseDateSearch = new Search();\n// releaseDateSearch.add(Filters.embeddingSpace());\n// releaseDateSearch.add(Filters.type(TYPE_RELEASE.TYPE));\n// releaseDateSearch.add(Filters.customAttribute(RELEASE.ATTR.PROGRAM).references(solution));\n// let releases = releaseDateSearch.findAllPages();\n//  let releaseData = [];\n//\n// cplace.each(releases, function (release) {\n//     let releaseName = release.getName();\n//     let releaseDate = release.get(RELEASE.ATTR.DATE);\n//     let releaseDateString = releaseDate.toString('dd.MM.yyyy');\n//     // get release Position\n//     let releasePosition = getDatePosition(releaseDate.getMillis());\n//     // add release only if releasePosition is not null\n//     if (releasePosition > 0) {\n//         releaseData.push({\n//             x: releasePosition,\n//             y: 2,\n//             name: '<a href=\"' + release.getUrl() + '\">' + releaseName + '</a>',\n//             value: releaseDateString\n//         });\n//     }\n// });\n//\n// series.push({\n//     type: 'scatter',\n//     lineWidth: 0,\n//     findNearestPointBy: 'xy',\n//     data: releaseData,\n//     marker: {\n//         fillColor: COLORS.RELEASE\n//     }\n// });\n\n// Add SAFe milestones\nconst periodStartDate = allPeriods.length > 0 ? allPeriods[0].get(TYPE_ITERATION.ATTR.START) : new DateTime();\nconst periodEndDate = allPeriods.length > 0 ? allPeriods[allPeriods.length - 1].get(TYPE_ITERATION.ATTR.END) : new DateTime();\nconst safeMilestoneSearch = new Search();\nsafeMilestoneSearch.add(Filters.embeddingSpace());\nsafeMilestoneSearch.add(Filters.type(TYPE_MILESTONE.TYPE));\nsafeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).gte(periodStartDate));\nsafeMilestoneSearch.add(Filters.customAttribute(TYPE_MILESTONE.ATTR.DATE).lte(periodEndDate));\nconst safeMilestones = safeMilestoneSearch.findAllPages();\nconst safeMilestoneData = [];\n\nlog('Milestones: ' + safeMilestones.length);\n\ncplace.each(safeMilestones, safeMilestone => {\n    const safeMilestoneName = safeMilestone.getName();\n    const safeMilestoneDate = safeMilestone.get(TYPE_MILESTONE.ATTR.DATE);\n    const safeMilestoneDateString = safeMilestoneDate.toString('dd.MM.yyyy');\n    // get milestone Position\n    const safeMilestonePosition = getDatePosition(safeMilestoneDate.getMillis());\n    // add milestone only if position is not null\n    if (safeMilestonePosition > 0) {\n        safeMilestoneData.push({\n            x: safeMilestonePosition,\n            y: 2,\n            name: '<a href=\"' + safeMilestone.getUrl() + '\">' + safeMilestoneName + '</a>',\n            value: safeMilestoneDateString\n        });\n    }\n});\n\nseries.push({\n    type: 'scatter',\n    lineWidth: 0,\n    findNearestPointBy: 'xy',\n    data: safeMilestoneData,\n    marker: {\n        fillColor: COLORS.SAFE_MILESTONE\n    }\n});\n\n//define today line position\nconst today = new DateTime();\nlet todayPosition = getDatePosition(today.getMillis());\n\n\n//helper function for finding milestone/today line position\nfunction getDatePosition(date) {\n    let xPosition = 0;\n    categoriesHorizontal.names.every((categoryName, idx) => {\n        let categoryStartDate = categoriesHorizontal.startDates[idx].getMillis();\n        let categoryEndDate = categoriesHorizontal.endDates[idx].getMillis();\n        // Check whether release date lies in between start and end date of category\n        if (date >= categoryStartDate && date <= categoryEndDate) {\n            // find x-Value of category and substract 0.5 for starting point as offset\n            let x = findCategory(categoriesHorizontal, [categoryName]) - 0.5;\n            // calculate the relative position of date between Category StartDate and EndDate and add it to the offset value\n            xPosition = x + (date - categoryStartDate) / (categoryEndDate - categoryStartDate);\n            // exit the every loop\n            return false;\n        }\n        // continue the every loop\n        return true;\n    });\n    // if there was no match, just return null\n    return xPosition;\n}\n\n\n// Build the Highcharts configuration object\nconst chart = {\n    chart: {\n        type: 'heatmap',\n        marginTop: 0,\n        marginBottom: 0,\n        plotBorderWidth: 0\n    },\n    title: {\n        text: null\n    },\n    xAxis: {\n        categories: [],\n        title: null,\n        gridLineWidth: 0,\n        lineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        //min: -1,\n        //max: Math.max(categoriesVertical.end,categoriesHorizontal.end)-1\n        plotLines: [{\n            dashStyle: 'dash',\n            color: COLORS.TODAY_PLOTLINE,\n            width: 2,\n            value: todayPosition,\n            zIndex: 1\n        }]\n    },\n    yAxis: {\n        categories: [],\n        title: null,\n        gridLineWidth: 0,\n        lineWidth: 0,\n        labels: {\n            enabled: false\n        },\n        reversed: true,\n        // min: -1,\n        // max: Math.max(categoriesVertical.end, categoriesHorizontal.end) - 1,\n        plotBands: [\n            {\n                color: COLORS.MILESTONE_PLOTBAND,\n                borderColor: 'white',\n                borderWidth: 2,\n                from: 1.5,\n                to: 2.5,\n                zIndex: 0\n            }\n            // {\n            //     color: COLORS.RELEASE_PLOTBAND,\n            //     borderColor: 'white',\n            //     borderWidth: 2,\n            //     from: 1.5,\n            //     to: 2.5,\n            //     zIndex: 0\n            // }\n        ]\n    },\n    colors: ['#D5001C', '#92D050'],\n    colorAxis: {\n        dataClassColor: 'category',\n        dataClasses: [{\n            to: 0.5\n        }, {\n            from: 0.5\n        }]\n    },\n    legend: {\n        enabled: false\n    },\n    tooltip: {\n        useHTML: true,\n        followPointer: false\n    },\n    plotOptions: {\n        series: {\n            borderColor: '#ffffff',\n            borderWidth: 2,\n            dataLabels: {\n                allowOverlap: false,\n                inside: true,\n                crop: true,\n                overflow: 'justify',\n                position: 'left',\n                shape: 'circle',\n                enabled: true,\n                color: '#000000',\n                format: '{point.name}',\n                style: {\n                    textOutline: 'none',\n                    textOverflow: 'clip'\n                }\n            },\n            stickyTracking: false,\n            tooltip: {\n                headerFormat: '',\n                pointFormat: '<b>{point.name}</b>',\n                findNearestPointBy: 'xy',\n            },\n            states: {\n                inactive: {\n                    opacity: 1\n                }\n            }\n        },\n        spline: {\n            tooltip: {\n                headerFormat: '{series.name}',\n                pointFormat: '',\n                findNearestPointBy: 'xy',\n            },\n            marker: {\n                enabled: false,\n                fillColor: COLORS.DEPEND,\n                radius: 6,\n                states: {\n                    hover: {\n                        enabled: false\n                    }\n                }\n            }\n        },\n        scatter: {\n            tooltip: {\n                headerFormat: '',\n                pointFormat: '<b>{point.name}</b><br>{point.value}',\n                findNearestPointBy: 'xy'\n            },\n            dataLabels: {\n                enabled: true\n            },\n            marker: {\n                enabled: true,\n                symbol: 'diamond',\n                radius: 10,\n                states: {\n                    hover: {\n                        enabled: true\n                    }\n                }\n            }\n        }\n    },\n    series: series\n};\n\n// noinspection JSAnnotator\nreturn chart;\n\n//--------------------------------------------------------------------------------------//\n//                                       HELPER FUNCTIONS                               //\n//--------------------------------------------------------------------------------------//\n\nfunction isPageOfTypeCapability(page) {\n    return page.getBuiltinFeatureValue('customType') === TYPE_CAPABILITY.TYPE;\n}\n\n/**\n * Log to cplace\n * @param {any} text\n */\nfunction log(text) {\n    if (!DEBUG) {\n        return;\n    }\n    const logOutput = (typeof text !== 'string') ? JSON.stringify(text) : text;\n    cplace.log(logOutput);\n}",
    "attributes": null,
    "type_name": null,
    "counter": 35
}