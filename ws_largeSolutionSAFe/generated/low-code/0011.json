{
    "type": "cf.cplace.platform.PageAction",
    "code": "cplace.setLogName('pageAction on PI-ProgramIncrement Progress');\n\n//Configurations\nconst PI={\n  TYPE:'cf.cplace.solution.safe.programIncrement',\n  ATTR:{\n    periodStatus:'cf.cplace.solution.safe.periodStatus',\n    predecessor:'cf.cplace.solution.safe.predecessor'\n  },\n  refAttr:{\n  \torder:'cf.cplace.solution.safe.order'\n}\n}\nconst periodStatus={\n  TYPE:'cf.cplace.solution.safe.periodStatus',\n  ATTR:{\n  \torder:'cf.cplace.solution.safe.order'\n}\n}  \n\nlet orderarr=[];\nlet sarr=[];\nlet order = (page.get(PI.ATTR.periodStatus) ? page.get(PI.ATTR.periodStatus).get(PI.refAttr.order) : null);\n\n return {\n   \n   checkAccess: function() {\n              // Pageaction should only be available when the periodStatus is 'Running'\n                if (order == 0) {\n                    return true;\n                }\n                return false;\n            }, \n  \tcall: function() {\n    \treturn doBusinessAction(page);\n  \t}\n}\n \n \n function doBusinessAction(page){\n   \n   let order=(page.get(PI.ATTR.periodStatus) ? page.get(PI.ATTR.periodStatus).get(PI.refAttr.order) : null);\n   let update=true; //setting the flag to check whether the update process should be performed or not\n  \n   \n   /*orderMap is required to get the corresponding periodStatus of the order */\n   let orderSearch=new Search();\n   orderSearch.add(Filters.space(page.getSpaceId()));\n   orderSearch.add(Filters.type(periodStatus.TYPE));\n   orderSearch.add(Filters.customAttributeNonempty(periodStatus.ATTR.order));\n   let result=orderSearch.findAllPages();\n   \n   let orderMap=new Map();\n    if(result){\n       cplace.each(result,function(value){\n         orderMap.set(value.get(periodStatus.ATTR.order),value);\n         orderarr.push(value.get(periodStatus.ATTR.order));\n       });\n    }\n  \n     /*Get the highest order */\n     let highorder=Math.max(...orderarr);\n     cplace.log(highorder);\n     /*check the predecessor chain to be set properly or not*/\n     let arr= checkforPredecessorChain(page); \n     for(let i=0;i<=highorder;i++){\n        if(arr[i]==null){\n          update=false;\n    /*Return the error message if the predecessor chain is not set*/    \n       return {\n            success: false, // default is true\n            message: {\n                en: 'Set the predeccessor chain properly'\n            } \n         }  \n      }\n   }   \n\n     // update the periodStatus \n     if(update){\n        updateperiodStatus(page, order, orderMap);  \n     }\n }\n     \n  \n \n \nfunction updateperiodStatus(page, orderIncr, orderMap) {\n \n   let newPeriodStatus = orderMap.get(orderIncr - 1);\n      \n     if (newPeriodStatus) {\n        cplace.actions().updatePage(page, {\n           customAttributes: {\n            [PI.ATTR.periodStatus]: newPeriodStatus //update the status to the one which comes next in the order (decreased by 1)\n             }\n         });\n     orderIncr += 1;\n            \n     // check for the successor PI if successor is present then update its periodStatus\n     let successor = Iterables.getFirst(page.getIncomingPages(PI.TYPE,PI.ATTR.predecessor), null);\n       \n     if (successor) {\n            updateperiodStatus (successor, orderIncr, orderMap);\n         }\n\t  }\n}\n\n\n function checkforPredecessorChain(page){\n    let successor = Iterables.getFirst(page.getIncomingPages(PI.TYPE,PI.ATTR.predecessor), null);\n    sarr.push(successor);\n    if(successor!=null){\n       cplace.log(successor.getName());\n       checkforPredecessorChain(successor,sarr);\n    }else{\n       cplace.log('check the chain');\n    }\n     \n    return sarr;\n }",
    "attributes": null,
    "type_name": "cf.cplace.solution.safe.programIncrement",
    "counter": 11
}