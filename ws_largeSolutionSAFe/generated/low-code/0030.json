{
    "type": "custom_attribute",
    "code": "/**\n *\n */\n\nconst DEBUG = false;\n\nconst PROGRAM_INCREMENT = {\n    TYPE: \"cf.cplace.solution.safe.programIncrement\",\n    ATTR: {\n        START_DATE: \"cf.cplace.solution.safe.startDate\",\n        END_DATE: \"cf.cplace.solution.safe.endDate\",\n        STATISTICS: \"cf.cplace.solution.safe.statsJson\",\n    },\n};\n\nconst pi = Array.from(pages)[0];\n\nif (pi?.getBuiltinFeatureValue(\"customType\") !== PROGRAM_INCREMENT.TYPE) {\n    throw new Error(\"Please provide a single team iteration in the chart search.\");\n}\n\nconst startDate = pi.get(PROGRAM_INCREMENT.ATTR.START_DATE).withTimeAtStartOfDay();\nconst endDate = pi.get(PROGRAM_INCREMENT.ATTR.END_DATE).withTimeAtStartOfDay();\n/** @type {Statistics} */\nlet statistics = null;\ntry {\n    statistics = JSON.parse(pi.get(PROGRAM_INCREMENT.ATTR.STATISTICS));\n    DEBUG && cplace.log(statistics);\n} catch (e) {\n    return {\n        title: {\n            text: null,\n        },\n    };\n}\n\nif (!statistics || !statistics.archive || !statistics.current) {\n    return {\n        title: {\n            text: null,\n        },\n    };\n}\n\nconst today = DateTime.parse(statistics.current.date).withTimeAtStartOfDay();\n\n// Sort statistics by Date\nconst sortedStatistics = statistics.archive.sort((a, b) => Days.daysBetween(new DateTime(Date.parse(b.date)), new DateTime(Date.parse(a.date))).getDays());\n\n// Define the data for Release Burndown\nlet data = sortedStatistics\n    .map((element) => {\n        const currentDate = DateTime.parse(element.date);\n        return {\n            day: currentDayNumber(startDate, currentDate),\n            planned: linearPercentageDegression(element.burndown.planned, currentDate, startDate, endDate),\n            actual: element.burndown.planned - element.burndown.done,\n            forecast: null,\n        };\n    })\n    .sort((a, b) => a.day - b.day);\n\nconst lastDataPoint = sortedStatistics[sortedStatistics.length - 1];\n\nlet currentDate = new DateTime(Date.parse(lastDataPoint.date));\n\nwhile (!currentDate.isAfter(endDate.plusSeconds(5))) {\n    const currentDateKey = currentDayNumber(startDate, currentDate);\n\n    // DEBUG && cplace.log(currentDateKey)\n\n    if (!data.some((el) => currentDateKey === el.day)) {\n        data.push({\n            day: currentDateKey,\n            planned: linearPercentageDegression(statistics.current.burndown.planned, currentDate, startDate, endDate),\n            actual: null,\n            forecast: linearPercentageDegressionForecast(statistics.current.burndown.planned, statistics.current.burndown.done, currentDate, today, endDate),\n        });\n    }\n\n    currentDate = currentDate.plusDays(1);\n}\n\ndata = sortByKey(data, \"day\");\n\n// Create the chart\nreturn {\n    chart: {\n        type: \"line\",\n    },\n    title: {\n        text: \"Program Increment Burn-Down Chart\",\n    },\n    xAxis: {\n        title: {\n            text: \"Day\",\n        },\n        categories: data.map((data) => data.day),\n    },\n    yAxis: {\n        title: {\n            text: \"Story Points\",\n        },\n    },\n    plotLines: [\n        {\n            color: \"#33ff33\",\n            width: 1,\n            zIndex: 9999,\n            value: 12,\n        },\n    ],\n    series: [\n        {\n            name: \"Ideal Burndown\",\n            data: data.map((data) => data.planned),\n            color: \"lightblue\",\n        },\n        {\n            name: \"Forecast\",\n            data: data.map((data) => data.forecast || data.actual),\n            color: {\n                pattern: {\n                    color: \"#ccccff\",\n                    opacity: 0.5,\n                },\n            },\n        },\n        {\n            name: \"Remaining Storypoints\",\n            data: data.map((data) => data.actual),\n            color: \"#6666ff\",\n        },\n    ],\n};\n\nfunction linearPercentageDegression(planned, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    return planned * (daysLeft / daysFullIteration);\n}\n\nfunction linearPercentageDegressionForecast(planned, done, currentDate, startDate, endDate) {\n    const daysFullIteration = Days.daysBetween(startDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n    const daysLeft = Days.daysBetween(currentDate.withTimeAtStartOfDay(), endDate.withTimeAtStartOfDay()).getDays();\n\n    DEBUG && cplace.log(\"daysfull: \" + daysFullIteration);\n    DEBUG && cplace.log(\"daysleft: \" + daysLeft);\n\n    if (daysFullIteration === 0) {\n        return done;\n    }\n\n    return (planned - done) * (daysLeft / daysFullIteration);\n}\n\nfunction sortByKey(array, key) {\n    return array.sort(function (a, b) {\n        var x = a[key];\n        var y = b[key];\n        return x < y ? -1 : x > y ? 1 : 0;\n    });\n}\n\nfunction currentDayNumber(startDate, currentDate) {\n    return Days.daysBetween(startDate.withTimeAtStartOfDay(), currentDate.withTimeAtStartOfDay()).getDays();\n}",
    "attributes": null,
    "type_name": null,
    "counter": 30
}