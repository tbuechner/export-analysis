
######### start - content of file "group-user-matrix/AbstractMatrixCtrl.ts" #########
import { IAngularEvent, IAugmentedJQuery, IHttpPromiseCallbackArg, IHttpService, IScope } from 'angular';
import { EVENT_RESIZE_FIXED_PANE_SCROLL_CONTAINERS } from '../cplaceFixedPaneScroll';
import { ColumnFiltersDialogCtrl, IFiltersDialogSavedEventData } from '../../flexigrid/controllers/ColumnFiltersDialogCtrl';
import * as _ from 'underscore';
import { PostHeadersService } from '../../services/PostHeadersService';

export interface IMatrixState {
  loadDataUrl: string;
  filterRowsDialogUrl?: string;
  filterColumnsDialogUrl?: string;
  toggleUrl?: string;
  matrixCustomInlineStyles: IMatrixCustomInlineStyle;
  additionalData: any;
}

export interface IEdge {
  rowId: string;
  columnId: string;
  iconClass: string;
  tooltip: string;
  edgeClass: string;

  [name: string]: string;
}

export interface INode {
  id: string;
  name: string;
  url: string;
}

export interface IMatrixData {
  rowPage: number;
  columnPage: number;
  rows: Array<INode>;
  columns: Array<INode>;
  edges: {
    [rowId: string]: {
      [columnId: string]: IEdge;
    };
  };
  excessiveDataColumns: boolean;
  excessiveDataRows: boolean;
}

export interface IMatrixCustomInlineStyle {
  columnHeadlineStyles: string;
  rowHeadlineStyles: string;
  wrappingTableStyles: string;
  matrixInfoStyles: string;
}

export abstract class AbstractMatrixCtrl {
  state: IMatrixState;
  data: IMatrixData;
  afterRenderEvent = EVENT_RESIZE_FIXED_PANE_SCROLL_CONTAINERS;
  loading = false;
  private filterForRows: boolean;
  private rowFilters: Object;
  private columnFilters: Object;
  private rowPage: number;
  private columnPage: number;

  constructor(protected $scope: IScope, protected $element: IAugmentedJQuery, protected $http: IHttpService, protected postHeadersService: PostHeadersService) {
    $scope.$on(ColumnFiltersDialogCtrl.EVENT_SAVED, (e: IAngularEvent, data: IFiltersDialogSavedEventData) => {
      e.stopPropagation();
      if (this.filterForRows) {
        this.rowFilters = data.filters;
      } else {
        this.columnFilters = data.filters;
      }
      this.loadData();
    });
    $scope.$on(ColumnFiltersDialogCtrl.EVENT_RESTORE, (e: IAngularEvent) => {
      e.stopPropagation();
      if (this.filterForRows) {
        this.rowFilters = null;
      } else {
        this.columnFilters = null;
      }
      this.loadData();
    });
  }

  /**
   * Do NOT override this method. Override doInitialize to setup stuff. doInitialize is called at the end of initialize method
   */
  initialize(state: IMatrixState) {
    this.state = state;
    this.doInitialize();
    this.loadData();
  }

  /**
   * class names returned by this will be added to the top level element of matrix for custom styling
   */
  abstract getMatrixClass(): string;

  filterRows() {
    this.filterForRows = true;
    presentURLinModal(this.state.filterRowsDialogUrl, {
      data: {
        filters: this.rowFilters ? JSON.stringify(this.rowFilters) : null
      },
      isLarge: true,
      angularScope: this.$scope
    });
  }

  filterColumns() {
    this.filterForRows = false;
    presentURLinModal(this.state.filterColumnsDialogUrl, {
      data: {
        filters: this.columnFilters ? JSON.stringify(this.columnFilters) : null
      },
      isLarge: true,
      angularScope: this.$scope
    });
  }

  hasRowFilters() {
    return this.rowFilters && !!Object.keys(this.rowFilters).length;
  }

  hasColumnFilters() {
    return this.columnFilters && !!Object.keys(this.columnFilters).length;
  }

  /**
   * return an object containing data that will be set to toggle handler
   * rowId and columnId are added later
   */
  getDataForToggleHandler(): object {
    return {};
  }

  /**
   * handle click event on grid, this method will be passed rowId and columnId
   */
  toggleEdge(rowId: string, columnId: string) {
    if (!this.canBeToggled(rowId, columnId)) {
      return;
    }
    if (!this.state.toggleUrl) {
      throw new Error('No url provided to handle toggle action');
    }
    this.doToggle(rowId, columnId);
  }

  loadMore(type: 'row' | 'column') {
    if (type == 'row') {
      this.rowPage = this.data.rowPage + 1;
    }
    if (type == 'column') {
      this.columnPage = this.data.columnPage + 1;
    }
    this.loadData();
  }

  highlightRowColumn(rowIndex, columnIndex) {
    this.$element.find('.cf-cplace-matrix-rows tr').eq(rowIndex).addClass('hovered');
    this.$element.find('.cf-cplace-matrix-columns th').eq(columnIndex).addClass('hovered');
  }

  unhighlightRowColumn(rowIndex, columnIndex) {
    this.$element.find('.cf-cplace-matrix-rows tr').eq(rowIndex).removeClass('hovered');
    this.$element.find('.cf-cplace-matrix-columns th').eq(columnIndex).removeClass('hovered');
  }

  addRowWidthChangeHandler(handler: Function): Function {
    let $matrixRowsElement: JQuery = this.$element.find('.matrix-rows');
    let unwatchMatrixRows: Function = angular.noop;
    const throttledResizeHandler = _.throttle(() => {
      handler($matrixRowsElement.width());
    }, 100);
    const addResizeHandler = (): void => {
      $matrixRowsElement.resize(throttledResizeHandler);
    };
    const removeResizeHandler = () => {
      unwatchMatrixRows();
      $matrixRowsElement.off('resize', throttledResizeHandler);
    };
    if ($matrixRowsElement.length) {
      addResizeHandler();
    } else {
      unwatchMatrixRows = this.$scope.$watch(() => {
        return this.$element.find('.matrix-rows')[0];
      }, (newValue) => {
        if (newValue instanceof HTMLElement) {
          $matrixRowsElement = angular.element(newValue);
          addResizeHandler();
          unwatchMatrixRows();
        }
      });
    }
    return removeResizeHandler;
  }

  getStylesObject(styles: string): { [key: string]: string } {
    let stylesObject = {};

    if (styles) {
      styles.split(';')
        .filter(item => item.length > 0)
        .map(style => style.trim().split(':'))
        .forEach(stylePair => stylesObject[stylePair[0]] = stylePair[1]);
    }

    return stylesObject;
  }

  protected doInitialize() {
  }

  protected getEdge(rowId: string, columnId: string) {
    let edges = this.data.edges[rowId];
    if (edges) {
      return edges[columnId];
    } else {
      return null;
    }
  }

  /**
   * Override this function to return a custom CSS class, which will be added to each grid cell.
   */
  protected getCustomCellClass(rowId: string, columnId: string){
  }

  /**
   * Determines if the grid cell can be clicked.
   * sub classes should implement this method to provide their own logic to decide
   */
  protected canBeToggled(rowId: string, columnId: string): boolean {
    return true;
  }

  /**
   * may be overridden to customize the behaviour when toggling
   * e.g. open a modal confirmation dialog prior to toggling
   */
  protected doToggle(rowId: string, columnId: string) {
    let data: any = angular.extend({}, this.getDataForToggleHandler(), {
      rowId: rowId,
      columnId: columnId
    });
    this.loading = true;
    this.$http
      .post(this.state.toggleUrl, data, this.postHeadersService.postHeaders())
      .then((result: ng.IHttpPromiseCallbackArg<any>) => {
        this.processToggleResult(rowId, columnId, result);
      }).finally(() => {
      this.loading = false;
    });
  }

  /**
   * may be overriden for additional/alternative processing of the toggle result
   * e.g. open a modal window
   */
  protected processToggleResult(rowId: string, columnId: string, result: IHttpPromiseCallbackArg<any>) {
    if (result.data.rowEdges) {
      this.data.edges[rowId] = result.data.rowEdges;
    }
  }

  private loadData() {
    if (!this.state.loadDataUrl) {
      throw new Error('Cannot load data, no url provided');
    }
    this.loading = true;
    this.$http
      .post(this.state.loadDataUrl, {
        rowFilters: this.rowFilters ? JSON.stringify(this.rowFilters) : null,
        columnFilters: this.columnFilters ? JSON.stringify(this.columnFilters) : null,
        rowPage: this.rowPage,
        columnPage: this.columnPage
      }, this.postHeadersService.postHeaders())
      .then((result: ng.IHttpPromiseCallbackArg<any>) => {
        this.data = result.data;
      }).finally(() => {
      this.loading = false;
    });
  }
}

######### end - content of file "group-user-matrix/AbstractMatrixCtrl.ts" #########


######### start - content of file "group-user-matrix/CandidateGroupSearch.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.Collections;
import java.util.Set;

import javax.annotation.Nonnull;

import org.json.JSONObject;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Sets;

import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.MembershipVisibility;
import cf.cplace.platform.core.datamodel.search.filter.Filters;
import cf.cplace.platform.core.datamodel.search.filter.Operator;
import cf.cplace.platform.core.datamodel.search.Search;
import cf.cplace.platform.core.datamodel.search.filter.SearchFilter;
import cf.cplace.platform.core.server.session.SessionLocal;
import cf.cplace.platform.frontend.handler.flexigrid.FlexiComponentUtils;
import cf.cplace.platform.core.datamodel.builtin.Schema;

/**
 * Search to be utilized to find groups according to filters set in the group user matrix.
 */
public class CandidateGroupSearch {

    private JSONObject groupFilters;

    public CandidateGroupSearch() {
    }

    public CandidateGroupSearch(JSONObject groupFilters) {
        this.groupFilters = groupFilters;
    }

    /**
     * Finds groups according to filters set in the group user matrix.
     *
     * @return resulting groups stored in a set.
     */
    public Set<String> findAll() {
        Search search = getGroupSearch();
        return doWithElasticSearch(search);
    }

    /**
     * Finds groups according to filters set in the group user matrix.
     *
     * @return resulting groups stored in a {@link CandidateUsersAndGroups}.
     */
    public CandidateUsersAndGroups getCandidateGroups() {
        return new CandidateUsersAndGroups(Collections.emptySet(), findAll(), HashMultimap.create());
    }

    @Nonnull
    private Search getGroupSearch() {
        Search search = new Search();
        search.add(Filters.entityClass(Group.class));
        FlexiComponentUtils.applyColumnFilters(groupFilters, search);
        search.addAlphabeticalSort();

        // membership visibility filter
        final Set<String> accessTokens = SessionLocal.getAccessTokens();
        final Group group = Group.SCHEMA.prototype();
        final SearchFilter groupVisibleFilter = Filters.and(
                Filters.builtinAttribute(group._membershipVisibility().getName(), Operator.equals, MembershipVisibility.thisGroup.getKey()),
                Filters.or(
                        Filters.builtinAttributeIn(group._administrators().getName(), accessTokens),
                        Filters.builtinAttributeIn(group._id().getName(), accessTokens)
                )
        );

        final SearchFilter allVisible = Filters.or(
                Filters.builtinAttribute(group._membershipVisibility().getName(), Operator.equals, MembershipVisibility.allUsers.getKey()),
                Filters.builtinAttribute(group._membershipVisibility().getName(), Operator.equals, MembershipVisibility.everybody.getKey())
        );
        search.add(Filters.or(allVisible, groupVisibleFilter));
        return search;
    }

    private Set<String> doWithElasticSearch(Search search) {
        Set<String> candidateGroups = Sets.newLinkedHashSet();
        search.findAllUids().forEach(uid -> candidateGroups.add(Schema.id(uid)));
        return candidateGroups;
    }
}

######### end - content of file "group-user-matrix/CandidateGroupSearch.java" #########


######### start - content of file "group-user-matrix/CandidateUserAndGroupSearch.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.Set;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.json.JSONObject;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;

import cf.cplace.platform.core.application.principal.groupusermatrix.GroupUserMatrixFilters;

/**
 * Search to be utilized to find users, groups and group memberships of users according to filters set in the group user matrix.
 */
public class CandidateUserAndGroupSearch {

    private JSONObject userFilters;
    private JSONObject groupFilters;

    private boolean onlyUnassignedUsers;
    private boolean filterUsersByGroups;
    private boolean filterGroupsByUsers;

    public CandidateUserAndGroupSearch(GroupUserMatrixFilters groupUserMatrixFilters) {
        this(groupUserMatrixFilters._userFilters().get(),
            groupUserMatrixFilters._groupFilters().get(),
            groupUserMatrixFilters._onlyUnassignedUsers().get(),
            groupUserMatrixFilters._filterUsersByGroups().get(),
            groupUserMatrixFilters._filterGroupsByUsers().get());
    }

    public CandidateUserAndGroupSearch(@Nullable String userFilters, @Nullable String groupFilters, boolean onlyUnassignedUsers, boolean filterUsersByGroups, boolean filterGroupsByUsers) {
        if (userFilters != null) {
            this.userFilters = new JSONObject(userFilters);
        }
        if (groupFilters != null) {
            this.groupFilters = new JSONObject(groupFilters);
        }
        this.onlyUnassignedUsers = onlyUnassignedUsers;
        this.filterUsersByGroups = filterUsersByGroups;
        this.filterGroupsByUsers = filterGroupsByUsers;
    }

    /**
     * Finds users, groups and group memberships of users according to filters set in the group user matrix.
     * @return resulting users, groups and group memberships of the users stored in a {@link CandidateUsersAndGroups}.
     */
    @Nonnull
    public CandidateUsersAndGroups getUsersAndGroups() {
        Set<String> candidateUsers = Sets.newLinkedHashSet();
        Set<String> candidateGroups = Sets.newLinkedHashSet();
        SetMultimap<String, String> userMemberships = HashMultimap.create();

        CandidateUsersAndGroups candidateGroupsResult = new CandidateGroupSearch(groupFilters).getCandidateGroups();
        if (filterUsersByGroups) {
            CandidateUsersAndGroups candidateUsersResult = new CandidateUserSearch(userFilters).getCandidateUsers(candidateGroupsResult.getGroupIds(), false);
            candidateGroups = candidateGroupsResult.getGroupIds();
            candidateUsers = candidateUsersResult.getUserIds();
            userMemberships = candidateUsersResult.getUserMemberships();
        }
        if (filterGroupsByUsers) {
            CandidateUsersAndGroups candidateUsersResult = new CandidateUserSearch(userFilters).getCandidateUsers(null, false);
            if (filterUsersByGroups) {
                candidateGroups = Sets.intersection(candidateUsersResult.getGroupIds(), candidateGroupsResult.getGroupIds());
            } else {
                candidateGroups = candidateUsersResult.getGroupIds();
                candidateUsers = candidateUsersResult.getUserIds();
            }
            userMemberships = candidateUsersResult.getUserMemberships();
        }
        if (!filterUsersByGroups && !filterGroupsByUsers) {
            CandidateUsersAndGroups candidateUsersResult = new CandidateUserSearch(userFilters).getCandidateUsers(null, onlyUnassignedUsers);
            candidateGroups = candidateGroupsResult.getGroupIds();
            candidateUsers = candidateUsersResult.getUserIds();
            userMemberships = candidateUsersResult.getUserMemberships();
        }
        return new CandidateUsersAndGroups(candidateUsers, candidateGroups, userMemberships);
    }
}

######### end - content of file "group-user-matrix/CandidateUserAndGroupSearch.java" #########


######### start - content of file "group-user-matrix/CandidateUserSearch.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;

import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.datamodel.search.filter.Filters;
import cf.cplace.platform.core.datamodel.search.filter.Operator;
import cf.cplace.platform.core.datamodel.search.Search;
import cf.cplace.platform.core.datamodel.search.filter.SearchFilter;
import cf.cplace.platform.core.datamodel.search.indexing.SearchIndexFields;
import cf.cplace.platform.core.datamodel.search.result.SearchableIndex;
import cf.cplace.platform.frontend.handler.flexigrid.FlexiComponentUtils;
import cf.cplace.platform.core.datamodel.builtin.BooleanAttribute;
import cf.cplace.platform.core.datamodel.builtin.Schema;
import cf.cplace.platform.core.datamodel.search.elasticsearch.EsClient;
import cf.cplace.platform.core.datamodel.search.elasticsearch.EsClientHolder;

/**
 * Search to be utilized to find users and group memberships of users according to filters set in the group user matrix.
 */
public class CandidateUserSearch {
    private static final Logger log = LoggerFactory.getLogger(CandidateUserSearch.class);

    private final JSONObject userFilters;

    public CandidateUserSearch(JSONObject userFilters) {
        this.userFilters = userFilters;
    }

    /**
     * Finds users and users group memberships according to filters set in the group user matrix.
     *
     * @param candidateGroups     filter for users who are member in at least one of these groups.
     * @param onlyUnassignedUsers filter for users that are not member in any group.
     * @return resulting users and group memberships of the users stored in a {@link CandidateUsersAndGroups}.
     */
    public CandidateUsersAndGroups getCandidateUsers(Set<String> candidateGroups, boolean onlyUnassignedUsers) {
        Set<String> filteredGroups = Sets.newLinkedHashSet();
        Set<String> filteredUsers = Sets.newLinkedHashSet();
        SetMultimap<String, String> userMemberships = HashMultimap.create();
        Search search = new Search();
        search.add(Filters.entityClass(Person.class));
        FlexiComponentUtils.applyColumnFilters(userFilters, search);
        search.addAlphabeticalSort();

        if (candidateGroups != null && !candidateGroups.isEmpty()) {
            List<SearchFilter> filterGroups = Lists.newArrayList();
            for (String groupId : candidateGroups) {
                filterGroups.add(Filters.builtinAttribute(Person.SCHEMA.prototype()._groupMembershipIds().getName(), Operator.equals, groupId));
            }
            search.add(Filters.or(filterGroups));
        } else if (onlyUnassignedUsers) {
            search.add(Filters.builtinAttribute(Person.SCHEMA.prototype()._isMemberOfAnyGroup().getName(), Operator.equals, BooleanAttribute.EXACT_FALSE));
        }

        final String membershipIdsFieldName = SearchIndexFields.getBuiltinAttributeExactValuesFieldName(Person.SCHEMA.prototype()._groupMembershipIds().getName());
        final var searchScanConfig = new EsClient.SearchScanConfig(600_000, 1000);
        EsClientHolder.getClient().searchScan(SearchableIndex.getIndexName(), search.getElasticSearchCriterion(),
                searchScanConfig, hits -> {
                    for (final var hit : hits) {
                        String userId = Schema.id(hit.getUid());
                        final List<String> values = hit.getStringList(membershipIdsFieldName);
                        if (!values.isEmpty()) {
                            filteredUsers.add(userId);
                            final Set<String> groupIds = new HashSet<>(values);
                            groupIds.remove(userId);
                            filteredGroups.addAll(groupIds);
                            userMemberships.putAll(userId, groupIds);
                        } else {
                            log.warn("A user with id: {} does not have any memberships", userId);
                        }
                    }
                }, new String[]{ SearchIndexFields.FIELD_UID, membershipIdsFieldName }, search.getSortBuilders());

        return new CandidateUsersAndGroups(filteredUsers, filteredGroups, userMemberships);
    }
}

######### end - content of file "group-user-matrix/CandidateUserSearch.java" #########


######### start - content of file "group-user-matrix/CandidateUsersAndGroups.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.Set;

import com.google.common.collect.SetMultimap;

/**
 * Generic result object for searches (e.g.  {@link CandidateUserSearch}, {@link CandidateGroupSearch}, {@link CandidateUserAndGroupSearch}) utilized in the context of the group user matrix.
 */
public class CandidateUsersAndGroups {
    private final Set<String> userIds;
    private final Set<String> groupIds;
    private final SetMultimap<String, String> userMemberships;

    public CandidateUsersAndGroups(Set<String> userIds, Set<String> groupIds, SetMultimap<String, String> userMemberships) {
        this.userIds = userIds;
        this.groupIds = groupIds;
        this.userMemberships = userMemberships;
    }

    public Set<String> getUserIds() {
        return userIds;
    }

    public Set<String> getGroupIds() {
        return groupIds;
    }

    public SetMultimap<String, String> getUserMemberships() {
        return userMemberships;
    }
}

######### end - content of file "group-user-matrix/CandidateUsersAndGroups.java" #########


######### start - content of file "group-user-matrix/FilterGroupsSpecificationHandler.java" #########
/*
 * Copyright 2016, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.Collections;
import java.util.List;

import cf.cplace.platform.core.application.authorization.GlobalPermissions;
import cf.cplace.platform.core.datamodel.custom.TypeDefinition;
import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.PersonSpace;
import cf.cplace.platform.core.datamodel.search.filter.Filters;
import cf.cplace.platform.core.datamodel.search.Search;
import cf.cplace.platform.core.frontend.handler.Forwarder;
import cf.cplace.platform.core.frontend.handler.TableSpecificationHandler;
import cf.cplace.platform.frontend.handler.group.NewHandler;

/**
 * Represents the filter dialog on the group dimension in the user and group matrix.
 * <p>
 * See {@link FilterUsersSpecificationHandler} for the filter dialog on the user dimension.
 */
public class FilterGroupsSpecificationHandler extends TableSpecificationHandler {

    protected void buildSearch() {
        search = new Search();
        search.add(Filters.space(PersonSpace.getPersonSpace()));
        TypeDefinition groupTypeDefinition = Group.getGroupTypeDefinition();
        search.add(Filters.type(groupTypeDefinition));
    }

    @Override
    public boolean showActions() {
        return GlobalPermissions.mayEditAllTypes();
    }

    public FilterGroupsSpecificationHandler() {
        buildSearch();
    }

    @Override
    public String getEditNewUrl() {
        return Forwarder.getFullUrl(NewHandler.class);
    }

    @Override
    public boolean isAllowedToCreateNewPage() {
        return true;
    }

    @Override
    public void checkAccess() {
        columnNamesToBeDisplayed.addAll(getDefaultColumnNamesIfNoUserConfig());
        availableColumnNames.addAll(search.getCustomAttributeNames());
        availableColumnNames.addAll(search.getAvailableBuiltinAttributeNamesWithoutDummyAttributes());
    }

    @Override
    public String getFullUrl() {
        return Forwarder.getFullUrl(FilterGroupsSpecificationHandler.class);
    }

    @Override
    protected List<String> getDefaultColumnNamesIfNoUserConfig() {
        return Collections.emptyList();
    }
}

######### end - content of file "group-user-matrix/FilterGroupsSpecificationHandler.java" #########


######### start - content of file "group-user-matrix/FilterUsersSpecificationHandler.java" #########
/*
 * Copyright 2016, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.Collections;
import java.util.List;

import javax.annotation.Nullable;

import cf.cplace.platform.commonlib.apiannotation.CplaceApi;
import cf.cplace.platform.core.application.authorization.GlobalPermissions;
import cf.cplace.platform.core.datamodel.custom.TypeDefinition;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.application.principal.PersonSpace;
import cf.cplace.platform.core.datamodel.search.filter.Filters;
import cf.cplace.platform.core.datamodel.search.Search;
import cf.cplace.platform.core.frontend.handler.Forwarder;
import cf.cplace.platform.core.frontend.handler.TableSpecificationHandler;
import cf.cplace.platform.frontend.handler.page.AbstractActionHandler;
import cf.cplace.platform.frontend.handler.systemGroup.UsersActionsHandler;

/**
 * Represents the filter dialog on the user dimension in the user and group matrix.
 * <p>
 * See {@link FilterGroupsSpecificationHandler} for the filter dialog on the group dimension.
 */
@CplaceApi
public class FilterUsersSpecificationHandler extends TableSpecificationHandler {

    protected void buildSearch() {
        search = new Search();
        search.add(Filters.space(PersonSpace.getPersonSpace()));
        TypeDefinition userTypeDefinition = Person.getUserTypeDefinition();
        search.add(Filters.type(userTypeDefinition));
    }

    @Override
    public boolean showActions() {
        return GlobalPermissions.mayEditAllTypes();
    }

    @Nullable
    @Override
    public Class<? extends AbstractActionHandler> getActionsHandlerIfShown() {
        return UsersActionsHandler.class;
    }

    public FilterUsersSpecificationHandler() {
        buildSearch();
    }

    @Override
    public void checkAccess() {
        columnNamesToBeDisplayed.addAll(getDefaultColumnNamesIfNoUserConfig());
        availableColumnNames.addAll(search.getCustomAttributeNames());
        availableColumnNames.addAll(search.getAvailableBuiltinAttributeNamesWithoutDummyAttributes());
    }

    @Override
    public String getFullUrl() {
        return Forwarder.getFullUrl(FilterUsersSpecificationHandler.class);
    }

    @Override
    protected List<String> getDefaultColumnNamesIfNoUserConfig() {
        return Collections.emptyList();
    }
}

######### end - content of file "group-user-matrix/FilterUsersSpecificationHandler.java" #########


######### start - content of file "group-user-matrix/GroupUserMatrixCtrl.ts" #########
import { IAngularEvent, IAugmentedJQuery, IHttpService, IScope } from 'angular';
import { EVENT_RESIZE_FIXED_PANE_SCROLL_CONTAINERS } from '../../directives/cplaceFixedPaneScroll';
import { PostHeadersService } from '../../services/PostHeadersService';
import { ColumnFiltersDialogCtrl, IFiltersDialogSavedEventData } from '../../flexigrid/controllers/ColumnFiltersDialogCtrl';

export interface IGroupUserMatrixState {
    toggleMembershipUrl: string;
    filterUsersDialogUrl: string;
    filterGroupsDialogUrl: string;
    loadDataUrl: string;
    exportDataUrl: string;
    mayExportGroupMemberships: boolean;
    userFiltersEnabled: boolean;
    data: IData;
}

export interface IData {
    excessiveData: boolean;
    excessiveDataUsers: boolean;
    excessiveDataGroups: boolean;
    userId2groupId2edge: {
        [userId: string]: {
            [groupId: string]: IEdge;
        };
    };
    users: Array<INode>;
    groups: Array<INode>;
    userPage: number;
    groupPage: number;
}

export interface IEdge {
    userId: string;
    groupId: string;
    directMembership: boolean;
    iconClass: string;
    tooltip: string;
}

export interface INode {
    id: string;
    name: string;
    url: string;
}

export class GroupUserMatrixCtrl {
    static CTRL_NAME = 'cf.cplace.platform.controllers.GroupUserMatrixCtrl';
    afterRenderEvent = EVENT_RESIZE_FIXED_PANE_SCROLL_CONTAINERS;
    state: IGroupUserMatrixState;
    onlyUnassignedUsers = false;
    private userFilters: Object;
    private groupFilters: Object;
    private filterForUsers = false;
    private filterUsersByGroups = false;
    private filterGroupsByUsers = false;
    private userPage: number;
    private groupPage: number;

    constructor(private $scope: IScope, $element: IAugmentedJQuery, private $http: IHttpService, private postHeadersService: PostHeadersService) {
        $scope.$on(ColumnFiltersDialogCtrl.EVENT_SAVED, (e: IAngularEvent, data: IFiltersDialogSavedEventData) => {
            e.stopPropagation();
            if (this.filterForUsers) {
                this.userFilters = data.filters;
            }
            else {
                this.groupFilters = data.filters;
            }
            this.reloadData();
        });
        $scope.$on(ColumnFiltersDialogCtrl.EVENT_RESTORE, (e: IAngularEvent) => {
            e.stopPropagation();
            if (this.filterForUsers) {
                this.userFilters = null;
            }
            else {
                this.groupFilters = null;
            }
            this.reloadData();
        });
        $element.on('mouseenter', '.matrix-data tr', function() {
            const index = jQuery(this).index();
            $element.find('.row-headers tr').eq(index).addClass('hovered');
        });
        $element.on('mouseleave', '.matrix-data tr', function() {
            const index = jQuery(this).index();
            $element.find('.row-headers tr').eq(index).removeClass('hovered');
        });
        $element.on('mouseenter', '.matrix-data td.edge-container', function() {
            const index = jQuery(this).index();
            $element.find('.column-headers th').eq(index).addClass('hovered');
        });
        $element.on('mouseleave', '.matrix-data td.edge-container', function() {
            const index = jQuery(this).index();
            $element.find('.column-headers th').eq(index).removeClass('hovered');
        });
    }

    initialize(matrix: IGroupUserMatrixState) {
        this.state = matrix;
        this.reloadData();
    }

    hasUserFilters() {
        return this.state.userFiltersEnabled && this.userFilters && !!Object.keys(this.userFilters).length;
    }

    hasGroupFilters() {
        return this.groupFilters && !!Object.keys(this.groupFilters).length;
    }

    filterUsers() {
        this.filterForUsers = true;
        presentURLinModal(this.state.filterUsersDialogUrl, {
            data: {
                filters: this.userFilters ? JSON.stringify(this.userFilters) : null
            },
            isLarge: true,
            angularScope: this.$scope
        });
    }

    filterGroups() {
        this.filterForUsers = false;
        presentURLinModal(this.state.filterGroupsDialogUrl, {
            data: {
                filters: this.groupFilters ? JSON.stringify(this.groupFilters) : null
            },
            isLarge: true,
            angularScope: this.$scope
        });
    }

    toggleOnlyUnassignedUsers() {
        this.onlyUnassignedUsers = !this.onlyUnassignedUsers;
        this.reloadData();
    }

    filterUsersForSelectedGroups() {
        this.userPage = 1;
        this.filterUsersByGroups = !this.filterUsersByGroups;
        this.onlyUnassignedUsers = false;
        this.reloadData();
    }

    filterGroupsForSelectedUsers() {
        this.groupPage = 1;
        this.filterGroupsByUsers = !this.filterGroupsByUsers;
        this.reloadData();
    }

    loadMore(type: string) {
        if (type == 'user') {
            this.userPage = this.state.data.userPage + 1;
        }
        if (type == 'group') {
            this.groupPage = this.state.data.groupPage + 1;
        }
        this.reloadData();
    }

    getEdge(user, group) {
        let edges = this.state.data.userId2groupId2edge[user.id];
        if (edges) {
            return edges[group.id];
        }
        else {
            return null;
        }
    }

    toggleEdge(user, group) {
        this.$http
            .post(this.state.toggleMembershipUrl, {
                userId: user.id,
                groupId: group.id
            }, this.postHeadersService.postHeaders())
            .then((result: any) => {
                const data = result.data;
                if (data.success) {
                    this.state.data.userId2groupId2edge[user.id] = data.groupId2edge;
                }
                else if (data.errorMessage) {
                    jQuery.bootstrapGrowl(data.errorMessage, {
                        ele: 'body',
                        type: 'danger',
                        delay: 4000,
                        allow_dismiss: true,
                        stackup_spacing: 10 // spacing between consecutively stacked growls.
                    });
                }
            });
    }

    canBeToggledClass(user, group) {
        var edge = this.getEdge(user, group);
        if ((edge && edge.directMembership) || edge == null) {
            return 'cell-edge-can-be-toggled';
        }
        else {
            return '';
        }
    }

    private reloadData() {
        this.state.data = null;
        this.$http
            .post(this.state.loadDataUrl, {
                userFilters: this.userFilters ? JSON.stringify(this.userFilters) : null,
                groupFilters: this.groupFilters ? JSON.stringify(this.groupFilters) : null,
                onlyUnassignedUsers: this.onlyUnassignedUsers,
                filterUsersByGroups: this.filterUsersByGroups,
                filterGroupsByUsers: this.filterGroupsByUsers,
                groupPage: this.groupPage,
                userPage: this.userPage
            }, this.postHeadersService.postHeaders())
            .then((result: any) => {
                this.state.data = result.data;
            });
    }

    exportData() {
        presentURLinModal(this.state.exportDataUrl, {
            data: {
                userFilters: this.userFilters ? JSON.stringify(this.userFilters) : null,
                groupFilters: this.groupFilters ? JSON.stringify(this.groupFilters) : null,
                onlyUnassignedUsers: this.onlyUnassignedUsers,
                filterUsersByGroups: this.filterUsersByGroups,
                filterGroupsByUsers: this.filterGroupsByUsers,
                groupPage: this.groupPage,
                userPage: this.userPage,
                mayExportGroupMemberships: this.state.mayExportGroupMemberships
            },
            angularScope: this.$scope
        });
    }

    /**
     * Checks whether the export group memberships button should be shown in the group user matrix.
     * @returns {boolean} true if the export group memberships button in the matrix should be shown.
     */
    showExportMembershipsButton(): boolean {
        return this.state.mayExportGroupMemberships &&
        (this.hasUserFilters() || this.hasGroupFilters() || this.onlyUnassignedUsers || this.filterUsersByGroups || this.filterGroupsByUsers);
    }
}

######### end - content of file "group-user-matrix/GroupUserMatrixCtrl.ts" #########


######### start - content of file "group-user-matrix/LoadDataHandler.java" #########
/*
 * Copyright 2016, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Sets;

import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.application.principal.groupusermatrix.GroupUserMatrixFilters;
import cf.cplace.platform.core.server.request.Parameters;
import cf.cplace.platform.core.frontend.handler.station.json.GsonAnswerStation;
import cf.cplace.platform.core.frontend.handler.Handler;
import cf.cplace.platform.core.frontend.handler.PostOnlyHandler;
import cf.cplace.platform.core.frontend.handler.station.Station;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state.Data;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state.Edge;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state.Node;

public class LoadDataHandler extends Handler implements PostOnlyHandler {
    public static final int PAGE_SIZE = 50;
    private static final Pattern WHITESPACE = Pattern.compile("\\s");

    final Station DATA = new GsonAnswerStation() {
        @Override
        protected String getString() {
            return data.toJson();
        }
    };
    private Data data;

    private int groupPage;
    private int userPage;
    public int maxUsers;
    public int maxGroups;
    protected GroupUserMatrixFilters groupUserMatrixFilters;

    @Override
    public final void checkAccess() {
        groupPage = Parameters.getInt("groupPage", 1);
        userPage = Parameters.getInt("userPage", 1);

        maxUsers = PAGE_SIZE * userPage;
        maxGroups = PAGE_SIZE * groupPage;

        setupMatrixFilters();
        additionalCheckAccess();
    }

    protected void additionalCheckAccess() {
    }

    private void setupMatrixFilters() {
        groupUserMatrixFilters = GroupUserMatrixFilters.SCHEMA.createRegisteredSessionEntity();

        groupUserMatrixFilters._userFilters().set(Parameters.getString("userFilters", ""));
        groupUserMatrixFilters._groupFilters().set(Parameters.getString("groupFilters", ""));
        groupUserMatrixFilters._onlyUnassignedUsers().set(Parameters.getBoolean("onlyUnassignedUsers", false));
        groupUserMatrixFilters._filterGroupsByUsers().set(Parameters.getBoolean("filterGroupsByUsers", false));
        groupUserMatrixFilters._filterUsersByGroups().set(Parameters.getBoolean("filterUsersByGroups", false));
    }

    @Override
    protected Station doBusinessLogic() {
        CandidateUsersAndGroups usersAndGroups = new CandidateUserAndGroupSearch(groupUserMatrixFilters).getUsersAndGroups();

        Iterable<Group> groups = Group.SCHEMA.getEntitiesById(usersAndGroups.getGroupIds(), false);
        Iterable<Person> persons = Person.SCHEMA.getEntitiesById(usersAndGroups.getUserIds(), false);
        data = createData(persons, usersAndGroups.getUserIds().size(), groups, usersAndGroups.getGroupIds().size(), usersAndGroups.getUserMemberships(), maxUsers, maxGroups);
        data.groupPage = groupPage;
        data.userPage = userPage;
        return DATA;
    }

    public static Data createData(Iterable<Person> users, int totalUserCount, Iterable<Group> groups, int totalGroupCount, SetMultimap<String, String> userMemberships, int maxUsers, int maxGroups) {
        final Data data = new Data();
        List<Person> selectedPersons = Lists.newArrayList();
        List<Group> selectedGroups = Lists.newArrayList();
        selectDataAndGroups(users, totalUserCount, groups, totalGroupCount, data, selectedPersons, selectedGroups, maxUsers, maxGroups);

        if (totalGroupCount == 0 || totalUserCount == 0) {
            return data;
        }

        for (Person user : selectedPersons) {
            final Set<String> userGroups = userMemberships.get(user.getId());
            for (Group group : selectedGroups) {
                Edge edge = getEdge(group, user, userGroups);
                String userId = user.getId();
                Map<String, Edge> groupId2edge = data.userId2groupId2edge.computeIfAbsent(userId, k -> Maps.newHashMap());
                groupId2edge.put(group.getId(), edge);
            }
        }
        return data;
    }

    private static void selectDataAndGroups(Iterable<Person> users, int totalUserCount, Iterable<Group> groups, int totalGroupCount, Data data,
                                            List<Person> selectedPersons, List<Group> selectedGroups, int maxUsers, int maxGroups) {
        data.numberOfFilteredUsers = totalUserCount;
        data.numberOfFilteredGroups = totalGroupCount;
        int userCount = 0;
        for (Person person : users) {
            if (userCount == maxUsers) {
                data.excessiveData = true;
                data.excessiveDataUsers = true;
                break;
            }
            data.users.add(new Node(person));
            selectedPersons.add(person);
            userCount++;
        }

        int groupCount = 0;
        for (Group group : groups) {
            if (groupCount == maxGroups) {
                data.excessiveData = true;
                data.excessiveDataGroups = true;
                break;
            }
            data.groups.add(new Node(group));
            selectedGroups.add(group);
            groupCount++;
        }
    }

    public static Edge getEdge(Group group, Person user, Set<String> userGroups) {
        boolean isGroupAdmin = false;
        if (group.isAdministratorOfThisGroup(user)) {
            isGroupAdmin = true;
        }
        if (group.isActiveMemberInThisGroup(user)) {
            return Edge.createDirectMembershipEdge(user, group, isGroupAdmin);
        } else {
            if (userGroups.contains(group.getId())) {
                Iterable<Group.MemberInGroup> allActivePersonsAndInWhichGroupTheyAreMember;
                allActivePersonsAndInWhichGroupTheyAreMember = group.getAllActivePersonsAndInWhichGroupTheyAreMember();
                for (Group.MemberInGroup memberInGroup : allActivePersonsAndInWhichGroupTheyAreMember) {
                    if (Objects.equals(memberInGroup.member, user)) {
                        return Edge.createInheritedMembershipEdge(user, memberInGroup.group, group, isGroupAdmin);
                    }
                }
            }
        }

        if (isGroupAdmin) {
            return Edge.createIsAdminEdge(user, group);
        }
        return null;
    }

    public static Map<String, Edge> getGroupId2Edge(Person user) {
        Map<String, Edge> groupId2edge = Maps.newHashMap();
        final String idsString = user._groupMembershipIds().get();
        if (idsString == null) {
            return groupId2edge;
        }
        Set<String> userGroups = Sets.newHashSet(WHITESPACE.split(idsString));
        userGroups.remove(user.getId());
        for (Group group : Group.SCHEMA.getEntities()) {
            Edge edge = getEdge(group, user, userGroups);
            if (edge != null) {
                groupId2edge.put(group.getId(), edge);
            }
        }
        return groupId2edge;
    }
}

######### end - content of file "group-user-matrix/LoadDataHandler.java" #########


######### start - content of file "group-user-matrix/ToggleMembershipHandler.java" #########
package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.Map;

import com.google.common.collect.Maps;

import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.Membership;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.server.request.Parameters;
import cf.cplace.platform.core.frontend.handler.station.json.GsonAnswerStation;
import cf.cplace.platform.core.frontend.handler.Handler;
import cf.cplace.platform.core.frontend.handler.PostOnlyHandler;
import cf.cplace.platform.core.frontend.handler.station.Station;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state.Edge;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.commonlib.util.io.gson.GsonUtil;

public class ToggleMembershipHandler extends Handler implements PostOnlyHandler {

    final Station SUCCESS = new GsonAnswerStation() {
        @Override
        protected String getString() {
            return result.toJson();
        }
    };

    Result result = new Result();

    Group group;

    Person user;

    private static final Message notAllowed = new Message() {
    };

    @Override
    public void checkAccess() {
        group = Group.SCHEMA.getEntityNotNull(Parameters.getString("groupId"));
        user = Person.SCHEMA.getEntityNotNull(Parameters.getString("userId"));
    }

    @Override
    public Station doBusinessLogic() {
        if (group.getEntityPermissions().mayEdit()) {
                Membership membership = Membership.getMembership(group, user);
                if (membership == null) {
                    Person.createMembership(user, group, null);
                    result.groupId2edge = LoadDataHandler.getGroupId2Edge(user);
                    result.success = true;
                } else {
                    if (membership.canBeDeleted() == null) {
                        membership.remove();
                        result.groupId2edge = LoadDataHandler.getGroupId2Edge(user);
                        result.success = true;
                    } else {
                        result.errorMessage = notAllowed.get();
                    }
                }
        } else {
            result.errorMessage = notAllowed.get();
        }
        return SUCCESS;
    }

    public static class Result {

        public String toJson() {
            return GsonUtil.getGsonWithModifiedDateSerializer().toJson(this, this.getClass());
        }

        boolean success = false;

        Map<String, Edge> groupId2edge = Maps.newHashMap();

        String errorMessage;
    }
}

######### end - content of file "group-user-matrix/ToggleMembershipHandler.java" #########


######### start - content of file "group-user-matrix/UserExcelSheetDefinition.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.Arrays;
import java.util.function.Function;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;

import cf.cplace.platform.commonlib.apiannotation.CplaceInternal;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.exporting.Export2ExcelJob;

/**
 * Allows to configure the excel to be created by the {@link Export2ExcelJob}
 * and provides utility functions for the creation of the excel.
 */
public class UserExcelSheetDefinition {

    public static final Message nameLabel = new Message() {
    };
    @VisibleForTesting
    @CplaceInternal
    public static final Message ldapLabel = new Message() {
    };
    @VisibleForTesting
    @CplaceInternal
    public static final Message emailLabel = new Message() {
    };

    enum UserExcelSheetColumn {
        NAME(0, nameLabel, p -> Strings.nullToEmpty(p._name().get())),
        LDAP(1, ldapLabel, p -> Strings.nullToEmpty(p._externalId().get())),
        EMAIL(2, emailLabel, p -> Strings.nullToEmpty(p._login().get()));

        public final int index;
        public final Message label;
        public final Function<Person, String> informationMapper;

        UserExcelSheetColumn(int index, Message label, Function<Person, String> informationMapper) {
            this.index = index;
            this.label = label;
            this.informationMapper = informationMapper;
        }
    }

    /**
     * Sets the width of all columns containing information about a user e.g. name, LDAP and email (excluding columns that contain group membership information).
     * @param sheet the sheet in the excel that contains the respective user information columns.
     */
    public void setUserInfoColumnWidth(Sheet sheet) {
        Arrays.stream(UserExcelSheetColumn.values())
                .forEach(column -> sheet.setColumnWidth(column.index, 10000));
    }

    /**
     * Creates the header cells of all columns containing information about a user e.g. name, LDAP and email (excluding columns that contain group membership information).
     * @param row the row to contain the header cells.
     * @param cellStyle the style of the header cells.
     */
    public void createHeaderCells(Row row, CellStyle cellStyle) {
        Arrays.stream(UserExcelSheetColumn.values())
            .forEach(column -> createHeaderCellFor(row, cellStyle, column));
    }

    /**
     * For a given user creates the cells in all columns containing information about the user e.g. name, LDAP and email (excluding columns that contain group membership information).
     * @param row the row to contain the user information cells.
     * @param cellStyle the style of the user information cells.
     * @param person the user for which the user information cells shall be created.
     */
    public void createUserCells(Row row, CellStyle cellStyle, Person person) {
        Arrays.stream(UserExcelSheetColumn.values())
            .forEach(column -> createUserCellFor(row, cellStyle, person, column));
    }

    /**
     * Returns the index of the last column that contains information about the user e.g. name, LDAP and email.
     * @return the index of the last column that contains information about the user.
     */
    public int getLastColumnIndex(){
        return UserExcelSheetColumn.values()[UserExcelSheetColumn.values().length - 1].index;
    }

    private void createHeaderCellFor(Row row, CellStyle cellStyle, UserExcelSheetColumn column) {
        final Cell userNameCell = row.createCell(column.index);
        userNameCell.setCellStyle(cellStyle);
        userNameCell.setCellValue(column.label.get());
    }

    private void createUserCellFor(Row row, CellStyle cellStyle, Person person, UserExcelSheetColumn column) {
        final Cell userNameCell = row.createCell(column.index);
        userNameCell.setCellStyle(cellStyle);
        userNameCell.setCellValue(column.informationMapper.apply(person));
    }
}

######### end - content of file "group-user-matrix/UserExcelSheetDefinition.java" #########


######### start - content of file "group-user-matrix/ViewHandler.java" #########
package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix;

import java.util.List;
import java.util.Set;

import javax.annotation.Nullable;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.gson.Gson;

import cf.cplace.platform.commonlib.apiannotation.CplaceApi;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.server.request.Parameters;
import cf.cplace.platform.core.frontend.handler.Forwarder;
import cf.cplace.platform.core.frontend.handler.FullPageHandler;
import cf.cplace.platform.core.frontend.handler.Handler;
import cf.cplace.platform.core.frontend.handler.HistoryEntryNameProvider;
import cf.cplace.platform.core.frontend.handler.station.template.MainPage;
import cf.cplace.platform.core.frontend.handler.station.Station;
import cf.cplace.platform.core.frontend.handler.navigation.TargetProvider;
import cf.cplace.platform.core.frontend.handler.TitleAndHeadingProvider;
import cf.cplace.platform.frontend.handler.group.overview.DefaultActionsAndViews;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state.State;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.commonlib.internationalization.ParameterizedMessage;
import cf.cplace.platform.commonlib.util.text.Escaping;
import cf.cplace.platform.commonlib.template.PrintSubstitution;
import cf.cplace.platform.commonlib.template.Template;
import cf.cplace.platform.commonlib.util.io.gson.GsonUtil;

@CplaceApi
public class ViewHandler extends Handler implements FullPageHandler, TitleAndHeadingProvider, HistoryEntryNameProvider {

    private static final ParameterizedMessage htmlUnsafe_filtered = new ParameterizedMessage() {
    };

    final Station SHOW = new MainPage() {
        @Override
        public TargetProvider getViewsProvider() {
            return new DefaultActionsAndViews();
        }

        @Override
        public TargetProvider getActionsProvider() {
            return new DefaultActionsAndViews();
        }

        @Override
        protected void putContentBodySubstitutions(Template template) {
            template.put("state", PrintSubstitution.printing(Escaping.htmlAttribute, () -> {
                State state = new State();
                return state.toJson();
            }));
            template.put("filteredMessage", PrintSubstitution.printingMessageHtml(() -> {
                if (usersToBeFiltered.size() > 0) {
                    return htmlUnsafe_filtered.setParameters(Forwarder.getFullUrl(ViewHandler.class));
                } else {
                    return null;
                }
            }));
        }
    };

    public static final Message title = new Message() {
    };

    Set<Person> usersToBeFiltered = Sets.newHashSet();

    @Override
    public void checkAccess() {
        checkLoggedIn();
    }

    @Override
    public Station doBusinessLogic() {
        String userIdsJson = Parameters.getString("userIds");
        if (!Strings.isNullOrEmpty(userIdsJson)) {
            UserIds userIds = new Gson().fromJson(Preconditions.checkNotNull(userIdsJson, "json"), UserIds.class);
            for (String userId : userIds.userIds) {
                Person user = Person.SCHEMA.getEntity(userId);
                if (user != null) {
                    usersToBeFiltered.add(user);
                }
            }
        }
        return SHOW;
    }

    @Override
    public Message getHistoryEntryName() {
        return title;
    }

    @Override
    public Message getTargetLabel() {
        return title;
    }

    @Override
    public Message getTitleAndHeading() {
        return DefaultActionsAndViews.overviewTitle;
    }

    @CplaceApi
    public static class UserIds {

        public String toJson() {
            return GsonUtil.getGsonWithModifiedDateSerializer().toJson(this, this.getClass());
        }

        public List<String> userIds = Lists.newArrayList();
    }

    @Nullable
    @Override
    public String getActionIconName() {
        return "fa-check-square-o";
    }
}

######### end - content of file "group-user-matrix/ViewHandler.java" #########


######### start - content of file "group-user-matrix/cplaceGroupUserMatrix.ts" #########
import { IAugmentedJQuery, IDirective, IScope } from 'angular';
import { GroupUserMatrixCtrl, IGroupUserMatrixState } from '../../controllers/groupUserMatrix/GroupUserMatrixCtrl';

export const CPLACE_GROUP_USER_MATRIX = 'cplaceGroupUserMatrix';

export function cplaceGroupUserMatrix(): IDirective {
    return {
        restrict: 'A',
        require: CPLACE_GROUP_USER_MATRIX,
        controller: GroupUserMatrixCtrl.CTRL_NAME,
        controllerAs: 'matrixCtrl',
        compile: () => {
            return {
                pre: (scope: IScope, element: IAugmentedJQuery, attrs: any, ctrl: GroupUserMatrixCtrl) => {
                    const state: IGroupUserMatrixState = JSON.parse(attrs[CPLACE_GROUP_USER_MATRIX]);
                    ctrl.initialize(state);
                }
            };
        }
    };
}

######### end - content of file "group-user-matrix/cplaceGroupUserMatrix.ts" #########


######### start - content of file "group-user-matrix/cplaceMatrix.ts" #########
import { IDirective } from 'angular';
import { AbstractMatrixCtrl } from './AbstractMatrixCtrl';
import * as _ from 'underscore';

/**
 * "name" property allows us to bind a dynamic controller. Generally when angular creates a controller instance it is named after directive,
 * since we change the name explicitly, internally, name of the controller becomes the value of "name" property in this case "theMatrix".
 * When requiring this directive(controller) in sibling/child directives this directive will be referred using the value of name property.
 *
 */
export function cplaceMatrix(): IDirective {
    return {
        restrict: 'E',
        templateUrl: '/cf.cplace.platform.matrix/matrix',
        name: 'theMatrix',
        controller: '@',
        controllerAs: 'matrixCtrl',
        transclude: true,
        priority: 1500,
        bindToController: true,
        link: ($scope, $element, $attrs, $ctrl: AbstractMatrixCtrl) => {
            $ctrl.initialize(JSON.parse($attrs.state));
        }
    };
}

export function cplaceMatrixInfo(): IDirective {
    return {
        require: '^theMatrix',
        restrict: 'A',
        link: (scope, element, attrs, matrixCtrl: AbstractMatrixCtrl) => {
            const throttledResizeHandler = _.throttle(() => {
                infoWidthChangeHandler(infoElm.children().width());
            }, 100);
            let infoElm = element.find('.cf-cplace-matrix-info');
            const detachRowWidthChangeHandler: Function = matrixCtrl.addRowWidthChangeHandler(rowsWidthChangeHandler);
            let infoWidth: number = infoElm.children().width(), rowsWidth: number = 0;
            infoElm.children().resize(throttledResizeHandler);
            scope.$on('$destroy', () => {
                infoElm.children().off('resize', throttledResizeHandler);
                detachRowWidthChangeHandler();
            });

            function updateWidthIfNecessary(newVal: number, oldVal: number) {
                if (newVal > oldVal) {
                    infoElm.css('width', newVal);
                }
            }

            function infoWidthChangeHandler(width: number): void {
                infoWidth = width;
                updateWidthIfNecessary(infoWidth, rowsWidth);
            }

            function rowsWidthChangeHandler(width: number) {
                rowsWidth = width;
                updateWidthIfNecessary(rowsWidth, infoWidth);
            }
        }
    };
}

export function cplaceMatrixRows(): IDirective {
    return {
        require: '^theMatrix',
        restrict: 'A'
    };
}

export function cplaceMatrixColumns(): IDirective {
    return {
        require: '^theMatrix',
        restrict: 'A'
    };
}

export function cplaceMatrixGrid() {
    return {
        require: '^theMatrix',
        restrict: 'A',
        link: (scope, element, attrs, ctrl: AbstractMatrixCtrl) => {
            const gridTableElm = element.find('.cf-cplace-matrix-data');
            const busyIndicator = element.find('.busy-indicator');
            gridTableElm.on('click', 'td', handleMatrixGridClick);
            gridTableElm.on('mouseenter', 'td', function() {
                const colIndex = jQuery(this).index();
                const rowIndex = angular.element(this).parent().index();
                ctrl.highlightRowColumn(rowIndex, colIndex);
            });
            gridTableElm.on('mouseleave', 'td', function() {
                const colIndex = jQuery(this).index();
                const rowIndex = angular.element(this).parent().index();
                ctrl.unhighlightRowColumn(rowIndex, colIndex);
            });

            function handleMatrixGridClick(event) {
                const cell = angular.element(event.currentTarget);
                const rowId = cell.attr('row-id');
                const columnId = cell.attr('column-id');
                ctrl.toggleEdge(rowId, columnId);
            }

            scope.$watch(() => {
                return ctrl.loading;
            }, (newVal, oldVal) => {
                let width = !!gridTableElm.width() ? gridTableElm.width() : '200px';
                let height = !!gridTableElm.height() ? gridTableElm.height() : '200px';
                busyIndicator.css({
                    width: width,
                    height: height,
                    left: gridTableElm.position().left,
                    top: gridTableElm.position().top
                });
            });
            scope.$on('$destroy', () => {
                gridTableElm.off('click', handleMatrixGridClick);
            });
        }
    };
}

######### end - content of file "group-user-matrix/cplaceMatrix.ts" #########


######### start - content of file "group-user-matrix/exporting/Export2ExcelHandler.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */
package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.exporting;

import cf.cplace.platform.core.application.authorization.GlobalPermissions;
import cf.cplace.platform.core.server.request.Parameters;
import cf.cplace.platform.core.server.session.SessionLocal;
import cf.cplace.platform.commonlib.template.Template;
import cf.cplace.platform.core.frontend.handler.Forwarder;
import cf.cplace.platform.core.frontend.handler.Handler;
import cf.cplace.platform.core.frontend.handler.station.template.JsonPage;
import cf.cplace.platform.core.frontend.handler.PostOnlyHandler;
import cf.cplace.platform.core.frontend.handler.station.Station;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.core.frontend.handler.ProtectedActionException;
import cf.cplace.platform.commonlib.util.text.Escaping;
import cf.cplace.platform.commonlib.template.PrintSubstitution;
import cf.cplace.platform.commonlib.util.NameValue;

/**
 * Entry point for the export of group memberships. Shows the user a modal that allows a user to only export memberships in groups in which the user is admin.
 * Subsequently forwards to the {@link SubmitExportHandler}.
 */
public class Export2ExcelHandler extends Handler implements PostOnlyHandler {

    private static final Message label = new Message() {
    };

    private static final Message notAllowedToExport = new Message() {
    };

    final Station SHOW = new JsonPage() {
        @Override
        public void putSubstitutions(Template template) {
            template.put("submitUrl", PrintSubstitution.printing(Escaping.htmlAttribute, () -> Forwarder.getFullUrl(
                SubmitExportHandler.class,
                NameValue.fromInt("groupPage", Parameters.getInt("groupPage", 1)),
                NameValue.fromInt("userPage", Parameters.getInt("userPage", 1)),
                NameValue.fromBoolean("onlyUnassignedUsers", Parameters.getBoolean("onlyUnassignedUsers", false)),
                NameValue.fromBoolean("filterGroupsByUsers", Parameters.getBoolean("filterGroupsByUsers", false)),
                NameValue.fromBoolean("filterUsersByGroups", Parameters.getBoolean("filterUsersByGroups", false)),
                NameValue.fromParameter("mayExportGroupMemberships")
            )));
            template.put("userFilters", PrintSubstitution.printing(Escaping.htmlAttribute, () -> NameValue.fromParameter("userFilters").getValue()));
            template.put("groupFilters", PrintSubstitution.printing(Escaping.htmlAttribute, () -> NameValue.fromParameter("groupFilters").getValue()));
        }
    };

    @Override
    public void checkAccess() {
        SessionLocal.checkLoggedIn();
        if (!GlobalPermissions.mayExportGroupMemberships()) {
            throw new ProtectedActionException(notAllowedToExport.get());
        }
    }

    @Override
    public Station doBusinessLogic() {
        return SHOW;
    }

    @Override
    public String getActionIconName() {
        return "fa-download";
    }

    @Override
    public Message getTargetLabel() {
        return label;
    }
}

######### end - content of file "group-user-matrix/exporting/Export2ExcelHandler.java" #########


######### start - content of file "group-user-matrix/exporting/Export2ExcelJob.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.exporting;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.VerticalAlignment;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbookType;

import com.google.common.collect.Streams;

import cf.cplace.platform.core.application.job.assets.PersistentJob;
import cf.cplace.platform.core.application.job.QueuedBatchJob;
import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.server.session.SessionLocal;
import cf.cplace.platform.frontend.handler.custom.DownloadExportHelper;
import cf.cplace.platform.frontend.handler.excel.ExcelExporter;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.UserExcelSheetDefinition;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.CandidateUserAndGroupSearch;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.CandidateUsersAndGroups;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.core.datamodel.builtin.PersistentEntity;
import cf.cplace.platform.core.server.TenantResources;
import cf.cplace.platform.core.application.job.data.DistributionType;
import cf.cplace.platform.commonlib.template.Template;
import cf.cplace.platform.commonlib.util.io.gson.GsonUtil;
import cf.cplace.platform.commonlib.util.io.gson.Gsonable;
import cf.cplace.platform.commonlib.util.Utilities;

/**
 * Exports direct memberships of the group user matrix to an excel file.
 * The excel can be configured via {@link UserExcelSheetDefinition}.
 */
public class Export2ExcelJob extends QueuedBatchJob {

    private static final Message jobName = new Message() {
    };
    static final Message groupMembershipsTabName = new Message() {
    };
    private static final Message excelFileName = new Message() {
    };

    final UserExcelSheetDefinition userExcelSheetDefinition = new UserExcelSheetDefinition();

    @Nonnull
    @Override
    public DistributionType getDistributionType(@Nullable String parameter) {
        return DistributionType.DISTRIBUTED;
    }

    @Nullable
    @Override
    protected Message getJobName(String parameter) {
        return jobName;
    }

    private static class JobParameters extends Gsonable {
        @Nullable
        String userFilters;
        @Nullable
        String groupFilters;
        boolean onlyUnassignedUsers;
        boolean filterUsersByGroups;
        boolean filterGroupsByUsers;
        boolean filterForGroupAdmin;

        public static JobParameters fromJson(@Nonnull String serialized) {
            return GsonUtil.getGsonWithModifiedDateSerializer().fromJson(serialized, JobParameters.class);
        }
    }

    @Override
    public boolean isUserJob() {
        return true;
    }


    @Override
    protected void execute(PersistentJob job) throws Exception {
        final JobParameters params = JobParameters.fromJson(job._parameter().getNotEmpty());

        try (final SXSSFWorkbook wb = new SXSSFWorkbook()) {
            try {
                final ExcelExporter exporter = new ExcelExporter();

                wb.setCompressTempFiles(true);
                final Sheet sheetUsersGroupsMatrix = wb.createSheet(groupMembershipsTabName.get());
                userExcelSheetDefinition.setUserInfoColumnWidth(sheetUsersGroupsMatrix);

                final CandidateUsersAndGroups usersAndGroups = new CandidateUserAndGroupSearch(params.userFilters, params.groupFilters, params.onlyUnassignedUsers, params.filterUsersByGroups, params.filterGroupsByUsers).getUsersAndGroups();

                final List<Group> groups = Streams.stream(Group.SCHEMA.getEntitiesById(usersAndGroups.getGroupIds(), false))
                    .filter(params.filterForGroupAdmin ? group -> group.isAdministratorOfThisGroup(SessionLocal.getUser()) : group -> true)
                    .collect(Collectors.toList());
                Iterator<Person> persons = Person.SCHEMA.getEntitiesById(usersAndGroups.getUserIds(), false).iterator();

                createFirstRowWithGroupNames(sheetUsersGroupsMatrix, groups, getHeaderStyle(wb));

                for (int rowNumber = 1; persons.hasNext(); rowNumber++) {
                    Person user = persons.next();
                    final Row personMembershipRow = sheetUsersGroupsMatrix.createRow(rowNumber);
                    personNameInFirstCellsOfRow(personMembershipRow, user, getHeaderStyle(wb));
                    personMembershipsInRow(personMembershipRow, groups, user);
                }
                exporter.writeToWorkbook(wb);
                final File exportedFile = writeToFile(wb);

                PersistentEntity.doOnWritableCopyAndPersistIfModified(job, j -> j._downloadFileName().set(exportedFile.getAbsolutePath()));
                job.logHtml(Template.getString(DownloadExportHelper.downloadLink(job, exportedFile.getName())));
            } finally {
                wb.dispose();
            }
        }
    }

    @Nonnull
    private File writeToFile(Workbook wb) throws IOException {
        File dir = TenantResources.INSTANCE().makeTemporaryUploadFolder();
        File excel = Utilities.getPathFile(dir, excelFileName.get() + '.' + XSSFWorkbookType.XLSX.getExtension());
        try (FileOutputStream fileOutputStream = new FileOutputStream(excel)) {
            wb.write(fileOutputStream);
        }
        return excel;
    }

    private void createFirstRowWithGroupNames(Sheet sheetUsersGroupMatrix, List<Group> groups, CellStyle rowStyle) {
        headerCells(sheetUsersGroupMatrix.createRow(0), groups, rowStyle);
    }


    /**
     * Creates and starts an {@link Export2ExcelJob} in a separate thread.
     * @param userFilters set in the group user matrix
     * @param groupFilters set in the group user matrix
     * @param onlyUnassignedUsers filter set in the group user matrix
     * @param filterUsersByGroups filter set in the group user matrix
     * @param filterGroupsByUsers filter set in the group user matrix
     * @param filterForGroupAdmin allows to filter for groups in the export in which the user who triggered the export is admin.
     * @return the started {@link Export2ExcelJob} job.
     */
    @Nonnull
    public static PersistentJob createJobAndStartInSeparateThread(@Nullable String userFilters, @Nullable String groupFilters, boolean onlyUnassignedUsers, boolean filterUsersByGroups, boolean filterGroupsByUsers, boolean filterForGroupAdmin) {
        return PersistentJob.createJobAndStartInSeparateThread(Export2ExcelJob.class, encodeParams(userFilters, groupFilters, onlyUnassignedUsers, filterUsersByGroups, filterGroupsByUsers, filterForGroupAdmin));
    }
    /**
     * Encodes the job parameters.
     * @param userFilters set in the group user matrix
     * @param groupFilters set in the group user matrix
     * @param onlyUnassignedUsers filter set in the group user matrix
     * @param filterUsersByGroups filter set in the group user matrix
     * @param filterGroupsByUsers filter set in the group user matrix
     * @param filterForGroupAdmin allows to filter for groups in the export in which the user who triggered the export is admin.
     * @return created {@link JobParameters} as Json.
     */
    @Nonnull
    public static String encodeParams(@Nullable String userFilters, @Nullable String groupFilters, boolean onlyUnassignedUsers, boolean filterUsersByGroups, boolean filterGroupsByUsers, boolean filterForGroupAdmin) {
        final JobParameters params = new JobParameters();
        params.userFilters = userFilters;
        params.groupFilters = groupFilters;
        params.onlyUnassignedUsers = onlyUnassignedUsers;
        params.filterUsersByGroups = filterUsersByGroups;
        params.filterGroupsByUsers = filterGroupsByUsers;
        params.filterForGroupAdmin = filterForGroupAdmin;
        return params.toJson();
    }


    private void headerCells(Row row, List<Group> groups, CellStyle style) {
        userExcelSheetDefinition.createHeaderCells(row, style);
        int lastUserColumnIndex = userExcelSheetDefinition.getLastColumnIndex() + 1;
        for (int i = 0; i < groups.size(); i++) {
            Cell c = row.createCell(i + lastUserColumnIndex);
            c.setCellStyle(style);
            c.setCellValue(groups.get(i)._name().get());
        }
    }

    private void personNameInFirstCellsOfRow(Row row, Person person, CellStyle style) {
        userExcelSheetDefinition.createUserCells(row, style, person);
    }

    private void personMembershipsInRow(Row row, List<Group> groups, Person user) {
        int index = userExcelSheetDefinition.getLastColumnIndex() + 1;
        for (Group group : groups) {
            Cell singleMembership = row.createCell(index++);
            activeDirectPersonMembership(user, group, singleMembership);
        }
    }

    private void activeDirectPersonMembership(Person user, Group group, Cell singleMembership) {
        if (group.isActiveMemberInThisGroup(user)) {
            singleMembership.setCellValue(Boolean.TRUE);
        }
    }

    private CellStyle getHeaderStyle(SXSSFWorkbook wb) {
        Font font = wb.createFont();
        font.setBold(true);
        CellStyle cellStyle = wb.createCellStyle();
        cellStyle.setWrapText(true);
        cellStyle.setFont(font);
        cellStyle.setAlignment(HorizontalAlignment.CENTER);
        cellStyle.setVerticalAlignment(VerticalAlignment.BOTTOM);
        return cellStyle;
    }

}

######### end - content of file "group-user-matrix/exporting/Export2ExcelJob.java" #########


######### start - content of file "group-user-matrix/exporting/SubmitExportHandler.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */
package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.exporting;

import javax.annotation.Nullable;

import cf.cplace.platform.core.application.authorization.GlobalPermissions;
import cf.cplace.platform.core.application.job.assets.PersistentJob;
import cf.cplace.platform.core.server.request.Parameters;
import cf.cplace.platform.core.server.session.SessionLocal;
import cf.cplace.platform.core.frontend.handler.station.template.JobCreatedJsonPage;
import cf.cplace.platform.core.frontend.handler.station.Station;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.LoadDataHandler;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.core.frontend.handler.ProtectedActionException;

/**
 * Subsequently to the {@link Export2ExcelHandler}, creates and starts the {@link Export2ExcelJob}.
 */
public class SubmitExportHandler extends LoadDataHandler {

    private static final Message label = new Message() {
    };

    private Station EXPORT = new JobCreatedJsonPage() {
        @Override
        protected PersistentJob getJob() {
            return job;
        }
    };

    private PersistentJob job;

    @Override
    protected void additionalCheckAccess() {
        SessionLocal.checkLoggedIn();
        if (!GlobalPermissions.mayExportGroupMemberships()) {
            throw new ProtectedActionException();
        }
    }

    @Override
    public Station doBusinessLogic() {
        boolean filterForGroupAdmin = Parameters.getBoolean("filterForGroupAdmin", false);
        job = Export2ExcelJob.createJobAndStartInSeparateThread(groupUserMatrixFilters._userFilters().isEmpty() ? null : groupUserMatrixFilters._userFilters().get(),
            groupUserMatrixFilters._groupFilters().isEmpty() ? null : groupUserMatrixFilters._groupFilters().get(),
            groupUserMatrixFilters._onlyUnassignedUsers().get(),
            groupUserMatrixFilters._filterUsersByGroups().get(),
            groupUserMatrixFilters._filterGroupsByUsers().get(),
            filterForGroupAdmin);
        return EXPORT;
    }

    @Nullable
    @Override
    public Message getTargetLabel() {
        return label;
    }

    @Nullable
    @Override
    public String getActionIconName() {
        return "fa-download";
    }
}

######### end - content of file "group-user-matrix/exporting/SubmitExportHandler.java" #########


######### start - content of file "group-user-matrix/exporting/export2Excel.html" #########
<form method="post" action="$submitUrl$" class="tricia-edit-form modal-form form-horizontal" cplace-form-provider>
    $[defaultDialogHeader()$
    <h1>$(title)$</h1>
    $defaultDialogHeader]$
    <div class="modal-body">
        <cplace-control-component-boolean name="filterForGroupAdmin"></cplace-control-component-boolean>
        $(filterForGroupAdminHelp)$
        <input type="hidden" name="userFilters" value="$userFilters$" id="userFilters"/>
        <input type="hidden" name="groupFilters" value="$groupFilters$" id="groupFilters"/>
    </div>
    $defaultDialogButtonBar(submit="next",cancel="cancel")$
</form>

######### end - content of file "group-user-matrix/exporting/export2Excel.html" #########


######### start - content of file "group-user-matrix/importing/ImportFromExcelHandler.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */
package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.importing;

import javax.annotation.Nullable;

import cf.cplace.platform.core.application.authorization.GlobalPermissions;
import cf.cplace.platform.core.server.session.SessionLocal;
import cf.cplace.platform.core.frontend.handler.Forwarder;
import cf.cplace.platform.core.frontend.handler.Handler;
import cf.cplace.platform.core.frontend.handler.station.template.JsonPage;
import cf.cplace.platform.core.frontend.handler.station.Station;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.core.frontend.handler.ProtectedActionException;
import cf.cplace.platform.commonlib.util.text.Escaping;
import cf.cplace.platform.commonlib.template.PrintSubstitution;
import cf.cplace.platform.commonlib.template.Template;

/**
 * Entry point for the import of group memberships. Shows the user a modal that allows a user to select an excel file to be imported.
 * Subsequently forwards to the {@link SubmitImportHandler}.
 */
public class ImportFromExcelHandler extends Handler {

    private static final Message label = new Message() {
    };

    private static final Message notAllowedToImport = new Message() {
    };

    final Station SHOW = new JsonPage() {
        @Override
        public void putSubstitutions(Template template) {
            template.put("submitUrl", PrintSubstitution.printing(Escaping.htmlAttribute, () -> Forwarder.getFullUrl(SubmitImportHandler.class)));
        }
    };

    @Override
    public void checkAccess() {
        SessionLocal.checkLoggedIn();
        if (!GlobalPermissions.mayImportGroupMemberships()) {
            throw new ProtectedActionException(notAllowedToImport.get());
        }
    }

    @Override
    public Station doBusinessLogic() {
        return SHOW;
    }

    @Override
    public Message getTargetLabel() {
        return label;
    }

    @Nullable
    @Override
    public String getActionIconName() {
        return "fa-upload";
    }
}

######### end - content of file "group-user-matrix/importing/ImportFromExcelHandler.java" #########


######### start - content of file "group-user-matrix/importing/ImportFromExcelJob.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.importing;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.apache.commons.lang3.StringUtils;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.json.JSONObject;

import com.google.common.base.Predicates;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Streams;

import cf.cplace.platform.core.application.job.assets.PersistentJob;
import cf.cplace.platform.core.application.job.QueuedBatchJob;
import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.Membership;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.application.principal.Principal;
import cf.cplace.platform.core.server.session.SessionLocal;
import cf.cplace.platform.frontend.handler.custom.ExcelUtilities;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.CandidateGroupSearch;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.UserExcelSheetDefinition;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.commonlib.internationalization.ParameterizedMessage;
import cf.cplace.platform.core.datamodel.builtin.PersistentSchema;
import cf.cplace.platform.commonlib.util.log.CountAndThrottleLog;
import cf.cplace.platform.core.application.job.data.DistributionType;
import cf.cplace.platform.core.application.job.data.ShutdownCancellationType;
import cf.cplace.platform.commonlib.util.text.Escaping;
import cf.cplace.platform.commonlib.util.text.SafeHtml;
import cf.cplace.platform.commonlib.util.collect.MoreCollectors;

/**
 * Imports direct group memberships from an excel file.
 * The format of the excel file to be imported is described in {@link UserExcelSheetDefinition}.
 */
public class ImportFromExcelJob extends QueuedBatchJob {

    private static final Message jobName = new Message() {
    };
    private static final ParameterizedMessage notAllowed = new ParameterizedMessage() {
    };
    private static final long TIME_STEPS_IN_MILLIS = 5_000;
    private static final int COUNT_STEPS = 1;
    private static final String PATH_KEY = "path";

    private final UserExcelSheetDefinition userExcelSheetDefinition = new UserExcelSheetDefinition();

    private PersistentJob job;

    private List<@SafeHtml String> messagesToAppend =  new ArrayList<>();

    @Nullable
    @Override
    protected Message getJobName(String parameter) {
        return jobName;
    }

    @Nonnull
    @Override
    public DistributionType getDistributionType(@Nullable String parameter) {
        return DistributionType.DISTRIBUTED;
    }

    /**
     * Encodes the job parameters.
     * @param pathToExcel path to the excel file that contains users, groups and group memberships to be imported. The file will be deleted at the end of the job, so only provide temporary files!
     * @return created string containing the parameters formated as Json.
     */
    @Nonnull
    public static String paramsAsJson(String pathToExcel) {
        JSONObject jo = new JSONObject();
        jo.put(PATH_KEY, pathToExcel);
        return jo.toString();
    }

    @Override
    protected void execute(PersistentJob job) throws Exception {
        this.job = job;
        this.job.logText("Info: Reading input file...");
        JSONObject jo = new JSONObject(job._parameter().get());
        final File importFile = new File(jo.getString(PATH_KEY));

        try(final Workbook wb = ExcelUtilities.createWorkbookFromFileWithType(importFile, ExcelUtilities.WORKBOOK_TYPE_XSSF)) {
            final Sheet firstSheet = wb.getSheetAt(0);

            final Map<String, Group> groupsMatrixMap = getGroups(firstSheet);
            final Map<String, Person> personsMatrixMap = getPersons(firstSheet);
            final Map<String, List<String>> personWithMemberships = createPersonsWithMemberships(firstSheet, personsMatrixMap);

            this.job.logText(String.format("Info: Updating memberships: Looking at '%s' memberships...", groupsMatrixMap.entrySet().size() * personsMatrixMap.entrySet().size()));
            CountAndThrottleLog countAndThrottleLog = new CountAndThrottleLog(TIME_STEPS_IN_MILLIS, COUNT_STEPS);
            personsMatrixMap.values().forEach(person -> updateGroupMembershipsForPerson(groupsMatrixMap, personWithMemberships, countAndThrottleLog, person));
            if (countAndThrottleLog.hasUnloggedInc()) {
                this.job.logHtml(String.format("Processed %s memberships in total: Changes done: <br>%s", countAndThrottleLog.getCount(), String.join("<br>", messagesToAppend)));
            }
        } finally {
            importFile.delete();
        }
    }

    private void updateGroupMembershipsForPerson(Map<String, Group> groupsMatrixMap, Map<String, List<String>> personWithMemberships, CountAndThrottleLog countAndThrottleLog, Person person) {
        final Set<String> groupsWithMembership = new HashSet<>(personWithMemberships.get(person.getUid()));
        groupsMatrixMap.values().forEach(group -> {
            membershipUpdate(person, groupsWithMembership, group, countAndThrottleLog);
        });
    }

    @Override
    public boolean isUserJob() {
        return true;
    }

    @Nonnull
    @Override
    public ShutdownCancellationType getShutdownCancellationType(@Nullable String parameter) {
        return ShutdownCancellationType.NOT_SUPPORTED;
    }

    @Nonnull
    private Map<String, List<String>> createPersonsWithMemberships(Sheet firstSheet, Map<String, Person> personsMatrixMap) {
        final Row headerRowWithGroupNames = firstSheet.getRow(0);
        final Iterator<Row> rowIterator = firstSheet.rowIterator();
        skipRowWithGroupNames(rowIterator);
        Map<String, List<String>> personWithMemberships = Maps.newHashMap();
        // for each row - were row is list of memberships for user
        while (rowIterator.hasNext()) {
            Row rowWithMemberships = rowIterator.next();
            Optional.ofNullable(getPersonEmail(rowWithMemberships)).map(personsMatrixMap::get).ifPresent(person -> {
                final List<String> userMemberships = collectSinglePersonMemberships(headerRowWithGroupNames, rowWithMemberships, person.getName());
                personWithMemberships.put(person.getUid(), userMemberships);
            });
        }
        return personWithMemberships;
    }

    @Nullable
    private String getPersonEmail(Row rowWithMemberships) {
        return Optional
                .ofNullable(rowWithMemberships
                        .getCell(userExcelSheetDefinition.getLastColumnIndex()))
                .map(Cell::getStringCellValue)
                .map(String::trim)
                .orElse(null);
    }

    @Nonnull
    private List<String> collectSinglePersonMemberships(Row headerRowWithGroupNames, Row rowWithMemberships, String personName) {
        final List<String> activeUserMemberships = Lists.newArrayList();
        final Iterator<Cell> cellsWithMemberships = rowWithMemberships.iterator();
        skipUserItems(cellsWithMemberships);
        while (cellsWithMemberships.hasNext()) {
            final Cell membershipValue = cellsWithMemberships.next();
            final int columnIndex = membershipValue.getColumnIndex();
            final Cell groupName = headerRowWithGroupNames.getCell(columnIndex);
            boolean isMember;
            try {
                isMember = membershipValue.getBooleanCellValue();
            } catch (IllegalStateException e) {
                this.job.logText(String.format("Error: Membership cell for user: '%s' and group: '%s' contains an invalid value. Please enter a valid value", personName, groupName != null ? groupName.getStringCellValue() : "undefined"));
                throw e;
            }
            if (groupName != null && isMember) {
                activeUserMemberships.add(groupName.getStringCellValue());
            }
        }
        return activeUserMemberships;
    }

    private void membershipUpdate(Person person, Set<String> groupsWithMembership, Group group, CountAndThrottleLog countAndThrottleLog) {
        final String groupName = group.getName();
        final String personName = person.getName();
        if (group.getEntityPermissions().mayEdit()) {
            final Membership existingMembership = Membership.getMembership(group, person);
            final boolean shouldBecomeDirectMember = groupsWithMembership.contains(groupName);

            if (shouldBecomeDirectMember && existingMembership == null) {
                Person.createMembership(person, group, "Imported from excel");
                messagesToAppend.add(String.format("Created: %s to: %s", Escaping.html.escape(personName), Escaping.html.escape(groupName)));
            } else if (!shouldBecomeDirectMember && existingMembership != null && existingMembership.canBeDeleted() == null) {
                messagesToAppend.add(String.format("Removed: %s from: %s", Escaping.html.escape(personName), Escaping.html.escape(groupName)));
                existingMembership.remove();
            }
        } else {
            messagesToAppend.add(notAllowed.setParameters(groupName).getHtmlSafe());
        }
        if (countAndThrottleLog.incAndShouldLog()) {
            this.job.logHtml(String.format("Processed %s memberships in total: Changes done: <br>%s", countAndThrottleLog.getCount() - 1, String.join("<br>", messagesToAppend)));
            messagesToAppend.clear();
        }
    }

    @Nonnull
    private Map<String, Group> getGroups(Sheet firstSheet) {
        final Row headerRowWithGroupNames = firstSheet.getRow(0);
        final List<String> groupsNamesFromExcel = groupNamesFromExcel(headerRowWithGroupNames);
        final List<Group> existingGroupsFromExcel = new ArrayList<>();
        for (Iterable<String> batch : Iterables.partition(groupsNamesFromExcel, PersistentSchema.QUERY_ENTITIES_BATCH_SIZE)) {
            existingGroupsFromExcel.addAll(Group.SCHEMA.createQuery().where(Group.SCHEMA.prototype()._name().isIn(Lists.newArrayList(batch))).findList());
        }
        final Set<String> allVisibleForCurrentUser = new CandidateGroupSearch().findAll();
        Person user = SessionLocal.getUser();
        if (user == null) {
            this.job.logText("Error: Session has no user defined");
            throw new IllegalStateException("Session has no user defined");
        }
        final List<Group> filteredGroups = existingGroupsFromExcel.stream()
                .filter(group -> allVisibleForCurrentUser.contains(group.getId()))
                .filter(group -> group.isAdministratorOfThisGroup(user))
                .collect(Collectors.toList());
        final Map<String, Group> groupsMatrixMap = mapToNameOrdered(filteredGroups, group -> group._name().get());
        validateExcelGroups(groupsNamesFromExcel, groupsMatrixMap);

        return groupsMatrixMap;
    }

    @Nonnull
    private Map<String, Person> getPersons(Sheet firstSheet) {
        final List<String> personEmailFromExcel = personEmailFromExcel(firstSheet);
        final List<Person> existingPersonsFromExcel = new ArrayList<>();
        for (Iterable<String> batch : Iterables.partition(personEmailFromExcel, PersistentSchema.QUERY_ENTITIES_BATCH_SIZE)) {
            existingPersonsFromExcel.addAll(Person.SCHEMA.createQuery().where(Person.SCHEMA.prototype()._login().isIn(Lists.newArrayList(batch))).findList());
        }
        final Map<String, Person> personsMatrixMap = mapToNameOrdered(existingPersonsFromExcel, person -> person._login().get());
        validateExcelPersons(personEmailFromExcel, personsMatrixMap);
        return personsMatrixMap;
    }

    @Nonnull
    private List<String> personEmailFromExcel(Sheet firstSheet) {
        final Iterator<Row> rowIterator = firstSheet.rowIterator();
        skipRowWithGroupNames(rowIterator);
        return Streams.stream(rowIterator)
                .map(row -> row.getCell(userExcelSheetDefinition.getLastColumnIndex()))
                .filter(Objects::nonNull)
                .map(Cell::getStringCellValue).filter(StringUtils::isNotBlank)
                .map(String::trim)
                .collect(Collectors.toList());
    }

    @Nonnull
    private List<String> groupNamesFromExcel(Row headerRowWithGroupNames) {
        List<String> groupsNamesFromExcel = Lists.newArrayList();

        final Iterator<Cell> hederRowCellsIterator = headerRowWithGroupNames.iterator();
        // skip first cell in first row
        skipUserItems(hederRowCellsIterator);

        while (hederRowCellsIterator.hasNext()) {
            Cell cellWithGroupName = hederRowCellsIterator.next();
            final String groupName = cellWithGroupName.getStringCellValue().trim();
            if (StringUtils.isNotBlank(groupName))
                groupsNamesFromExcel.add(groupName);
        }
        return groupsNamesFromExcel;
    }

    private void skipRowWithGroupNames(Iterator<?> item) {
        if(item.hasNext())
            item.next();
    }

    private void skipUserItems(Iterator<?> item) {
        for(int i = 0; i <= userExcelSheetDefinition.getLastColumnIndex() && item.hasNext(); ++i)
            item.next();
    }

    @Nonnull
    private <T extends Principal> Map<String, T> mapToNameOrdered(List<T> itemsToMap, Function<T, String> functor) {
        return itemsToMap.stream()
                .sorted(Comparator.comparing(functor))
                .collect(MoreCollectors.toLinkedMap(functor, i -> i));
    }

    private void validateExcelGroups(List<String> groupsFromExcel, final Map<String, Group> groupsMatrixMap) {
        if (groupsFromExcel.stream().distinct().count() != groupsFromExcel.size()) {
            this.job.logText("Error: Multiple entries in the excel for same group are not allowed");
            throw new IllegalStateException("Multiple entries in the excel for same group are not allowed");
        }
        if (groupsFromExcel.size() != groupsMatrixMap.size()) {
            job.logText("Following groups doesn't exist or are misspelled or your are not permitted: ");
            final List<String> notValid = validate(groupsFromExcel, groupsMatrixMap);
            if (!notValid.isEmpty()) {
                job.logHtmlWithoutTimestamp(notValid.stream().map(Escaping.html::escape).collect(Collectors.joining("<br/>")));
            }
        }
    }

    private void validateExcelPersons(List<String> personsFromExcel, final Map<String, Person> personsMatrixMap) {
        if (personsFromExcel.stream().distinct().count() != personsFromExcel.size()) {
            this.job.logText("Error: Multiple entries in the excel for same login are not allowed");
            throw new IllegalStateException("Multiple entries in the excel for same login are not allowed");
        }
        if (personsFromExcel.size() != personsMatrixMap.size()) {
            job.logText("Following persons doesn't exist or are misspelled: ");
            final List<String> notValid = validate(personsFromExcel, personsMatrixMap);
            if (!notValid.isEmpty()) {
                job.logHtmlWithoutTimestamp(notValid.stream().map(Escaping.html::escape).collect(Collectors.joining("<br/>")));
            }
        }
    }

    @Nonnull
    private List<String> validate(List<String> personsFromExcel, final Map<String, ?> personsMatrixMap) {
        return personsFromExcel.stream()
            .filter(Predicates.not(personsMatrixMap::containsKey))
            .collect(Collectors.toList());
    }
}

######### end - content of file "group-user-matrix/importing/ImportFromExcelJob.java" #########


######### start - content of file "group-user-matrix/importing/SubmitImportHandler.java" #########
/*
 * Copyright 2019, collaboration Factory AG. All rights reserved.
 */
package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.importing;

import java.io.File;
import java.io.IOException;

import org.apache.poi.xssf.usermodel.XSSFWorkbookType;
import org.springframework.web.multipart.MultipartFile;

import cf.cplace.platform.core.application.job.assets.PersistentJob;
import cf.cplace.platform.core.server.request.RequestLocal;
import cf.cplace.platform.core.frontend.handler.Forwarder;
import cf.cplace.platform.core.frontend.handler.Handler;
import cf.cplace.platform.core.frontend.handler.station.template.JobCreatedJsonPage;
import cf.cplace.platform.core.frontend.handler.station.Line;
import cf.cplace.platform.core.frontend.handler.PostOnlyHandler;
import cf.cplace.platform.core.frontend.handler.station.Station;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.ViewHandler;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.core.server.TenantResources;
import cf.cplace.platform.commonlib.util.Utilities;

/**
 * Subsequently to the {@link ImportFromExcelHandler}, creates and starts the {@link ImportFromExcelJob}.
 */
public class SubmitImportHandler extends Handler implements PostOnlyHandler {

    private static final Message noFile = new Message() {
    };

    final Station SUCCESS = new JobCreatedJsonPage() {
        @Override
        protected PersistentJob getJob() {
            return job;
        }

        @Override
        protected String getTargetUrl() {
            return Forwarder.getFullUrl(ViewHandler.class);
        }
    };
    final Station INVALID = new Line() {
        @Override
        public void next(Forwarder f) {
            f.go(ImportFromExcelHandler.class);
        }
    };

    private MultipartFile uploadedFile;

    private PersistentJob job;

    @Override
    public void checkAccess() {
        uploadedFile = RequestLocal.getUploadedFile();
    }

    @Override
    public Station doBusinessLogic() {
        if (!isValidAndAddGenerateErrorMessagesIfNot()) {
            return INVALID;
        }

        String name = String.format("group_membership_import_%s.%s", Utilities.randomId(), XSSFWorkbookType.XLSX.getExtension());
        File destinationFile = new File(TenantResources.INSTANCE().getOrCreateUploadDirectory(), name);

        try {
            uploadedFile.transferTo(destinationFile.toPath());
        } catch (IOException e) {
            throw new IllegalStateException("failed to copy uploaded file", e);
        }

        job = PersistentJob.createJobAndStartInSeparateThread(ImportFromExcelJob.class, ImportFromExcelJob.paramsAsJson(destinationFile.getAbsolutePath()));
        return SUCCESS;

    }

    private static final Message wrongType = new Message() {
    };

    private boolean isValidAndAddGenerateErrorMessagesIfNot() {
        if (uploadedFile == null) {
            RequestLocal.addErrorMessage(noFile.get());
            return false;
        }

        if (!uploadedFile.getOriginalFilename().endsWith(".xlsx")) {
            RequestLocal.addErrorMessage(wrongType.get());
            return false;
        }
        return true;
    }
}

######### end - content of file "group-user-matrix/importing/SubmitImportHandler.java" #########


######### start - content of file "group-user-matrix/importing/importFromExcel.html" #########
<form method="post" action="$submitUrl$" enctype="multipart/form-data" class="tricia-edit-form modal-form form-horizontal" cplace-validated-form cplace-form-provider>
	$[defaultDialogHeader()$
		<h1>$(title)$</h1>
	$defaultDialogHeader]$
	<div class="modal-body">
		$messages()$
		$showPart1()$
			$(excelFile)$
		$showPart2()$
			<input type="file" name="file" size="40" style="max-width:315px;" class="required" accept=".xlsx"/>
		$showPart3()$
	</div>
	$defaultDialogButtonBar(submit="save",cancel="cancel")$
</form>

######### end - content of file "group-user-matrix/importing/importFromExcel.html" #########


######### start - content of file "group-user-matrix/state/Data.java" #########
/*
 * Copyright 2016, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state;

import java.util.List;
import java.util.Map;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import cf.cplace.platform.commonlib.util.io.gson.GsonUtil;

public class Data {
    public boolean excessiveData = false;

    public boolean excessiveDataUsers = false;

    public boolean excessiveDataGroups = false;

    public final Map<String, Map<String, Edge>> userId2groupId2edge = Maps.newHashMap();

    public final List<Node> users = Lists.newArrayList();

    public final List<Node> groups = Lists.newArrayList();

    public int numberOfFilteredUsers = -1;

    public int numberOfFilteredGroups = -1;

    public int groupPage = 1;

    public int userPage = 1;

    public String toJson() {
        return GsonUtil.getGsonWithModifiedDateSerializer().toJson(this, this.getClass());
    }
}

######### end - content of file "group-user-matrix/state/Data.java" #########


######### start - content of file "group-user-matrix/state/Edge.java" #########
/*
 * Copyright 2016, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state;

import javax.annotation.Nonnull;

import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.commonlib.internationalization.Message;
import cf.cplace.platform.commonlib.internationalization.ParameterizedMessage;
import cf.cplace.platform.commonlib.util.io.gson.GsonUtil;

public class Edge {

    private static final Message isAdminInfo = new Message() {
    };

    private static final ParameterizedMessage indirectMembershipInfo = new ParameterizedMessage() {
    };

    public String toJson() {
        return GsonUtil.getGsonWithModifiedDateSerializer().toJson(this, this.getClass());
    }

    String userId;

    String groupId;

    boolean directMembership;

    String iconClass;

    String tooltip;

    boolean isAdmin;

    private static Edge createEdge(Person user, Group group, boolean isGroupAdmin) {
        Edge edge = new Edge();
        edge.userId = user.getId();
        edge.groupId = group.getId();
        edge.isAdmin = isGroupAdmin;
        return edge;
    }

    @Nonnull
    public static Edge createDirectMembershipEdge(Person user, Group group, boolean isGroupAdmin) {
        final Edge edge = createEdge(user, group, isGroupAdmin);
        edge.directMembership = true;
        edge.iconClass = "fa-check";
        return edge;
    }

    @Nonnull
    public static Edge createIsAdminEdge(Person user, Group group) {
        final Edge edge = createEdge(user, group, true);
        edge.directMembership = false;
        edge.iconClass = "";
        edge.isAdmin = true;
        edge.tooltip = isAdminInfo.get();
        return edge;
    }

    @Nonnull
    public static Edge createInheritedMembershipEdge(Person user, Group indirectGroup, Group group, boolean isGroupAdmin) {
        final Edge edge = createEdge(user, group, isGroupAdmin);
        edge.directMembership = false;
        edge.isAdmin = isGroupAdmin;
        edge.tooltip = indirectMembershipInfo.setParameters(indirectGroup.getName()).get();
        edge.iconClass = "fa-check-square";
        return edge;
    }
}

######### end - content of file "group-user-matrix/state/Edge.java" #########


######### start - content of file "group-user-matrix/state/Node.java" #########
/*
 * Copyright 2016, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state;

import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.application.principal.Principal;

public class Node {
    public final String id;

    public final String name;

    public final String url;

    public boolean active = false;

    public Node(Principal p) {
        id = p.getId();
        name = p.getName();
        url = p.getUrl();
        if (p instanceof Person person) {
            active = person.isActiveAccount();
        }
    }
}

######### end - content of file "group-user-matrix/state/Node.java" #########


######### start - content of file "group-user-matrix/state/State.java" #########
/*
 * Copyright 2016, collaboration Factory AG. All rights reserved.
 */

package cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.state;

import cf.cplace.platform.core.application.application.Application;
import cf.cplace.platform.core.datamodel.builtin.assets.readaccess.ReadProtected;
import cf.cplace.platform.core.application.principal.Group;
import cf.cplace.platform.core.application.principal.Person;
import cf.cplace.platform.core.frontend.handler.Forwarder;
import cf.cplace.platform.frontend.handler.flexigrid.TableColumnFilterDialogHandler;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.FilterGroupsSpecificationHandler;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.FilterUsersSpecificationHandler;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.LoadDataHandler;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.ToggleMembershipHandler;
import cf.cplace.platform.frontend.handler.group.overview.groupUserMatrix.exporting.Export2ExcelHandler;
import cf.cplace.platform.frontend.handler.page.NewPageConfig;
import cf.cplace.platform.commonlib.util.io.gson.GsonUtil;
import cf.cplace.platform.commonlib.util.NameValue;

public class State {

    public Data data;

    public boolean userFiltersEnabled = true;

    public final String toggleMembershipUrl = Forwarder.getFullUrl(ToggleMembershipHandler.class);

    public final String filterUsersDialogUrl = Forwarder.getFullUrl(TableColumnFilterDialogHandler.class,
            new NameValue(NewPageConfig.FLEXI_COMPONENT_IDENTIFIER, Forwarder.getFullUrl(FilterUsersSpecificationHandler.class)),
            new NameValue("columnName", Person.SCHEMA.prototype()._name().getName())
    );

    public final String filterGroupsDialogUrl = Forwarder.getFullUrl(TableColumnFilterDialogHandler.class,
            new NameValue(NewPageConfig.FLEXI_COMPONENT_IDENTIFIER, Forwarder.getFullUrl(FilterGroupsSpecificationHandler.class)),
            new NameValue("columnName", Group.SCHEMA.prototype()._name().getName())
    );

    public final String loadDataUrl = Forwarder.getFullUrl(LoadDataHandler.class);

    public final String exportDataUrl = Forwarder.getFullUrl(Export2ExcelHandler.class);

    public final boolean mayExportGroupMemberships = ReadProtected.sessionUserMatchesOneOfThese(Application.getApplication()._mayExportGroupMemberships().getAssets());

    public String toJson() {
        return GsonUtil.getGsonWithModifiedDateSerializer().toJson(this, this.getClass());
    }
}

######### end - content of file "group-user-matrix/state/State.java" #########


######### start - content of file "group-user-matrix/view.html" #########
<div class="cplace-group-user-matrix-wrapper" cplace-group-user-matrix="$state$">
    <div class="alert alert-warning" ng-cloak ng-if="matrixCtrl.state.data.excessiveData">
        $[(too_many_entries)$
        {{matrixCtrl.state.data.users.length}} $|$ {{matrixCtrl.state.data.numberOfFilteredUsers}} $|$ {{matrixCtrl.state.data.groups.length}} $|$
        {{matrixCtrl.state.data.numberOfFilteredGroups}}
        $too_many_entries]$
    </div>

    <div class="cplace-group-user-matrix">
        <div class="cplace-fixed-pane-scroll" cplace-fixed-pane-scroll>
            <cplace-fixed-pane-corner>
                <div class="info-area">
                    <div class="matrix-legends">
                        <h6>$(legend)$</h6>
                        <ul class="legends">
                            <li>
                                <i class="fa fa-check"></i> $(member)$
                            </li>
                            <li>
                                <i class="fa fa-check-square-o"></i> $(indirect_member)$
                            </li>
                            <li>
                                <i class="fa fa-square"></i> $(group_admin)$
                            </li>
                        </ul>
                    </div>
                    <div class="column-title header-title">
                        <div class="column-header">
                            <span><i class="far fa-users"></i> $(group)$</span>
                            <div class="btn-group btn-group-xs pull-right">
                                <a href="" class="btn btn-xs column_filter" ng-click="::matrixCtrl.filterGroups()"
                                   ng-class="matrixCtrl.hasGroupFilters() ? 'btn-primary' : 'btn-default'">
                                    <i class="fa fa-filter"></i>
                                </a>
                                <a href="" class="btn btn-xs column_filter" ng-click="::matrixCtrl.filterGroupsForSelectedUsers()"
                                   ng-class="matrixCtrl.filterGroupsByUsers ? 'btn-primary' : 'btn-default'"
                                   cplace-tooltipster="$(filter_groups_for_selected_users)$">
                                <span class="cf-stack">
                                    <i class="far fa-users main"></i>
                                    <i class="fa fa-filter stacked"></i>
                                </span>
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="gap-filler"></div>
                    <div class="row-title header-title">
                        <div class="btn-group btn-group-xs pull-right" ng-if="::matrixCtrl.state.userFiltersEnabled">
                            <a href="" class="btn " ng-click="::matrixCtrl.filterUsers()"
                               ng-class="matrixCtrl.hasUserFilters() ? 'btn-primary' : 'btn-default'">
                                <i class="fa fa-fw fa-filter"></i>
                            </a>
                            <a href="" class="btn" ng-click="::matrixCtrl.toggleOnlyUnassignedUsers()"
                               ng-class="matrixCtrl.onlyUnassignedUsers ? 'btn-primary' : 'btn-default'"
                               cplace-tooltipster="$(only_unassigned_users)$">
                                <i class="fa fa-fw fa-user-times"></i>
                            </a>
                            <a href="" class="btn" ng-click="::matrixCtrl.filterUsersForSelectedGroups()"
                               ng-class="matrixCtrl.filterUsersByGroups ? 'btn-primary' : 'btn-default'"
                               cplace-tooltipster="$(filter_users_for_selected_groups)$">
                                    <span class="cf-stack">
                                            <i class="fa fa-fw fa-user main"></i>
                                            <i class="fa fa-fw fa-filter stacked"></i>
                                        </span>
                            </a>
                            <a href="" class="btn btn-warning btn-xs export-button"
                               ng-show="matrixCtrl.showExportMembershipsButton()"
                               ng-click="::matrixCtrl.exportData()"
                               ng-cloak
                               cplace-tooltipster="$(export_memberships_tooltip)$">
                                <i class="fa fa-fw fa-download"></i>
                            </a>
                        </div>
                        <div class="header-user-message">
                            <i class="fa fa-fw fa-user"></i> $(user)$
                        </div>
                        <div class="cell-empty"></div>
                    </div>
                </div>
            </cplace-fixed-pane-corner>
            <cplace-fixed-pane-top>
                <div class="matrix-header-top">
                    <table class="column-headers" cellpadding="0" ng-cloak>
                        <tr>
                            <th ng-repeat="group in matrixCtrl.state.data.groups"
                                cplace-on-finish-render="{{::matrixCtrl.state.data.groups.length}}"
                                after-render-event="{{::matrixCtrl.afterRenderEvent}}">
                                <div class="column-header-wrapper">
                                    <div class="column-header" cplace-tooltipster>
                                        <a ng-href="{{::group.url}}">{{::group.name}}</a>
                                    </div>
                                </div>
                                <div class="text-center helper-arrow">
                                    <i class="fa fa-arrow-up"></i>
                                </div>
                            </th>
                            <th ng-if="matrixCtrl.state.data.excessiveDataGroups">
                                <div class="column-header-wrapper">
                                    <div class="column-header">
                                        <button class="btn btn-xs btn-primary" ng-click="matrixCtrl.loadMore('group')">$(load_more)$</button>
                                    </div>
                                </div>
                            </th>
                        </tr>
                    </table>
                </div>
            </cplace-fixed-pane-top>
            <cplace-fixed-pane-left>
                <div class="matrix-header-left">
                    <table class="row-headers" cellpadding="0" ng-cloak>
                        <tr ng-repeat="user in matrixCtrl.state.data.users">
                            <th>
                                <div class="row-header" cplace-tooltipster>
                                    <a ng-href="{{::user.url}}">{{::user.name}}
                                        <span class="tricia-user-disabled" cplace-tooltipster="$(disabled)$" ng-if="!user.active">
	                                        <i class="fa fa-times"></i>
                                        </span>
                                    </a>
                                </div>
                            </th>
                            <td class="helper-arrow">
                                <i class="fa fa-arrow-right"></i>
                            </td>
                        </tr>
                        <tr ng-if="matrixCtrl.state.data.excessiveDataUsers">
                            <td colspan="2">
                                <div class="load-more">
                                    <button class="btn btn-xs btn-primary" ng-click="matrixCtrl.loadMore('user')">$(load_more)$</button>
                                </div>
                            </td>
                        </tr>
                    </table>
                </div>
            </cplace-fixed-pane-left>
            <cplace-fixed-pane-content>
                <table class="matrix-data" cellpadding="0" ng-cloak>
                    <tr ng-repeat="user in matrixCtrl.state.data.users">
                        <td class="edge-container" ng-repeat="group in matrixCtrl.state.data.groups"
                            ng-class="matrixCtrl.canBeToggledClass(user,group)" ng-click="::matrixCtrl.toggleEdge(user, group)">
                            <div class="cell-edge" ng-class="matrixCtrl.getEdge(user, group).isAdmin ? 'admin' : ''">
                                <i class="fa"
                                   ng-class="matrixCtrl.getEdge(user, group).iconClass"
                                   ng-if="matrixCtrl.getEdge(user, group)"
                                   cplace-tooltipster="{{matrixCtrl.getEdge(user, group).tooltip}}"></i>

                            </div>
                        </td>
                        <td class="cell-edge" ng-if="matrixCtrl.state.data.excessiveDataGroups">
                            &hellip;
                        </td>
                    </tr>
                    <tr ng-if="matrixCtrl.state.data.excessiveDataUsers">
                        <td class="cell-edge"
                            ng-repeat="group in matrixCtrl.state.data.groups">
                            &vellip;
                        </td>
                        <td class="cell-edge" ng-if="matrixCtrl.state.data.excessiveDataGroups">
                            &#x22F1;
                        </td>
                    </tr>
                </table>
                <div class="loading" ng-if="!matrixCtrl.state.data">
                    <i class="fa fa-spin fa-spinner"></i> <i>$(loading)$</i>
                </div>
            </cplace-fixed-pane-content>
        </div>
    </div>
</div>

######### end - content of file "group-user-matrix/view.html" #########

